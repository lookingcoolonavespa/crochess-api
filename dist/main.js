!function(Q,F){"object"==typeof exports&&"object"==typeof module?module.exports=F():"function"==typeof define&&define.amd?define([],F):"object"==typeof exports?exports.croChess=F():Q.croChess=F()}(this,(function(){return(()=>{"use strict";var __webpack_modules__={371:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"Gameboard\": () => (/* reexport */ src_Gameboard),\n  \"History\": () => (/* reexport */ History)\n});\n\n;// CONCATENATED MODULE: ./src/utils/helpers.ts\nfunction toXY(square) {\n  const [x, y] = square.split('');\n  return {\n    x: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'].indexOf(x.toLowerCase()),\n    y: Number(y)\n  };\n}\n\nfunction fromXY(coord) {\n  const {\n    x,\n    y\n  } = coord;\n  const col = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'][x];\n  if (!col) return '';\n  return col.concat(y.toString());\n}\n\nconst calcDistance = squareOne => squareTwo => {\n  const {\n    x: x1,\n    y: y1\n  } = toXY(squareOne);\n  const {\n    x: x2,\n    y: y2\n  } = toXY(squareTwo);\n  const xDiff = x1 - x2;\n  const yDiff = y1 - y2;\n  return {\n    xDiff,\n    yDiff\n  };\n};\n\n\n;// CONCATENATED MODULE: ./src/Piece.ts\n\n\n\nconst Piece = (color, type) => {\n  function hasMove(from, to) {\n    switch (type) {\n      case 'king':\n        {\n          const oneSquareVert = utils_moves.yByN(1)(from)(to) && utils_moves.xByN(0)(from)(to);\n          const oneSquareLateral = utils_moves.xByN(1)(from)(to) && utils_moves.yByN(0)(from)(to);\n          const oneSquareDiagonally = utils_moves.yByN(1)(from)(to) && utils_moves.xByN(1)(from)(to);\n          return from !== to && (oneSquareDiagonally || oneSquareVert || oneSquareLateral);\n        }\n\n      case 'queen':\n        {\n          return from !== to && (utils_moves.diagonal(from)(to) || utils_moves.vertAndLateral(from)(to));\n        }\n\n      case 'bishop':\n        {\n          return from !== to && utils_moves.diagonal(from)(to);\n        }\n\n      case 'knight':\n        {\n          return from !== to && (utils_moves.xByN(1)(from)(to) && utils_moves.yByN(2)(from)(to) || utils_moves.xByN(2)(from)(to) && utils_moves.yByN(1)(from)(to));\n        }\n\n      case 'rook':\n        {\n          return from !== to && utils_moves.vertAndLateral(to)(from);\n        }\n\n      case 'pawn':\n        {\n          const {\n            x: x1,\n            y: y1\n          } = toXY(from);\n          const {\n            x: x2,\n            y: y2\n          } = toXY(to);\n          const onlyMovesInFront = color === 'white' ? y1 < y2 : y1 > y2;\n          const regularMove = utils_moves.yByN(1)(from)(to) && x1 === x2;\n          const firstMove = color === 'white' ? y1 === 2 : y1 === 7;\n          const jumpTwo = utils_moves.yByN(2)(from)(to) && x1 === x2;\n          return from !== to && onlyMovesInFront && (regularMove || firstMove && jumpTwo);\n        }\n    }\n  }\n\n  function getPawnCaptures(origin) {\n    if (type !== 'pawn') return;\n    const {\n      x,\n      y\n    } = toXY(origin);\n    const newY = color === 'white' ? y + 1 : y - 1;\n    const captureOne = {\n      x: x + 1,\n      y: newY\n    };\n    const captureTwo = {\n      x: x - 1,\n      y: newY\n    };\n    return [fromXY(captureOne), fromXY(captureTwo)];\n  }\n\n  return {\n    hasMove,\n    getPawnCaptures,\n\n    get type() {\n      return type;\n    },\n\n    get color() {\n      return color;\n    }\n\n  };\n};\n\n/* harmony default export */ const src_Piece = (Piece);\n;// CONCATENATED MODULE: ./src/utils/moves.ts\n\n\nconst moves = {\n  vertAndLateral: from => to => {\n    const [x1, y1] = from.split('');\n    const [x2, y2] = to.split('');\n    return x1 === x2 || y1 === y2;\n  },\n  diagonal: from => to => {\n    const {\n      x: x1,\n      y: y1\n    } = toXY(from);\n    const {\n      x: x2,\n      y: y2\n    } = toXY(to);\n    return Math.abs(x2 - x1) === Math.abs(y2 - y1);\n  },\n  xByN: num => from => to => {\n    const {\n      x: x1\n    } = toXY(from);\n    const {\n      x: x2\n    } = toXY(to);\n    return Math.abs(x1 - x2) === num;\n  },\n  yByN: num => from => to => {\n    const {\n      y: y1\n    } = toXY(from);\n    const {\n      y: y2\n    } = toXY(to);\n    return Math.abs(y1 - y2) === num;\n  }\n};\n/* harmony default export */ const utils_moves = (moves);\n/* dealing with move vectors */\n\nfunction splitIntoVectors(arrayOfMoves, start) {\n  return arrayOfMoves.reduce((acc, curr) => {\n    const {\n      xDiff,\n      yDiff\n    } = calcDistance(start)(curr);\n    let vector = '';\n    if (yDiff !== 0) vector = yDiff < 0 ? 'up' : 'down';\n    if (xDiff !== 0) vector += xDiff < 0 ? 'Right' : 'Left'; // normalize vector name\n\n    vector = vector.charAt(0).toLowerCase() + vector.slice(1);\n    acc[vector] = acc[vector] || [];\n    acc[vector].push(curr);\n    return acc;\n  }, {});\n}\n\nfunction getBeginningOfVector(vector) {\n  if (vector.length === 0) return '';\n  return vector.reduce((acc, curr) => {\n    const {\n      x: x1,\n      y: y1\n    } = toXY(acc);\n    const {\n      x: x2,\n      y: y2\n    } = toXY(curr);\n    const accIsBeginning = x1 === x2 ? y1 < y2 : x1 < x2;\n    return accIsBeginning ? acc : curr;\n  });\n}\n\nconst getMovesAlongVector = (s1, s2, allSquares) => {\n  const liesSameVertOrLat = moves.vertAndLateral(s1)(s2);\n  const liesSameDiagonally = moves.diagonal(s1)(s2);\n  const liesOnSameLine = liesSameVertOrLat || liesSameDiagonally;\n  if (!liesOnSameLine) return [];\n  const matchingVector = liesSameDiagonally ? 'diagonal' : 'vertAndLateral';\n  const squaresAlongVector = allSquares.filter(s => moves[matchingVector](s1)(s) && moves[matchingVector](s2)(s));\n  return squaresAlongVector;\n};\n/* sort moves */\n\n\nconst sortMovesClosestTo = square => moves => {\n  return [...moves].sort((a, b) => {\n    const {\n      xDiff: x1Diff,\n      yDiff: y1Diff\n    } = calcDistance(square)(a);\n    const aDiff = Math.abs(x1Diff) + Math.abs(y1Diff);\n    const {\n      xDiff: x2Diff,\n      yDiff: y2Diff\n    } = calcDistance(square)(b);\n    const bDiff = Math.abs(x2Diff) + Math.abs(y2Diff);\n    return aDiff - bDiff;\n  });\n};\n/* get moves */\n\n\nfunction getPossibleMoves(origin, board) {\n  // get all moves that can happen if no other pieces were on the board\n  const allSquares = Array.from(board.keys());\n  const square = board.get(origin);\n  const {\n    type,\n    color\n  } = square.piece;\n  const piece = src_Piece(color, type);\n  return allSquares.filter(s => piece.hasMove(origin, s));\n}\n\nfunction getLegalMoves(origin, board) {\n  // get moves regardless of whether or not there is check\n  const square = board.get(origin);\n  const piece = square.piece;\n  const possibleMoves = getPossibleMoves(origin, board);\n  const obstructions = possibleMoves.filter(s => {\n    var _a;\n\n    return (_a = board.get(s)) === null || _a === void 0 ? void 0 : _a.piece;\n  });\n\n  if (!obstructions.length) {\n    if (piece.type === 'pawn') return [...getPawnCaptures(origin, board), ...possibleMoves];\n    return possibleMoves;\n  }\n\n  let legalMoves = [];\n\n  switch (piece.type) {\n    case 'knight':\n      {\n        legalMoves = possibleMoves;\n        break;\n      }\n\n    case 'pawn':\n      {\n        const capturesAvailable = getPawnCaptures(origin, board);\n        const unobstructedMoves = removeMovesWithPieces(removeObstructedMoves(origin, possibleMoves, obstructions), board);\n        legalMoves = [...capturesAvailable, ...unobstructedMoves];\n        break;\n      }\n\n    case 'king':\n      {\n        legalMoves = removeProtectedSquares(piece, possibleMoves, board);\n        break;\n      }\n\n    default:\n      {\n        legalMoves = removeObstructedMoves(origin, possibleMoves, obstructions);\n      }\n  }\n\n  return removeMovesWithPieces(legalMoves, board, piece.color);\n}\n\nfunction getLegalMovesInCheck(origin, board, kingPos, squareGivingCheck) {\n  const squaresThatDealWithCheck = getSquaresBetweenKingAndCheck(kingPos, squareGivingCheck, Array.from(board.keys()));\n  const moves = getLegalMoves(origin, board);\n  return moves.filter(s => squaresThatDealWithCheck.includes(s));\n}\n\nfunction getAttackingMoves(origin, board) {\n  // for when you need to check for if squares are protected\n  const square = board.get(origin);\n  const {\n    type,\n    color\n  } = square.piece;\n\n  switch (type) {\n    case 'pawn':\n      {\n        const piece = src_Piece(color, 'pawn');\n        return piece.getPawnCaptures(origin);\n      }\n\n    default:\n      return getLegalMoves(origin, board);\n  }\n}\n\nfunction getAllMovesForColor(color, board) {\n  const allMoves = [];\n\n  for (const [square, {\n    piece\n  }] of board.entries()) {\n    if (!piece) continue;\n    if (piece.color !== color) continue;\n    allMoves.push(getLegalMoves(square, board));\n  }\n\n  return allMoves.flat();\n}\n\nfunction getAttackingMovesForColor(color, board) {\n  const allMoves = [];\n\n  for (const [square, {\n    piece\n  }] of board.entries()) {\n    if (!piece) continue;\n    if (piece.color !== color) continue;\n    allMoves.push(getAttackingMoves(square, board));\n  }\n\n  return allMoves.flat();\n}\n\nfunction getPawnCaptures(pawnSquare, board) {\n  var _a;\n\n  const {\n    color\n  } = (_a = board.get(pawnSquare)) === null || _a === void 0 ? void 0 : _a.piece;\n  const pawn = src_Piece(color, 'pawn');\n  const captureMoves = pawn.getPawnCaptures(pawnSquare);\n  if (!captureMoves) return [];\n  return captureMoves.filter(s => {\n    const squareVal = board.get(s);\n    if (!squareVal) return false;\n    const piece = squareVal.piece;\n    const enPassant = squareVal.enPassant;\n    return piece && piece.color !== pawn.color || enPassant && enPassant.color !== pawn.color;\n  });\n}\n\nfunction getSquaresBetweenKingAndCheck(kingPos, checkPos, allSquares) {\n  // includes kingPos and checkPos\n  const squaresAlongVector = getMovesAlongVector(kingPos, checkPos, allSquares);\n  const squaresBetweenKingAndPiece = removeMovesBehindTwoSquares(kingPos, checkPos, squaresAlongVector);\n  return squaresBetweenKingAndPiece;\n}\n/* filter moves */\n\n\nfunction removeMovesBehindTwoSquares(s1, s2, vector) {\n  const sorted = sortMovesClosestTo(getBeginningOfVector(vector))(vector);\n  let furthestSquare;\n  let closestSquare;\n\n  if (sorted.indexOf(s1) > sorted.indexOf(s2)) {\n    furthestSquare = s1;\n    closestSquare = s2;\n  } else {\n    furthestSquare = s2;\n    closestSquare = s1;\n  }\n\n  const removedOneEnd = removeMovesBehindSquare(furthestSquare)(sorted);\n  const removedBothEnds = removeMovesBehindSquare(closestSquare)(removedOneEnd.reverse());\n  return removedBothEnds;\n}\n\nconst removeMovesBehindSquare = square => moves => {\n  const copy = [...moves];\n  const index = moves.indexOf(square);\n  if (index === -1) return [];\n  copy.splice(index + 1);\n  return copy;\n};\n\nfunction removeObstructedMoves(startingSquare, possibleMoves, obstructions) {\n  // a) split possible moves into vectors (up,down,left,right, and/or diagonals)\n  // b) see which obstructions belong to which vector\n  // c) find the closest obstruction\n  // d) remove all the moves behind that obstruction\n  const filteredMoves = [];\n  const allVectors = splitIntoVectors(possibleMoves, startingSquare);\n  const obstructionVectors = splitIntoVectors(obstructions, startingSquare);\n\n  for (const vector in allVectors) {\n    if (!obstructionVectors[vector]) {\n      // look for vector obstruction is on\n      filteredMoves.push(allVectors[vector]);\n      continue;\n    }\n\n    const sorted = sortMovesClosestTo(startingSquare)(allVectors[vector]);\n    const closestObstruction = sortMovesClosestTo(startingSquare)(obstructionVectors[vector])[0];\n    filteredMoves.push(removeMovesBehindSquare(closestObstruction)(sorted));\n  }\n\n  return filteredMoves.flat();\n}\n\nfunction removeProtectedSquares(king, possibleMoves, board) {\n  // bc king cant move if square is protected\n  const oppColor = king.color === 'white' ? 'black' : 'white';\n  const allEnemyMoves = getAttackingMovesForColor(oppColor, board);\n  return possibleMoves.filter(s => {\n    return !allEnemyMoves.includes(s);\n  });\n}\n\nfunction removeMovesWithPieces(moves, board, color) {\n  return moves.filter(s => {\n    const squareVal = board.get(s);\n    if (!squareVal) return false;\n    if (color) return !squareVal.piece || squareVal.piece.color !== color;else return !squareVal.piece;\n  });\n}\n/* gameboard checks */\n\n\nfunction getDiscoveredCheck(kingPos, kingColor, vacated, board) {\n  var _a; // openSquare is a square just vacated\n\n\n  let squaresAlongVector = getMovesAlongVector(kingPos, vacated, Array.from(board.keys()));\n  squaresAlongVector = squaresAlongVector.filter(s => s !== kingPos && s !== vacated);\n  if (!squaresAlongVector.length) return '';\n\n  for (const square of squaresAlongVector) {\n    const piece = (_a = board.get(square)) === null || _a === void 0 ? void 0 : _a.piece;\n    if (!piece || piece.color === kingColor) continue;\n    const legalMoves = getLegalMoves(square, board);\n    if (legalMoves.includes(kingPos)) return square;\n  }\n\n  return '';\n}\n\nfunction canBlockOrCaptureCheck(kingPos, squareGivingCheck, board) {\n  var _a;\n\n  const king = (_a = board.get(kingPos)) === null || _a === void 0 ? void 0 : _a.piece;\n  const blockOrCaptureSquares = getSquaresBetweenKingAndCheck(kingPos, squareGivingCheck, Array.from(board.keys())); // also includes check square\n\n  const ownPieceMoves = getAllMovesForColor(king.color, board);\n  return ownPieceMoves.some(move => blockOrCaptureSquares.includes(move));\n}\n\n\n;// CONCATENATED MODULE: ./src/Gameboard.ts\n\n\n\nconst Gameboard = (board, squaresGivingCheck) => {\n  board = board || createBoard();\n\n  function createBoard() {\n    const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];\n    const ranks = [1, 2, 3, 4, 5, 6, 7, 8];\n    return files.reduce((acc, file) => {\n      ranks.forEach(rank => {\n        const square = file.concat(rank.toString());\n        acc.set(square, {\n          piece: null\n        });\n      });\n      return acc;\n    }, new Map());\n  }\n\n  function canCastle(color, side) {\n    const rank = color === 'white' ? 1 : 8;\n    const castleSquares = side === 'kingside' ? [`f${rank}`, `g${rank}`] : [`c${rank}`, `d${rank}`];\n    const oppColor = color === 'white' ? 'black' : 'white';\n    const oppMoves = getAttackingMovesForColor(oppColor, board);\n    let canCastle = true;\n    castleSquares.forEach(s => {\n      // check if castle square is cleared\n      if (at(s).piece) canCastle = false; // make sure castle square isnt attacked\n\n      if (oppMoves.includes(s)) {\n        canCastle = false;\n      }\n    });\n    return canCastle;\n  }\n\n  function castle(color, side) {\n    const rank = color === 'white' ? 1 : 8;\n    const castleSquares = side === 'kingside' ? [`f${rank}`, `g${rank}`] : [`d${rank}`, `c${rank}`];\n    const kingPos = get.kingPosition(color);\n    const rookPos = getRookPos();\n    from(rookPos).to(castleSquares[0]);\n    from(kingPos).to(castleSquares[1]);\n\n    function getRookPos() {\n      const pieceMap = get.pieceMap();\n      const rookPos = pieceMap[color].rook.find(square => {\n        const file = square.split('')[0];\n        return side === 'kingside' ? ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'].indexOf(file) > 3 : ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'].indexOf(file) < 3;\n      });\n      return rookPos;\n    } // need to get king position\n    // need to get castle squares\n    // need to find rook\n\n  }\n\n  const enPassant = (() => {\n    function getSquare(current, color) {\n      const {\n        x,\n        y\n      } = toXY(current);\n      const newY = color === 'white' ? y - 1 : y + 1;\n      return fromXY({\n        x,\n        y: newY\n      });\n    }\n\n    return {\n      checkToggle: (from, to) => {\n        const {\n          y: y1\n        } = toXY(from);\n        const {\n          y: y2\n        } = toXY(to);\n        return Math.abs(y1 - y2) === 2;\n      },\n      toggle: (current, color) => {\n        const enPassantSquare = getSquare(current, color);\n        at(enPassantSquare).setEnPassant(color, current);\n      },\n      remove: () => {\n        for (const squareObj of board.values()) {\n          if (squareObj.enPassant) return squareObj.enPassant = undefined;\n        }\n      }\n    };\n  })();\n\n  const at = square => ({\n    place: piece => {\n      if (!board.get(square)) return 'square does not exist';\n      board.set(square, {\n        piece\n      });\n    },\n    remove: () => {\n      if (!board.get(square)) return 'square does not exist';\n      board.set(square, {\n        piece: null\n      });\n    },\n    promote: pieceType => {\n      const squareVal = board.get(square);\n      const piece = squareVal === null || squareVal === void 0 ? void 0 : squareVal.piece;\n      if (!piece) return;\n      board.set(square, Object.assign(Object.assign({}, squareVal), {\n        piece: Object.assign(Object.assign({}, piece), {\n          type: pieceType\n        })\n      }));\n    },\n    setEnPassant: (color, current) => {\n      if (!board.get(square)) return 'square does not exist';\n      board.set(square, {\n        piece: null,\n        enPassant: {\n          current,\n          color: color\n        }\n      });\n    },\n\n    get piece() {\n      var _a;\n\n      return (_a = board.get(square)) === null || _a === void 0 ? void 0 : _a.piece;\n    },\n\n    getLegalMoves: () => {\n      squaresGivingCheck = squaresGivingCheck || [];\n      const {\n        type,\n        color\n      } = at(square).piece;\n\n      switch (squaresGivingCheck.length) {\n        case 2:\n          {\n            if (type !== 'king') return [];\n            return getLegalMoves(square, board);\n          }\n\n        case 1:\n          {\n            return getLegalMovesInCheck(origin, board, get.kingPosition(color), squaresGivingCheck[0]);\n          }\n\n        default:\n          {\n            return getLegalMoves(square, board);\n          }\n      }\n    }\n  });\n\n  const from = s1 => ({\n    to: s2 => {\n      const piece = at(s1).piece;\n      if (!piece) return; // move piece\n\n      at(s1).remove();\n      at(s2).place(piece);\n    }\n  });\n\n  const get = {\n    kingPosition: color => {\n      for (const [square, value] of board.entries()) {\n        if (value.piece && value.piece.type === 'king' && value.piece.color === color) return square;\n      }\n    },\n    pieceMap: () => {\n      const pieceMap = {\n        white: {},\n        black: {}\n      };\n\n      for (const [square, value] of board.entries()) {\n        const {\n          piece\n        } = value;\n        if (!piece) continue;\n        const {\n          type,\n          color\n        } = piece;\n        pieceMap[color][type] = pieceMap[color][type] ? [...pieceMap[color][type], square] : [square];\n      }\n\n      return pieceMap;\n    },\n    squaresGivingCheckAfterMove: (from, end) => {\n      var _a;\n\n      const squaresGivingCheck = [];\n      const piece = (_a = board.get(end)) === null || _a === void 0 ? void 0 : _a.piece;\n      const oppColor = piece.color === 'white' ? 'black' : 'white';\n      const kingPosition = get.kingPosition(oppColor);\n      const pieceHitsKing = getLegalMoves(end, board).includes(kingPosition);\n      if (pieceHitsKing) squaresGivingCheck.push(end);\n      const discoveredCheck = getDiscoveredCheck(kingPosition, oppColor, from, board);\n      if (discoveredCheck) squaresGivingCheck.push(discoveredCheck);\n      return squaresGivingCheck;\n    },\n    isCheckmate: (color, squaresGivingCheck) => {\n      const kingPos = get.kingPosition(color);\n      const legalMoves = at(kingPos).getLegalMoves(); // check if check can be blocked\n\n      if (squaresGivingCheck.length === 1) {\n        if (canBlockOrCaptureCheck(kingPos, squaresGivingCheck[0], board)) return false;\n      }\n\n      if (!legalMoves || !legalMoves.length) return true;\n      return false;\n    }\n  };\n  return {\n    createBoard,\n    castle,\n    canCastle,\n    enPassant,\n    at,\n    from,\n    get,\n\n    get board() {\n      return board;\n    }\n\n  };\n};\n\n/* harmony default export */ const src_Gameboard = (Gameboard);\n;// CONCATENATED MODULE: ./src/History.ts\n// should output history object that holds move history in 2d array\n// for each move needs to attach piece Type to beginning of move if not pawn\n// should further specify square of piece if, say both rooks, can move to same square\n\nfunction History(prevHistory, board, pieceMap) {\n  const history = prevHistory || [];\n  const get = {\n    piecePrefix: (from, to) => {\n      var _a;\n\n      const {\n        type,\n        color\n      } = (_a = board.get(to)) === null || _a === void 0 ? void 0 : _a.piece;\n\n      switch (type) {\n        case 'pawn':\n          return '';\n\n        case 'knight':\n        case 'rook':\n          {\n            let prefix = type === 'rook' ? 'R' : 'N';\n\n            if (pieceMap[color][type].length !== 1) {\n              // look for piece of same type that couldve also went to the square\n              pieceMap[color][type].forEach(s => {\n                if (s === to) return;\n                const boardCopy = new Map(board);\n                boardCopy.set(to, {\n                  piece: null\n                });\n\n                if (getLegalMoves(s, boardCopy).includes(to)) {\n                  const [x1, y1] = from.split('');\n                  const [x2] = s.split('');\n                  const sameFile = x1 === x2;\n                  prefix = sameFile ? prefix + y1 : prefix + x1;\n                }\n              });\n            }\n\n            return prefix;\n          }\n\n        default:\n          {\n            const prefix = type.charAt(0).toUpperCase();\n            return prefix;\n          }\n      }\n    },\n    castleNotation: side => {\n      return side === 'kingside' ? 'O-O' : 'O-O-O';\n    }\n  };\n  const affix = {\n    capture: (move, prefix) => {\n      return `${prefix}x${move}`;\n    },\n    promote: (move, pieceType) => {\n      const suffix = pieceType === 'knight' ? 'N' : pieceType.charAt(0).toUpperCase();\n      return `${move}=${suffix}`;\n    },\n    check: notation => {\n      return `${notation}+`;\n    },\n    checkmate: notation => {\n      return `${notation}#`;\n    }\n  };\n  return {\n    get,\n    affix,\n    insertMove: notation => {\n      const lastMovePair = history[history.length - 1];\n\n      if (lastMovePair.length === 1) {\n        lastMovePair.push(notation);\n      } else {\n        const newMovePair = [notation];\n        history.push(newMovePair);\n      }\n    }\n  };\n}\n;// CONCATENATED MODULE: ./src/main.ts\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDMUIsYUFBTyxHQUFHQSxRQUFRLEdBQWxCO0FBQ0QsS0FaVztBQWFaQyxhQUFTLEVBQUdELFFBQUQsSUFBcUI7QUFDOUIsYUFBTyxHQUFHQSxRQUFRLEdBQWxCO0FBQ0Q7QUFmVyxHQUFkO0FBa0JBLFNBQU87QUFDTG5ILE9BREs7QUFFTCtHLFNBRks7QUFHTE0sY0FBVSxFQUFHRixRQUFELElBQXFCO0FBQy9CLFlBQU1HLFlBQVksR0FBR2QsT0FBTyxDQUFDQSxPQUFPLENBQUNuSSxNQUFSLEdBQWlCLENBQWxCLENBQTVCOztBQUNBLFVBQUlpSixZQUFZLENBQUNqSixNQUFiLEtBQXdCLENBQTVCLEVBQStCO0FBQzdCaUosb0JBQVksQ0FBQ25KLElBQWIsQ0FBa0JnSixRQUFsQjtBQUNELE9BRkQsTUFFTztBQUNMLGNBQU1JLFdBQVcsR0FBRyxDQUFDSixRQUFELENBQXBCO0FBQ0FYLGVBQU8sQ0FBQ3JJLElBQVIsQ0FBYW9KLFdBQWI7QUFDRDtBQUNGO0FBWEksR0FBUDtBQWFELEM7O0FDekZEO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcm9DaGVzcy8uL3NyYy91dGlscy9oZWxwZXJzLnRzPzI4ZjMiLCJ3ZWJwYWNrOi8vY3JvQ2hlc3MvLi9zcmMvUGllY2UudHM/MmViOCIsIndlYnBhY2s6Ly9jcm9DaGVzcy8uL3NyYy91dGlscy9tb3Zlcy50cz81MGZiIiwid2VicGFjazovL2Nyb0NoZXNzLy4vc3JjL0dhbWVib2FyZC50cz81N2UzIiwid2VicGFjazovL2Nyb0NoZXNzLy4vc3JjL0hpc3RvcnkudHM/NGMyMSIsIndlYnBhY2s6Ly9jcm9DaGVzcy8uL3NyYy9tYWluLnRzP2NkNDkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29vcmQgfSBmcm9tICcuLi90eXBlcy9pbnRlcmZhY2VzJztcbmltcG9ydCB7IFNxdWFyZSB9IGZyb20gJy4uL3R5cGVzL3R5cGVzJztcblxuZnVuY3Rpb24gdG9YWShzcXVhcmU6IFNxdWFyZSk6IENvb3JkIHtcbiAgY29uc3QgW3gsIHldID0gc3F1YXJlLnNwbGl0KCcnKTtcbiAgcmV0dXJuIHtcbiAgICB4OiBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJywgJ2cnLCAnaCddLmluZGV4T2YoeC50b0xvd2VyQ2FzZSgpKSxcbiAgICB5OiBOdW1iZXIoeSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZnJvbVhZKGNvb3JkOiBDb29yZCk6IFNxdWFyZSB7XG4gIGNvbnN0IHsgeCwgeSB9ID0gY29vcmQ7XG4gIGNvbnN0IGNvbCA9IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJywgJ2YnLCAnZycsICdoJ11beF07XG4gIGlmICghY29sKSByZXR1cm4gJyc7XG4gIHJldHVybiBjb2wuY29uY2F0KHkudG9TdHJpbmcoKSk7XG59XG5cbmNvbnN0IGNhbGNEaXN0YW5jZSA9IChzcXVhcmVPbmU6IHN0cmluZykgPT4gKHNxdWFyZVR3bzogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IHsgeDogeDEsIHk6IHkxIH0gPSB0b1hZKHNxdWFyZU9uZSk7XG4gIGNvbnN0IHsgeDogeDIsIHk6IHkyIH0gPSB0b1hZKHNxdWFyZVR3byk7XG5cbiAgY29uc3QgeERpZmYgPSB4MSAtIHgyO1xuICBjb25zdCB5RGlmZiA9IHkxIC0geTI7XG4gIHJldHVybiB7XG4gICAgeERpZmYsXG4gICAgeURpZmZcbiAgfTtcbn07XG5cbmV4cG9ydCB7IHRvWFksIGZyb21YWSwgY2FsY0Rpc3RhbmNlIH07XG4iLCJpbXBvcnQgbW92ZXMgZnJvbSAnLi91dGlscy9tb3Zlcyc7XG5pbXBvcnQgeyB0b1hZLCBmcm9tWFkgfSBmcm9tICcuL3V0aWxzL2hlbHBlcnMnO1xuXG5pbXBvcnQgeyBDb2xvciwgU3F1YXJlLCBQaWVjZVR5cGUgfSBmcm9tICcuL3R5cGVzL3R5cGVzJztcblxuY29uc3QgUGllY2UgPSAoY29sb3I6IENvbG9yLCB0eXBlOiBQaWVjZVR5cGUpID0+IHtcbiAgZnVuY3Rpb24gaGFzTW92ZShmcm9tOiBTcXVhcmUsIHRvOiBTcXVhcmUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2tpbmcnOiB7XG4gICAgICAgIGNvbnN0IG9uZVNxdWFyZVZlcnQgPVxuICAgICAgICAgIG1vdmVzLnlCeU4oMSkoZnJvbSkodG8pICYmIG1vdmVzLnhCeU4oMCkoZnJvbSkodG8pO1xuICAgICAgICBjb25zdCBvbmVTcXVhcmVMYXRlcmFsID1cbiAgICAgICAgICBtb3Zlcy54QnlOKDEpKGZyb20pKHRvKSAmJiBtb3Zlcy55QnlOKDApKGZyb20pKHRvKTtcbiAgICAgICAgY29uc3Qgb25lU3F1YXJlRGlhZ29uYWxseSA9XG4gICAgICAgICAgbW92ZXMueUJ5TigxKShmcm9tKSh0bykgJiYgbW92ZXMueEJ5TigxKShmcm9tKSh0byk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBmcm9tICE9PSB0byAmJlxuICAgICAgICAgIChvbmVTcXVhcmVEaWFnb25hbGx5IHx8IG9uZVNxdWFyZVZlcnQgfHwgb25lU3F1YXJlTGF0ZXJhbClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ3F1ZWVuJzoge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGZyb20gIT09IHRvICYmXG4gICAgICAgICAgKG1vdmVzLmRpYWdvbmFsKGZyb20pKHRvKSB8fCBtb3Zlcy52ZXJ0QW5kTGF0ZXJhbChmcm9tKSh0bykpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjYXNlICdiaXNob3AnOiB7XG4gICAgICAgIHJldHVybiBmcm9tICE9PSB0byAmJiBtb3Zlcy5kaWFnb25hbChmcm9tKSh0byk7XG4gICAgICB9XG4gICAgICBjYXNlICdrbmlnaHQnOiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgZnJvbSAhPT0gdG8gJiZcbiAgICAgICAgICAoKG1vdmVzLnhCeU4oMSkoZnJvbSkodG8pICYmIG1vdmVzLnlCeU4oMikoZnJvbSkodG8pKSB8fFxuICAgICAgICAgICAgKG1vdmVzLnhCeU4oMikoZnJvbSkodG8pICYmIG1vdmVzLnlCeU4oMSkoZnJvbSkodG8pKSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ3Jvb2snOiB7XG4gICAgICAgIHJldHVybiBmcm9tICE9PSB0byAmJiBtb3Zlcy52ZXJ0QW5kTGF0ZXJhbCh0bykoZnJvbSk7XG4gICAgICB9XG4gICAgICBjYXNlICdwYXduJzoge1xuICAgICAgICBjb25zdCB7IHg6IHgxLCB5OiB5MSB9ID0gdG9YWShmcm9tKTtcbiAgICAgICAgY29uc3QgeyB4OiB4MiwgeTogeTIgfSA9IHRvWFkodG8pO1xuXG4gICAgICAgIGNvbnN0IG9ubHlNb3Zlc0luRnJvbnQgPSBjb2xvciA9PT0gJ3doaXRlJyA/IHkxIDwgeTIgOiB5MSA+IHkyO1xuICAgICAgICBjb25zdCByZWd1bGFyTW92ZSA9IG1vdmVzLnlCeU4oMSkoZnJvbSkodG8pICYmIHgxID09PSB4MjtcblxuICAgICAgICBjb25zdCBmaXJzdE1vdmUgPSBjb2xvciA9PT0gJ3doaXRlJyA/IHkxID09PSAyIDogeTEgPT09IDc7XG4gICAgICAgIGNvbnN0IGp1bXBUd28gPSBtb3Zlcy55QnlOKDIpKGZyb20pKHRvKSAmJiB4MSA9PT0geDI7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBmcm9tICE9PSB0byAmJlxuICAgICAgICAgIG9ubHlNb3Zlc0luRnJvbnQgJiZcbiAgICAgICAgICAocmVndWxhck1vdmUgfHwgKGZpcnN0TW92ZSAmJiBqdW1wVHdvKSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQYXduQ2FwdHVyZXMob3JpZ2luOiBTcXVhcmUpIHtcbiAgICBpZiAodHlwZSAhPT0gJ3Bhd24nKSByZXR1cm47XG5cbiAgICBjb25zdCB7IHgsIHkgfSA9IHRvWFkob3JpZ2luKTtcblxuICAgIGNvbnN0IG5ld1kgPSBjb2xvciA9PT0gJ3doaXRlJyA/IHkgKyAxIDogeSAtIDE7XG5cbiAgICBjb25zdCBjYXB0dXJlT25lID0geyB4OiB4ICsgMSwgeTogbmV3WSB9O1xuICAgIGNvbnN0IGNhcHR1cmVUd28gPSB7IHg6IHggLSAxLCB5OiBuZXdZIH07XG5cbiAgICByZXR1cm4gW2Zyb21YWShjYXB0dXJlT25lKSwgZnJvbVhZKGNhcHR1cmVUd28pXTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaGFzTW92ZSxcbiAgICBnZXRQYXduQ2FwdHVyZXMsXG4gICAgZ2V0IHR5cGUoKSB7XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9LFxuICAgIGdldCBjb2xvcigpIHtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG4gIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBQaWVjZTtcbiIsImltcG9ydCB7IGNhbGNEaXN0YW5jZSwgdG9YWSB9IGZyb20gJy4vaGVscGVycyc7XG5pbXBvcnQge1xuICBQaWVjZUludGVyZmFjZSxcbiAgU3F1YXJlT2JqLFxuICBQaWVjZU9iaixcbiAgRW5QYXNzYW50T2JqXG59IGZyb20gJy4uL3R5cGVzL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgTW92ZXMsIEJvYXJkLCBTcXVhcmUsIENvbG9yIH0gZnJvbSAnLi4vdHlwZXMvdHlwZXMnO1xuaW1wb3J0IFBpZWNlIGZyb20gJy4uL1BpZWNlJztcblxuY29uc3QgbW92ZXMgPSB7XG4gIHZlcnRBbmRMYXRlcmFsOiAoZnJvbTogU3F1YXJlKSA9PiAodG86IFNxdWFyZSkgPT4ge1xuICAgIGNvbnN0IFt4MSwgeTFdID0gZnJvbS5zcGxpdCgnJyk7XG4gICAgY29uc3QgW3gyLCB5Ml0gPSB0by5zcGxpdCgnJyk7XG4gICAgcmV0dXJuIHgxID09PSB4MiB8fCB5MSA9PT0geTI7XG4gIH0sXG4gIGRpYWdvbmFsOiAoZnJvbTogU3F1YXJlKSA9PiAodG86IFNxdWFyZSkgPT4ge1xuICAgIGNvbnN0IHsgeDogeDEsIHk6IHkxIH0gPSB0b1hZKGZyb20pO1xuICAgIGNvbnN0IHsgeDogeDIsIHk6IHkyIH0gPSB0b1hZKHRvKTtcbiAgICByZXR1cm4gTWF0aC5hYnMoeDIgLSB4MSkgPT09IE1hdGguYWJzKHkyIC0geTEpO1xuICB9LFxuICB4QnlOOiAobnVtOiBudW1iZXIpID0+IChmcm9tOiBTcXVhcmUpID0+ICh0bzogU3F1YXJlKSA9PiB7XG4gICAgY29uc3QgeyB4OiB4MSB9ID0gdG9YWShmcm9tKTtcbiAgICBjb25zdCB7IHg6IHgyIH0gPSB0b1hZKHRvKTtcbiAgICByZXR1cm4gTWF0aC5hYnMoeDEgLSB4MikgPT09IG51bTtcbiAgfSxcbiAgeUJ5TjogKG51bTogbnVtYmVyKSA9PiAoZnJvbTogU3F1YXJlKSA9PiAodG86IFNxdWFyZSkgPT4ge1xuICAgIGNvbnN0IHsgeTogeTEgfSA9IHRvWFkoZnJvbSk7XG4gICAgY29uc3QgeyB5OiB5MiB9ID0gdG9YWSh0byk7XG4gICAgcmV0dXJuIE1hdGguYWJzKHkxIC0geTIpID09PSBudW07XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IG1vdmVzO1xuXG4vKiBkZWFsaW5nIHdpdGggbW92ZSB2ZWN0b3JzICovXG5cbmZ1bmN0aW9uIHNwbGl0SW50b1ZlY3RvcnMoYXJyYXlPZk1vdmVzOiBNb3Zlcywgc3RhcnQ6IFNxdWFyZSkge1xuICBpbnRlcmZhY2UgVmVjdG9ycyB7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nW107XG4gIH1cbiAgcmV0dXJuIGFycmF5T2ZNb3Zlcy5yZWR1Y2UoKGFjYzogVmVjdG9ycywgY3VycjogU3F1YXJlKSA9PiB7XG4gICAgY29uc3QgeyB4RGlmZiwgeURpZmYgfSA9IGNhbGNEaXN0YW5jZShzdGFydCkoY3Vycik7XG5cbiAgICBsZXQgdmVjdG9yID0gJyc7XG4gICAgaWYgKHlEaWZmICE9PSAwKSB2ZWN0b3IgPSB5RGlmZiA8IDAgPyAndXAnIDogJ2Rvd24nO1xuICAgIGlmICh4RGlmZiAhPT0gMCkgdmVjdG9yICs9IHhEaWZmIDwgMCA/ICdSaWdodCcgOiAnTGVmdCc7XG5cbiAgICAvLyBub3JtYWxpemUgdmVjdG9yIG5hbWVcbiAgICB2ZWN0b3IgPSB2ZWN0b3IuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyB2ZWN0b3Iuc2xpY2UoMSk7XG5cbiAgICBhY2NbdmVjdG9yXSA9IGFjY1t2ZWN0b3JdIHx8IFtdO1xuICAgIGFjY1t2ZWN0b3JdLnB1c2goY3Vycik7XG5cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59XG5cbmZ1bmN0aW9uIGdldEJlZ2lubmluZ09mVmVjdG9yKHZlY3RvcjogTW92ZXMpIHtcbiAgaWYgKHZlY3Rvci5sZW5ndGggPT09IDApIHJldHVybiAnJztcblxuICByZXR1cm4gdmVjdG9yLnJlZHVjZSgoYWNjLCBjdXJyKSA9PiB7XG4gICAgY29uc3QgeyB4OiB4MSwgeTogeTEgfSA9IHRvWFkoYWNjKTtcbiAgICBjb25zdCB7IHg6IHgyLCB5OiB5MiB9ID0gdG9YWShjdXJyKTtcblxuICAgIGNvbnN0IGFjY0lzQmVnaW5uaW5nID0geDEgPT09IHgyID8geTEgPCB5MiA6IHgxIDwgeDI7XG4gICAgcmV0dXJuIGFjY0lzQmVnaW5uaW5nID8gYWNjIDogY3VycjtcbiAgfSk7XG59XG5cbmNvbnN0IGdldE1vdmVzQWxvbmdWZWN0b3IgPSAoXG4gIHMxOiBTcXVhcmUsXG4gIHMyOiBTcXVhcmUsXG4gIGFsbFNxdWFyZXM6IE1vdmVzXG4pOiBNb3ZlcyA9PiB7XG4gIGNvbnN0IGxpZXNTYW1lVmVydE9yTGF0ID0gbW92ZXMudmVydEFuZExhdGVyYWwoczEpKHMyKTtcbiAgY29uc3QgbGllc1NhbWVEaWFnb25hbGx5ID0gbW92ZXMuZGlhZ29uYWwoczEpKHMyKTtcblxuICBjb25zdCBsaWVzT25TYW1lTGluZSA9IGxpZXNTYW1lVmVydE9yTGF0IHx8IGxpZXNTYW1lRGlhZ29uYWxseTtcbiAgaWYgKCFsaWVzT25TYW1lTGluZSkgcmV0dXJuIFtdO1xuXG4gIGNvbnN0IG1hdGNoaW5nVmVjdG9yID0gbGllc1NhbWVEaWFnb25hbGx5ID8gJ2RpYWdvbmFsJyA6ICd2ZXJ0QW5kTGF0ZXJhbCc7XG5cbiAgY29uc3Qgc3F1YXJlc0Fsb25nVmVjdG9yID0gYWxsU3F1YXJlcy5maWx0ZXIoXG4gICAgKHMpID0+IG1vdmVzW21hdGNoaW5nVmVjdG9yXShzMSkocykgJiYgbW92ZXNbbWF0Y2hpbmdWZWN0b3JdKHMyKShzKVxuICApO1xuICByZXR1cm4gc3F1YXJlc0Fsb25nVmVjdG9yO1xufTtcblxuLyogc29ydCBtb3ZlcyAqL1xuXG5jb25zdCBzb3J0TW92ZXNDbG9zZXN0VG8gPVxuICAoc3F1YXJlOiBTcXVhcmUpID0+XG4gIChtb3ZlczogTW92ZXMpOiBNb3ZlcyA9PiB7XG4gICAgcmV0dXJuIFsuLi5tb3Zlc10uc29ydCgoYSwgYikgPT4ge1xuICAgICAgY29uc3QgeyB4RGlmZjogeDFEaWZmLCB5RGlmZjogeTFEaWZmIH0gPSBjYWxjRGlzdGFuY2Uoc3F1YXJlKShhKTtcbiAgICAgIGNvbnN0IGFEaWZmID0gTWF0aC5hYnMoeDFEaWZmKSArIE1hdGguYWJzKHkxRGlmZik7XG5cbiAgICAgIGNvbnN0IHsgeERpZmY6IHgyRGlmZiwgeURpZmY6IHkyRGlmZiB9ID0gY2FsY0Rpc3RhbmNlKHNxdWFyZSkoYik7XG4gICAgICBjb25zdCBiRGlmZiA9IE1hdGguYWJzKHgyRGlmZikgKyBNYXRoLmFicyh5MkRpZmYpO1xuXG4gICAgICByZXR1cm4gYURpZmYgLSBiRGlmZjtcbiAgICB9KTtcbiAgfTtcblxuLyogZ2V0IG1vdmVzICovXG5cbmZ1bmN0aW9uIGdldFBvc3NpYmxlTW92ZXMob3JpZ2luOiBTcXVhcmUsIGJvYXJkOiBCb2FyZCkge1xuICAvLyBnZXQgYWxsIG1vdmVzIHRoYXQgY2FuIGhhcHBlbiBpZiBubyBvdGhlciBwaWVjZXMgd2VyZSBvbiB0aGUgYm9hcmRcbiAgY29uc3QgYWxsU3F1YXJlcyA9IEFycmF5LmZyb20oYm9hcmQua2V5cygpKTtcblxuICBjb25zdCBzcXVhcmUgPSBib2FyZC5nZXQob3JpZ2luKSBhcyBTcXVhcmVPYmo7XG5cbiAgY29uc3QgeyB0eXBlLCBjb2xvciB9ID0gc3F1YXJlLnBpZWNlIGFzIFBpZWNlT2JqO1xuICBjb25zdCBwaWVjZSA9IFBpZWNlKGNvbG9yLCB0eXBlKTtcblxuICByZXR1cm4gYWxsU3F1YXJlcy5maWx0ZXIoKHMpID0+IHBpZWNlLmhhc01vdmUob3JpZ2luLCBzKSk7XG59XG5cbmZ1bmN0aW9uIGdldExlZ2FsTW92ZXMob3JpZ2luOiBTcXVhcmUsIGJvYXJkOiBCb2FyZCkge1xuICAvLyBnZXQgbW92ZXMgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIG9yIG5vdCB0aGVyZSBpcyBjaGVja1xuXG4gIGNvbnN0IHNxdWFyZSA9IGJvYXJkLmdldChvcmlnaW4pIGFzIFNxdWFyZU9iajtcblxuICBjb25zdCBwaWVjZSA9IHNxdWFyZS5waWVjZSBhcyBQaWVjZU9iajtcblxuICBjb25zdCBwb3NzaWJsZU1vdmVzID0gZ2V0UG9zc2libGVNb3ZlcyhvcmlnaW4sIGJvYXJkKTtcblxuICBjb25zdCBvYnN0cnVjdGlvbnMgPSBwb3NzaWJsZU1vdmVzLmZpbHRlcigocykgPT4gYm9hcmQuZ2V0KHMpPy5waWVjZSk7XG4gIGlmICghb2JzdHJ1Y3Rpb25zLmxlbmd0aCkge1xuICAgIGlmIChwaWVjZS50eXBlID09PSAncGF3bicpXG4gICAgICByZXR1cm4gWy4uLmdldFBhd25DYXB0dXJlcyhvcmlnaW4sIGJvYXJkKSwgLi4ucG9zc2libGVNb3Zlc107XG4gICAgcmV0dXJuIHBvc3NpYmxlTW92ZXM7XG4gIH1cblxuICBsZXQgbGVnYWxNb3ZlczogTW92ZXMgPSBbXTtcbiAgc3dpdGNoIChwaWVjZS50eXBlKSB7XG4gICAgY2FzZSAna25pZ2h0Jzoge1xuICAgICAgbGVnYWxNb3ZlcyA9IHBvc3NpYmxlTW92ZXM7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAncGF3bic6IHtcbiAgICAgIGNvbnN0IGNhcHR1cmVzQXZhaWxhYmxlID0gZ2V0UGF3bkNhcHR1cmVzKG9yaWdpbiwgYm9hcmQpO1xuICAgICAgY29uc3QgdW5vYnN0cnVjdGVkTW92ZXMgPSByZW1vdmVNb3Zlc1dpdGhQaWVjZXMoXG4gICAgICAgIHJlbW92ZU9ic3RydWN0ZWRNb3ZlcyhvcmlnaW4sIHBvc3NpYmxlTW92ZXMsIG9ic3RydWN0aW9ucyksXG4gICAgICAgIGJvYXJkXG4gICAgICApO1xuICAgICAgbGVnYWxNb3ZlcyA9IFsuLi5jYXB0dXJlc0F2YWlsYWJsZSwgLi4udW5vYnN0cnVjdGVkTW92ZXNdO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgJ2tpbmcnOiB7XG4gICAgICBsZWdhbE1vdmVzID0gcmVtb3ZlUHJvdGVjdGVkU3F1YXJlcyhwaWVjZSwgcG9zc2libGVNb3ZlcywgYm9hcmQpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGxlZ2FsTW92ZXMgPSByZW1vdmVPYnN0cnVjdGVkTW92ZXMob3JpZ2luLCBwb3NzaWJsZU1vdmVzLCBvYnN0cnVjdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZW1vdmVNb3Zlc1dpdGhQaWVjZXMobGVnYWxNb3ZlcywgYm9hcmQsIHBpZWNlLmNvbG9yKTtcbn1cblxuZnVuY3Rpb24gZ2V0TGVnYWxNb3Zlc0luQ2hlY2soXG4gIG9yaWdpbjogU3F1YXJlLFxuICBib2FyZDogQm9hcmQsXG4gIGtpbmdQb3M6IFNxdWFyZSxcbiAgc3F1YXJlR2l2aW5nQ2hlY2s6IFNxdWFyZVxuKSB7XG4gIGNvbnN0IHNxdWFyZXNUaGF0RGVhbFdpdGhDaGVjayA9IGdldFNxdWFyZXNCZXR3ZWVuS2luZ0FuZENoZWNrKFxuICAgIGtpbmdQb3MsXG4gICAgc3F1YXJlR2l2aW5nQ2hlY2ssXG4gICAgQXJyYXkuZnJvbShib2FyZC5rZXlzKCkpXG4gICk7XG5cbiAgY29uc3QgbW92ZXMgPSBnZXRMZWdhbE1vdmVzKG9yaWdpbiwgYm9hcmQpO1xuXG4gIHJldHVybiBtb3Zlcy5maWx0ZXIoKHMpID0+IHNxdWFyZXNUaGF0RGVhbFdpdGhDaGVjay5pbmNsdWRlcyhzKSk7XG59XG5cbmZ1bmN0aW9uIGdldEF0dGFja2luZ01vdmVzKG9yaWdpbjogU3F1YXJlLCBib2FyZDogQm9hcmQpIHtcbiAgLy8gZm9yIHdoZW4geW91IG5lZWQgdG8gY2hlY2sgZm9yIGlmIHNxdWFyZXMgYXJlIHByb3RlY3RlZFxuICBjb25zdCBzcXVhcmUgPSBib2FyZC5nZXQob3JpZ2luKSBhcyBTcXVhcmVPYmo7XG5cbiAgY29uc3QgeyB0eXBlLCBjb2xvciB9ID0gc3F1YXJlLnBpZWNlIGFzIFBpZWNlT2JqO1xuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3Bhd24nOiB7XG4gICAgICBjb25zdCBwaWVjZSA9IFBpZWNlKGNvbG9yLCAncGF3bicpO1xuICAgICAgcmV0dXJuIHBpZWNlLmdldFBhd25DYXB0dXJlcyhvcmlnaW4pIGFzIE1vdmVzO1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGdldExlZ2FsTW92ZXMob3JpZ2luLCBib2FyZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QWxsTW92ZXNGb3JDb2xvcihjb2xvcjogQ29sb3IsIGJvYXJkOiBCb2FyZCk6IE1vdmVzIHtcbiAgY29uc3QgYWxsTW92ZXM6IE1vdmVzW10gPSBbXTtcbiAgZm9yIChjb25zdCBbc3F1YXJlLCB7IHBpZWNlIH1dIG9mIGJvYXJkLmVudHJpZXMoKSkge1xuICAgIGlmICghcGllY2UpIGNvbnRpbnVlO1xuICAgIGlmIChwaWVjZS5jb2xvciAhPT0gY29sb3IpIGNvbnRpbnVlO1xuXG4gICAgYWxsTW92ZXMucHVzaChnZXRMZWdhbE1vdmVzKHNxdWFyZSwgYm9hcmQpKTtcbiAgfVxuXG4gIHJldHVybiBhbGxNb3Zlcy5mbGF0KCk7XG59XG5cbmZ1bmN0aW9uIGdldEF0dGFja2luZ01vdmVzRm9yQ29sb3IoY29sb3I6IENvbG9yLCBib2FyZDogQm9hcmQpOiBNb3ZlcyB7XG4gIGNvbnN0IGFsbE1vdmVzOiBNb3Zlc1tdID0gW107XG4gIGZvciAoY29uc3QgW3NxdWFyZSwgeyBwaWVjZSB9XSBvZiBib2FyZC5lbnRyaWVzKCkpIHtcbiAgICBpZiAoIXBpZWNlKSBjb250aW51ZTtcbiAgICBpZiAocGllY2UuY29sb3IgIT09IGNvbG9yKSBjb250aW51ZTtcblxuICAgIGFsbE1vdmVzLnB1c2goZ2V0QXR0YWNraW5nTW92ZXMoc3F1YXJlLCBib2FyZCkpO1xuICB9XG5cbiAgcmV0dXJuIGFsbE1vdmVzLmZsYXQoKTtcbn1cblxuZnVuY3Rpb24gZ2V0UGF3bkNhcHR1cmVzKHBhd25TcXVhcmU6IFNxdWFyZSwgYm9hcmQ6IEJvYXJkKSB7XG4gIGNvbnN0IHsgY29sb3IgfSA9IGJvYXJkLmdldChwYXduU3F1YXJlKT8ucGllY2UgYXMgUGllY2VPYmo7XG4gIGNvbnN0IHBhd24gPSBQaWVjZShjb2xvciwgJ3Bhd24nKTtcblxuICBjb25zdCBjYXB0dXJlTW92ZXMgPSBwYXduLmdldFBhd25DYXB0dXJlcyhwYXduU3F1YXJlKTtcbiAgaWYgKCFjYXB0dXJlTW92ZXMpIHJldHVybiBbXTtcblxuICByZXR1cm4gY2FwdHVyZU1vdmVzLmZpbHRlcigocykgPT4ge1xuICAgIGNvbnN0IHNxdWFyZVZhbCA9IGJvYXJkLmdldChzKTtcbiAgICBpZiAoIXNxdWFyZVZhbCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgY29uc3QgcGllY2UgPSBzcXVhcmVWYWwucGllY2U7XG4gICAgY29uc3QgZW5QYXNzYW50OiBFblBhc3NhbnRPYmogfCB1bmRlZmluZWQgPSBzcXVhcmVWYWwuZW5QYXNzYW50O1xuXG4gICAgcmV0dXJuIChcbiAgICAgIChwaWVjZSAmJiBwaWVjZS5jb2xvciAhPT0gcGF3bi5jb2xvcikgfHxcbiAgICAgIChlblBhc3NhbnQgJiYgZW5QYXNzYW50LmNvbG9yICE9PSBwYXduLmNvbG9yKVxuICAgICk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRTcXVhcmVzQmV0d2VlbktpbmdBbmRDaGVjayhcbiAga2luZ1BvczogU3F1YXJlLFxuICBjaGVja1BvczogU3F1YXJlLFxuICBhbGxTcXVhcmVzOiBNb3Zlc1xuKSB7XG4gIC8vIGluY2x1ZGVzIGtpbmdQb3MgYW5kIGNoZWNrUG9zXG4gIGNvbnN0IHNxdWFyZXNBbG9uZ1ZlY3RvciA9IGdldE1vdmVzQWxvbmdWZWN0b3Ioa2luZ1BvcywgY2hlY2tQb3MsIGFsbFNxdWFyZXMpO1xuICBjb25zdCBzcXVhcmVzQmV0d2VlbktpbmdBbmRQaWVjZSA9IHJlbW92ZU1vdmVzQmVoaW5kVHdvU3F1YXJlcyhcbiAgICBraW5nUG9zLFxuICAgIGNoZWNrUG9zLFxuICAgIHNxdWFyZXNBbG9uZ1ZlY3RvclxuICApO1xuICByZXR1cm4gc3F1YXJlc0JldHdlZW5LaW5nQW5kUGllY2U7XG59XG5cbi8qIGZpbHRlciBtb3ZlcyAqL1xuXG5mdW5jdGlvbiByZW1vdmVNb3Zlc0JlaGluZFR3b1NxdWFyZXMoXG4gIHMxOiBTcXVhcmUsXG4gIHMyOiBTcXVhcmUsXG4gIHZlY3RvcjogTW92ZXNcbik6IE1vdmVzIHtcbiAgY29uc3Qgc29ydGVkID0gc29ydE1vdmVzQ2xvc2VzdFRvKGdldEJlZ2lubmluZ09mVmVjdG9yKHZlY3RvcikpKHZlY3Rvcik7XG4gIGxldCBmdXJ0aGVzdFNxdWFyZTtcbiAgbGV0IGNsb3Nlc3RTcXVhcmU7XG5cbiAgaWYgKHNvcnRlZC5pbmRleE9mKHMxKSA+IHNvcnRlZC5pbmRleE9mKHMyKSkge1xuICAgIGZ1cnRoZXN0U3F1YXJlID0gczE7XG4gICAgY2xvc2VzdFNxdWFyZSA9IHMyO1xuICB9IGVsc2Uge1xuICAgIGZ1cnRoZXN0U3F1YXJlID0gczI7XG4gICAgY2xvc2VzdFNxdWFyZSA9IHMxO1xuICB9XG4gIGNvbnN0IHJlbW92ZWRPbmVFbmQgPSByZW1vdmVNb3Zlc0JlaGluZFNxdWFyZShmdXJ0aGVzdFNxdWFyZSkoc29ydGVkKTtcbiAgY29uc3QgcmVtb3ZlZEJvdGhFbmRzID0gcmVtb3ZlTW92ZXNCZWhpbmRTcXVhcmUoY2xvc2VzdFNxdWFyZSkoXG4gICAgcmVtb3ZlZE9uZUVuZC5yZXZlcnNlKClcbiAgKTtcblxuICByZXR1cm4gcmVtb3ZlZEJvdGhFbmRzO1xufVxuXG5jb25zdCByZW1vdmVNb3Zlc0JlaGluZFNxdWFyZSA9XG4gIChzcXVhcmU6IFNxdWFyZSkgPT5cbiAgKG1vdmVzOiBNb3Zlcyk6IE1vdmVzID0+IHtcbiAgICBjb25zdCBjb3B5ID0gWy4uLm1vdmVzXTtcbiAgICBjb25zdCBpbmRleCA9IG1vdmVzLmluZGV4T2Yoc3F1YXJlKTtcblxuICAgIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiBbXTtcblxuICAgIGNvcHkuc3BsaWNlKGluZGV4ICsgMSk7XG5cbiAgICByZXR1cm4gY29weTtcbiAgfTtcblxuZnVuY3Rpb24gcmVtb3ZlT2JzdHJ1Y3RlZE1vdmVzKFxuICBzdGFydGluZ1NxdWFyZTogU3F1YXJlLFxuICBwb3NzaWJsZU1vdmVzOiBNb3ZlcyxcbiAgb2JzdHJ1Y3Rpb25zOiBNb3Zlc1xuKTogTW92ZXMge1xuICAvLyBhKSBzcGxpdCBwb3NzaWJsZSBtb3ZlcyBpbnRvIHZlY3RvcnMgKHVwLGRvd24sbGVmdCxyaWdodCwgYW5kL29yIGRpYWdvbmFscylcbiAgLy8gYikgc2VlIHdoaWNoIG9ic3RydWN0aW9ucyBiZWxvbmcgdG8gd2hpY2ggdmVjdG9yXG4gIC8vIGMpIGZpbmQgdGhlIGNsb3Nlc3Qgb2JzdHJ1Y3Rpb25cbiAgLy8gZCkgcmVtb3ZlIGFsbCB0aGUgbW92ZXMgYmVoaW5kIHRoYXQgb2JzdHJ1Y3Rpb25cblxuICBjb25zdCBmaWx0ZXJlZE1vdmVzOiBNb3Zlc1tdID0gW107XG5cbiAgY29uc3QgYWxsVmVjdG9ycyA9IHNwbGl0SW50b1ZlY3RvcnMocG9zc2libGVNb3Zlcywgc3RhcnRpbmdTcXVhcmUpO1xuICBjb25zdCBvYnN0cnVjdGlvblZlY3RvcnMgPSBzcGxpdEludG9WZWN0b3JzKG9ic3RydWN0aW9ucywgc3RhcnRpbmdTcXVhcmUpO1xuICBmb3IgKGNvbnN0IHZlY3RvciBpbiBhbGxWZWN0b3JzKSB7XG4gICAgaWYgKCFvYnN0cnVjdGlvblZlY3RvcnNbdmVjdG9yXSkge1xuICAgICAgLy8gbG9vayBmb3IgdmVjdG9yIG9ic3RydWN0aW9uIGlzIG9uXG4gICAgICBmaWx0ZXJlZE1vdmVzLnB1c2goYWxsVmVjdG9yc1t2ZWN0b3JdKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHNvcnRlZCA9IHNvcnRNb3Zlc0Nsb3Nlc3RUbyhzdGFydGluZ1NxdWFyZSkoYWxsVmVjdG9yc1t2ZWN0b3JdKTtcbiAgICBjb25zdCBjbG9zZXN0T2JzdHJ1Y3Rpb24gPSBzb3J0TW92ZXNDbG9zZXN0VG8oc3RhcnRpbmdTcXVhcmUpKFxuICAgICAgb2JzdHJ1Y3Rpb25WZWN0b3JzW3ZlY3Rvcl1cbiAgICApWzBdO1xuXG4gICAgZmlsdGVyZWRNb3Zlcy5wdXNoKHJlbW92ZU1vdmVzQmVoaW5kU3F1YXJlKGNsb3Nlc3RPYnN0cnVjdGlvbikoc29ydGVkKSk7XG4gIH1cblxuICByZXR1cm4gZmlsdGVyZWRNb3Zlcy5mbGF0KCk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVByb3RlY3RlZFNxdWFyZXMoXG4gIGtpbmc6IFBpZWNlT2JqLFxuICBwb3NzaWJsZU1vdmVzOiBNb3ZlcyxcbiAgYm9hcmQ6IEJvYXJkXG4pOiBNb3ZlcyB7XG4gIC8vIGJjIGtpbmcgY2FudCBtb3ZlIGlmIHNxdWFyZSBpcyBwcm90ZWN0ZWRcbiAgY29uc3Qgb3BwQ29sb3IgPSBraW5nLmNvbG9yID09PSAnd2hpdGUnID8gJ2JsYWNrJyA6ICd3aGl0ZSc7XG5cbiAgY29uc3QgYWxsRW5lbXlNb3ZlcyA9IGdldEF0dGFja2luZ01vdmVzRm9yQ29sb3Iob3BwQ29sb3IsIGJvYXJkKTtcbiAgcmV0dXJuIHBvc3NpYmxlTW92ZXMuZmlsdGVyKChzKSA9PiB7XG4gICAgcmV0dXJuICFhbGxFbmVteU1vdmVzLmluY2x1ZGVzKHMpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlTW92ZXNXaXRoUGllY2VzKFxuICBtb3ZlczogTW92ZXMsXG4gIGJvYXJkOiBCb2FyZCxcbiAgY29sb3I/OiBDb2xvclxuKTogTW92ZXMge1xuICByZXR1cm4gbW92ZXMuZmlsdGVyKChzKSA9PiB7XG4gICAgY29uc3Qgc3F1YXJlVmFsID0gYm9hcmQuZ2V0KHMpO1xuICAgIGlmICghc3F1YXJlVmFsKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoY29sb3IpIHJldHVybiAhc3F1YXJlVmFsLnBpZWNlIHx8IHNxdWFyZVZhbC5waWVjZS5jb2xvciAhPT0gY29sb3I7XG4gICAgZWxzZSByZXR1cm4gIXNxdWFyZVZhbC5waWVjZTtcbiAgfSk7XG59XG5cbi8qIGdhbWVib2FyZCBjaGVja3MgKi9cblxuZnVuY3Rpb24gZ2V0RGlzY292ZXJlZENoZWNrKFxuICBraW5nUG9zOiBTcXVhcmUsXG4gIGtpbmdDb2xvcjogQ29sb3IsXG4gIHZhY2F0ZWQ6IFNxdWFyZSxcbiAgYm9hcmQ6IEJvYXJkXG4pOiBTcXVhcmUge1xuICAvLyBvcGVuU3F1YXJlIGlzIGEgc3F1YXJlIGp1c3QgdmFjYXRlZFxuICBsZXQgc3F1YXJlc0Fsb25nVmVjdG9yID0gZ2V0TW92ZXNBbG9uZ1ZlY3RvcihcbiAgICBraW5nUG9zLFxuICAgIHZhY2F0ZWQsXG4gICAgQXJyYXkuZnJvbShib2FyZC5rZXlzKCkpXG4gICk7XG4gIHNxdWFyZXNBbG9uZ1ZlY3RvciA9IHNxdWFyZXNBbG9uZ1ZlY3Rvci5maWx0ZXIoXG4gICAgKHMpID0+IHMgIT09IGtpbmdQb3MgJiYgcyAhPT0gdmFjYXRlZFxuICApO1xuICBpZiAoIXNxdWFyZXNBbG9uZ1ZlY3Rvci5sZW5ndGgpIHJldHVybiAnJztcblxuICBmb3IgKGNvbnN0IHNxdWFyZSBvZiBzcXVhcmVzQWxvbmdWZWN0b3IpIHtcbiAgICBjb25zdCBwaWVjZSA9IGJvYXJkLmdldChzcXVhcmUpPy5waWVjZTtcbiAgICBpZiAoIXBpZWNlIHx8IHBpZWNlLmNvbG9yID09PSBraW5nQ29sb3IpIGNvbnRpbnVlO1xuXG4gICAgY29uc3QgbGVnYWxNb3ZlcyA9IGdldExlZ2FsTW92ZXMoc3F1YXJlLCBib2FyZCk7XG4gICAgaWYgKGxlZ2FsTW92ZXMuaW5jbHVkZXMoa2luZ1BvcykpIHJldHVybiBzcXVhcmU7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGNhbkJsb2NrT3JDYXB0dXJlQ2hlY2soXG4gIGtpbmdQb3M6IFNxdWFyZSxcbiAgc3F1YXJlR2l2aW5nQ2hlY2s6IFNxdWFyZSxcbiAgYm9hcmQ6IEJvYXJkXG4pOiBib29sZWFuIHtcbiAgY29uc3Qga2luZyA9IGJvYXJkLmdldChraW5nUG9zKT8ucGllY2UgYXMgUGllY2VPYmo7XG5cbiAgY29uc3QgYmxvY2tPckNhcHR1cmVTcXVhcmVzID0gZ2V0U3F1YXJlc0JldHdlZW5LaW5nQW5kQ2hlY2soXG4gICAga2luZ1BvcyxcbiAgICBzcXVhcmVHaXZpbmdDaGVjayxcbiAgICBBcnJheS5mcm9tKGJvYXJkLmtleXMoKSlcbiAgKTsgLy8gYWxzbyBpbmNsdWRlcyBjaGVjayBzcXVhcmVcblxuICBjb25zdCBvd25QaWVjZU1vdmVzID0gZ2V0QWxsTW92ZXNGb3JDb2xvcihraW5nLmNvbG9yLCBib2FyZCk7XG4gIHJldHVybiBvd25QaWVjZU1vdmVzLnNvbWUoKG1vdmUpID0+IGJsb2NrT3JDYXB0dXJlU3F1YXJlcy5pbmNsdWRlcyhtb3ZlKSk7XG59XG5cbmV4cG9ydCB7XG4gIGdldEF0dGFja2luZ01vdmVzRm9yQ29sb3IsXG4gIGdldExlZ2FsTW92ZXMsXG4gIGdldExlZ2FsTW92ZXNJbkNoZWNrLFxuICBnZXREaXNjb3ZlcmVkQ2hlY2ssXG4gIGNhbkJsb2NrT3JDYXB0dXJlQ2hlY2tcbn07XG4iLCJpbXBvcnQge1xuICBnZXRMZWdhbE1vdmVzLFxuICBnZXREaXNjb3ZlcmVkQ2hlY2ssXG4gIGNhbkJsb2NrT3JDYXB0dXJlQ2hlY2ssXG4gIGdldEF0dGFja2luZ01vdmVzRm9yQ29sb3IsXG4gIGdldExlZ2FsTW92ZXNJbkNoZWNrXG59IGZyb20gJy4vdXRpbHMvbW92ZXMnO1xuaW1wb3J0IHsgdG9YWSwgZnJvbVhZIH0gZnJvbSAnLi91dGlscy9oZWxwZXJzJztcblxuaW1wb3J0IHsgQ29sb3IsIFNxdWFyZSwgQm9hcmQsIFBpZWNlVHlwZSwgTW92ZXMgfSBmcm9tICcuL3R5cGVzL3R5cGVzJztcbmltcG9ydCB7IFBpZWNlTWFwLCBQaWVjZU9iaiB9IGZyb20gJy4vdHlwZXMvaW50ZXJmYWNlcyc7XG5cbmNvbnN0IEdhbWVib2FyZCA9IChib2FyZDogQm9hcmQsIHNxdWFyZXNHaXZpbmdDaGVjazogTW92ZXMpID0+IHtcbiAgYm9hcmQgPSBib2FyZCB8fCBjcmVhdGVCb2FyZCgpO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUJvYXJkKCkge1xuICAgIGNvbnN0IGZpbGVzID0gWydhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJywgJ2gnXTtcbiAgICBjb25zdCByYW5rcyA9IFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4XTtcblxuICAgIHJldHVybiBmaWxlcy5yZWR1Y2UoKGFjYywgZmlsZSkgPT4ge1xuICAgICAgcmFua3MuZm9yRWFjaCgocmFuaykgPT4ge1xuICAgICAgICBjb25zdCBzcXVhcmUgPSBmaWxlLmNvbmNhdChyYW5rLnRvU3RyaW5nKCkpO1xuICAgICAgICBhY2Muc2V0KHNxdWFyZSwgeyBwaWVjZTogbnVsbCB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBuZXcgTWFwKCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuQ2FzdGxlKGNvbG9yOiBDb2xvciwgc2lkZTogJ2tpbmdzaWRlJyB8ICdxdWVlbnNpZGUnKSB7XG4gICAgY29uc3QgcmFuayA9IGNvbG9yID09PSAnd2hpdGUnID8gMSA6IDg7XG4gICAgY29uc3QgY2FzdGxlU3F1YXJlcyA9XG4gICAgICBzaWRlID09PSAna2luZ3NpZGUnID8gW2BmJHtyYW5rfWAsIGBnJHtyYW5rfWBdIDogW2BjJHtyYW5rfWAsIGBkJHtyYW5rfWBdO1xuXG4gICAgY29uc3Qgb3BwQ29sb3IgPSBjb2xvciA9PT0gJ3doaXRlJyA/ICdibGFjaycgOiAnd2hpdGUnO1xuICAgIGNvbnN0IG9wcE1vdmVzID0gZ2V0QXR0YWNraW5nTW92ZXNGb3JDb2xvcihvcHBDb2xvciwgYm9hcmQpO1xuXG4gICAgbGV0IGNhbkNhc3RsZSA9IHRydWU7XG5cbiAgICBjYXN0bGVTcXVhcmVzLmZvckVhY2goKHMpID0+IHtcbiAgICAgIC8vIGNoZWNrIGlmIGNhc3RsZSBzcXVhcmUgaXMgY2xlYXJlZFxuICAgICAgaWYgKGF0KHMpLnBpZWNlKSBjYW5DYXN0bGUgPSBmYWxzZTtcblxuICAgICAgLy8gbWFrZSBzdXJlIGNhc3RsZSBzcXVhcmUgaXNudCBhdHRhY2tlZFxuICAgICAgaWYgKG9wcE1vdmVzLmluY2x1ZGVzKHMpKSB7XG4gICAgICAgIGNhbkNhc3RsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNhbkNhc3RsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhc3RsZShjb2xvcjogQ29sb3IsIHNpZGU6ICdraW5nc2lkZScgfCAncXVlZW5zaWRlJykge1xuICAgIGNvbnN0IHJhbmsgPSBjb2xvciA9PT0gJ3doaXRlJyA/IDEgOiA4O1xuICAgIGNvbnN0IGNhc3RsZVNxdWFyZXMgPVxuICAgICAgc2lkZSA9PT0gJ2tpbmdzaWRlJyA/IFtgZiR7cmFua31gLCBgZyR7cmFua31gXSA6IFtgZCR7cmFua31gLCBgYyR7cmFua31gXTtcblxuICAgIGNvbnN0IGtpbmdQb3MgPSBnZXQua2luZ1Bvc2l0aW9uKGNvbG9yKSBhcyBTcXVhcmU7XG4gICAgY29uc3Qgcm9va1BvcyA9IGdldFJvb2tQb3MoKSBhcyBTcXVhcmU7XG5cbiAgICBmcm9tKHJvb2tQb3MpLnRvKGNhc3RsZVNxdWFyZXNbMF0pO1xuICAgIGZyb20oa2luZ1BvcykudG8oY2FzdGxlU3F1YXJlc1sxXSk7XG5cbiAgICBmdW5jdGlvbiBnZXRSb29rUG9zKCkge1xuICAgICAgY29uc3QgcGllY2VNYXAgPSBnZXQucGllY2VNYXAoKTtcbiAgICAgIGNvbnN0IHJvb2tQb3MgPSBwaWVjZU1hcFtjb2xvcl0ucm9vay5maW5kKChzcXVhcmUpID0+IHtcbiAgICAgICAgY29uc3QgZmlsZSA9IHNxdWFyZS5zcGxpdCgnJylbMF07XG4gICAgICAgIHJldHVybiBzaWRlID09PSAna2luZ3NpZGUnXG4gICAgICAgICAgPyBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJywgJ2cnLCAnaCddLmluZGV4T2YoZmlsZSkgPiAzXG4gICAgICAgICAgOiBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJywgJ2cnLCAnaCddLmluZGV4T2YoZmlsZSkgPCAzO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiByb29rUG9zO1xuICAgIH1cbiAgICAvLyBuZWVkIHRvIGdldCBraW5nIHBvc2l0aW9uXG4gICAgLy8gbmVlZCB0byBnZXQgY2FzdGxlIHNxdWFyZXNcbiAgICAvLyBuZWVkIHRvIGZpbmQgcm9va1xuICB9XG5cbiAgY29uc3QgZW5QYXNzYW50ID0gKCgpID0+IHtcbiAgICBmdW5jdGlvbiBnZXRTcXVhcmUoY3VycmVudDogU3F1YXJlLCBjb2xvcjogQ29sb3IpOiBTcXVhcmUge1xuICAgICAgY29uc3QgeyB4LCB5IH0gPSB0b1hZKGN1cnJlbnQpO1xuICAgICAgY29uc3QgbmV3WSA9IGNvbG9yID09PSAnd2hpdGUnID8geSAtIDEgOiB5ICsgMTtcbiAgICAgIHJldHVybiBmcm9tWFkoeyB4LCB5OiBuZXdZIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjaGVja1RvZ2dsZTogKGZyb206IFNxdWFyZSwgdG86IFNxdWFyZSk6IGJvb2xlYW4gPT4ge1xuICAgICAgICBjb25zdCB7IHk6IHkxIH0gPSB0b1hZKGZyb20pO1xuICAgICAgICBjb25zdCB7IHk6IHkyIH0gPSB0b1hZKHRvKTtcblxuICAgICAgICByZXR1cm4gTWF0aC5hYnMoeTEgLSB5MikgPT09IDI7XG4gICAgICB9LFxuICAgICAgdG9nZ2xlOiAoY3VycmVudDogU3F1YXJlLCBjb2xvcjogQ29sb3IpOiB2b2lkID0+IHtcbiAgICAgICAgY29uc3QgZW5QYXNzYW50U3F1YXJlID0gZ2V0U3F1YXJlKGN1cnJlbnQsIGNvbG9yKTtcbiAgICAgICAgYXQoZW5QYXNzYW50U3F1YXJlKS5zZXRFblBhc3NhbnQoY29sb3IsIGN1cnJlbnQpO1xuICAgICAgfSxcbiAgICAgIHJlbW92ZTogKCk6IHZvaWQgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IHNxdWFyZU9iaiBvZiBib2FyZC52YWx1ZXMoKSkge1xuICAgICAgICAgIGlmIChzcXVhcmVPYmouZW5QYXNzYW50KSByZXR1cm4gKHNxdWFyZU9iai5lblBhc3NhbnQgPSB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSkoKTtcblxuICBjb25zdCBhdCA9IChzcXVhcmU6IFNxdWFyZSkgPT4gKHtcbiAgICBwbGFjZTogKHBpZWNlOiBQaWVjZU9iaikgPT4ge1xuICAgICAgaWYgKCFib2FyZC5nZXQoc3F1YXJlKSkgcmV0dXJuICdzcXVhcmUgZG9lcyBub3QgZXhpc3QnO1xuXG4gICAgICBib2FyZC5zZXQoc3F1YXJlLCB7IHBpZWNlIH0pO1xuICAgIH0sXG4gICAgcmVtb3ZlOiAoKSA9PiB7XG4gICAgICBpZiAoIWJvYXJkLmdldChzcXVhcmUpKSByZXR1cm4gJ3NxdWFyZSBkb2VzIG5vdCBleGlzdCc7XG5cbiAgICAgIGJvYXJkLnNldChzcXVhcmUsIHsgcGllY2U6IG51bGwgfSk7XG4gICAgfSxcbiAgICBwcm9tb3RlOiAocGllY2VUeXBlOiBQaWVjZVR5cGUpID0+IHtcbiAgICAgIGNvbnN0IHNxdWFyZVZhbCA9IGJvYXJkLmdldChzcXVhcmUpO1xuICAgICAgY29uc3QgcGllY2UgPSBzcXVhcmVWYWw/LnBpZWNlO1xuICAgICAgaWYgKCFwaWVjZSkgcmV0dXJuO1xuXG4gICAgICBib2FyZC5zZXQoc3F1YXJlLCB7IC4uLnNxdWFyZVZhbCwgcGllY2U6IHsgLi4ucGllY2UsIHR5cGU6IHBpZWNlVHlwZSB9IH0pO1xuICAgIH0sXG4gICAgc2V0RW5QYXNzYW50OiAoY29sb3I6IENvbG9yLCBjdXJyZW50OiBTcXVhcmUpID0+IHtcbiAgICAgIGlmICghYm9hcmQuZ2V0KHNxdWFyZSkpIHJldHVybiAnc3F1YXJlIGRvZXMgbm90IGV4aXN0JztcblxuICAgICAgYm9hcmQuc2V0KHNxdWFyZSwge1xuICAgICAgICBwaWVjZTogbnVsbCxcbiAgICAgICAgZW5QYXNzYW50OiB7XG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICBjb2xvcjogY29sb3JcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXQgcGllY2UoKSB7XG4gICAgICByZXR1cm4gYm9hcmQuZ2V0KHNxdWFyZSk/LnBpZWNlO1xuICAgIH0sXG4gICAgZ2V0TGVnYWxNb3ZlczogKCk6IE1vdmVzID0+IHtcbiAgICAgIHNxdWFyZXNHaXZpbmdDaGVjayA9IHNxdWFyZXNHaXZpbmdDaGVjayB8fCBbXTtcbiAgICAgIGNvbnN0IHsgdHlwZSwgY29sb3IgfSA9IGF0KHNxdWFyZSkucGllY2UgYXMgUGllY2VPYmo7XG5cbiAgICAgIHN3aXRjaCAoc3F1YXJlc0dpdmluZ0NoZWNrLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICBpZiAodHlwZSAhPT0gJ2tpbmcnKSByZXR1cm4gW107XG4gICAgICAgICAgcmV0dXJuIGdldExlZ2FsTW92ZXMoc3F1YXJlLCBib2FyZCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgcmV0dXJuIGdldExlZ2FsTW92ZXNJbkNoZWNrKFxuICAgICAgICAgICAgb3JpZ2luLFxuICAgICAgICAgICAgYm9hcmQsXG4gICAgICAgICAgICBnZXQua2luZ1Bvc2l0aW9uKGNvbG9yKSBhcyBTcXVhcmUsXG4gICAgICAgICAgICBzcXVhcmVzR2l2aW5nQ2hlY2tbMF1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICByZXR1cm4gZ2V0TGVnYWxNb3ZlcyhzcXVhcmUsIGJvYXJkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgZnJvbSA9IChzMTogU3F1YXJlKSA9PiAoe1xuICAgIHRvOiAoczI6IFNxdWFyZSkgPT4ge1xuICAgICAgY29uc3QgcGllY2UgPSBhdChzMSkucGllY2U7XG4gICAgICBpZiAoIXBpZWNlKSByZXR1cm47XG5cbiAgICAgIC8vIG1vdmUgcGllY2VcbiAgICAgIGF0KHMxKS5yZW1vdmUoKTtcbiAgICAgIGF0KHMyKS5wbGFjZShwaWVjZSk7XG4gICAgfVxuICB9KTtcblxuICBjb25zdCBnZXQgPSB7XG4gICAga2luZ1Bvc2l0aW9uOiAoY29sb3I6IENvbG9yKTogU3F1YXJlIHwgdW5kZWZpbmVkID0+IHtcbiAgICAgIGZvciAoY29uc3QgW3NxdWFyZSwgdmFsdWVdIG9mIGJvYXJkLmVudHJpZXMoKSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdmFsdWUucGllY2UgJiZcbiAgICAgICAgICB2YWx1ZS5waWVjZS50eXBlID09PSAna2luZycgJiZcbiAgICAgICAgICB2YWx1ZS5waWVjZS5jb2xvciA9PT0gY29sb3JcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiBzcXVhcmU7XG4gICAgICB9XG4gICAgfSxcbiAgICBwaWVjZU1hcDogKCk6IHtcbiAgICAgIHdoaXRlOiBQaWVjZU1hcDtcbiAgICAgIGJsYWNrOiBQaWVjZU1hcDtcbiAgICB9ID0+IHtcbiAgICAgIGNvbnN0IHBpZWNlTWFwID0geyB3aGl0ZToge30gYXMgUGllY2VNYXAsIGJsYWNrOiB7fSBhcyBQaWVjZU1hcCB9O1xuICAgICAgZm9yIChjb25zdCBbc3F1YXJlLCB2YWx1ZV0gb2YgYm9hcmQuZW50cmllcygpKSB7XG4gICAgICAgIGNvbnN0IHsgcGllY2UgfSA9IHZhbHVlO1xuICAgICAgICBpZiAoIXBpZWNlKSBjb250aW51ZTtcblxuICAgICAgICBjb25zdCB7IHR5cGUsIGNvbG9yIH0gPSBwaWVjZTtcbiAgICAgICAgcGllY2VNYXBbY29sb3JdW3R5cGVdID0gcGllY2VNYXBbY29sb3JdW3R5cGVdXG4gICAgICAgICAgPyBbLi4ucGllY2VNYXBbY29sb3JdW3R5cGVdLCBzcXVhcmVdXG4gICAgICAgICAgOiBbc3F1YXJlXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwaWVjZU1hcDtcbiAgICB9LFxuICAgIHNxdWFyZXNHaXZpbmdDaGVja0FmdGVyTW92ZTogKGZyb206IFNxdWFyZSwgZW5kOiBTcXVhcmUpOiBTcXVhcmVbXSA9PiB7XG4gICAgICBjb25zdCBzcXVhcmVzR2l2aW5nQ2hlY2s6IHN0cmluZ1tdID0gW107XG5cbiAgICAgIGNvbnN0IHBpZWNlID0gYm9hcmQuZ2V0KGVuZCk/LnBpZWNlIGFzIFBpZWNlT2JqO1xuICAgICAgY29uc3Qgb3BwQ29sb3IgPSBwaWVjZS5jb2xvciA9PT0gJ3doaXRlJyA/ICdibGFjaycgOiAnd2hpdGUnO1xuICAgICAgY29uc3Qga2luZ1Bvc2l0aW9uID0gZ2V0LmtpbmdQb3NpdGlvbihvcHBDb2xvcikgYXMgU3F1YXJlO1xuXG4gICAgICBjb25zdCBwaWVjZUhpdHNLaW5nID0gZ2V0TGVnYWxNb3ZlcyhlbmQsIGJvYXJkKS5pbmNsdWRlcyhraW5nUG9zaXRpb24pO1xuICAgICAgaWYgKHBpZWNlSGl0c0tpbmcpIHNxdWFyZXNHaXZpbmdDaGVjay5wdXNoKGVuZCk7XG5cbiAgICAgIGNvbnN0IGRpc2NvdmVyZWRDaGVjayA9IGdldERpc2NvdmVyZWRDaGVjayhcbiAgICAgICAga2luZ1Bvc2l0aW9uLFxuICAgICAgICBvcHBDb2xvcixcbiAgICAgICAgZnJvbSxcbiAgICAgICAgYm9hcmRcbiAgICAgICk7XG4gICAgICBpZiAoZGlzY292ZXJlZENoZWNrKSBzcXVhcmVzR2l2aW5nQ2hlY2sucHVzaChkaXNjb3ZlcmVkQ2hlY2spO1xuXG4gICAgICByZXR1cm4gc3F1YXJlc0dpdmluZ0NoZWNrO1xuICAgIH0sXG4gICAgaXNDaGVja21hdGU6IChjb2xvcjogQ29sb3IsIHNxdWFyZXNHaXZpbmdDaGVjazogc3RyaW5nW10pOiBib29sZWFuID0+IHtcbiAgICAgIGNvbnN0IGtpbmdQb3MgPSBnZXQua2luZ1Bvc2l0aW9uKGNvbG9yKSBhcyBTcXVhcmU7XG4gICAgICBjb25zdCBsZWdhbE1vdmVzID0gYXQoa2luZ1BvcykuZ2V0TGVnYWxNb3ZlcygpO1xuICAgICAgLy8gY2hlY2sgaWYgY2hlY2sgY2FuIGJlIGJsb2NrZWRcbiAgICAgIGlmIChzcXVhcmVzR2l2aW5nQ2hlY2subGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmIChjYW5CbG9ja09yQ2FwdHVyZUNoZWNrKGtpbmdQb3MsIHNxdWFyZXNHaXZpbmdDaGVja1swXSwgYm9hcmQpKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghbGVnYWxNb3ZlcyB8fCAhbGVnYWxNb3Zlcy5sZW5ndGgpIHJldHVybiB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGNyZWF0ZUJvYXJkLFxuICAgIGNhc3RsZSxcbiAgICBjYW5DYXN0bGUsXG4gICAgZW5QYXNzYW50LFxuICAgIGF0LFxuICAgIGZyb20sXG4gICAgZ2V0LFxuICAgIGdldCBib2FyZCgpIHtcbiAgICAgIHJldHVybiBib2FyZDtcbiAgICB9XG4gIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBHYW1lYm9hcmQ7XG4iLCIvLyBzaG91bGQgb3V0cHV0IGhpc3Rvcnkgb2JqZWN0IHRoYXQgaG9sZHMgbW92ZSBoaXN0b3J5IGluIDJkIGFycmF5XG4vLyBmb3IgZWFjaCBtb3ZlIG5lZWRzIHRvIGF0dGFjaCBwaWVjZSBUeXBlIHRvIGJlZ2lubmluZyBvZiBtb3ZlIGlmIG5vdCBwYXduXG4vLyBzaG91bGQgZnVydGhlciBzcGVjaWZ5IHNxdWFyZSBvZiBwaWVjZSBpZiwgc2F5IGJvdGggcm9va3MsIGNhbiBtb3ZlIHRvIHNhbWUgc3F1YXJlXG5cbmltcG9ydCB7IEFsbFBpZWNlTWFwLCBQaWVjZU9iaiB9IGZyb20gJy4vdHlwZXMvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBCb2FyZCwgUGllY2VUeXBlLCBTcXVhcmUgfSBmcm9tICcuL3R5cGVzL3R5cGVzJztcbmltcG9ydCB7IGdldExlZ2FsTW92ZXMgfSBmcm9tICcuL3V0aWxzL21vdmVzJztcblxudHlwZSBIaXN0b3J5VHlwZSA9IFNxdWFyZVtdW107XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhpc3RvcnkoXG4gIHByZXZIaXN0b3J5OiBIaXN0b3J5VHlwZSxcbiAgYm9hcmQ6IEJvYXJkLFxuICBwaWVjZU1hcDogQWxsUGllY2VNYXBcbikge1xuICBjb25zdCBoaXN0b3J5OiBIaXN0b3J5VHlwZSA9IHByZXZIaXN0b3J5IHx8IFtdO1xuXG4gIGNvbnN0IGdldCA9IHtcbiAgICBwaWVjZVByZWZpeDogKGZyb206IFNxdWFyZSwgdG86IFNxdWFyZSkgPT4ge1xuICAgICAgY29uc3QgeyB0eXBlLCBjb2xvciB9ID0gYm9hcmQuZ2V0KHRvKT8ucGllY2UgYXMgUGllY2VPYmo7XG5cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdwYXduJzpcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIGNhc2UgJ2tuaWdodCc6XG4gICAgICAgIGNhc2UgJ3Jvb2snOiB7XG4gICAgICAgICAgbGV0IHByZWZpeCA9IHR5cGUgPT09ICdyb29rJyA/ICdSJyA6ICdOJztcbiAgICAgICAgICBpZiAocGllY2VNYXBbY29sb3JdW3R5cGVdLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgLy8gbG9vayBmb3IgcGllY2Ugb2Ygc2FtZSB0eXBlIHRoYXQgY291bGR2ZSBhbHNvIHdlbnQgdG8gdGhlIHNxdWFyZVxuICAgICAgICAgICAgcGllY2VNYXBbY29sb3JdW3R5cGVdLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHMgPT09IHRvKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgY29uc3QgYm9hcmRDb3B5ID0gbmV3IE1hcChib2FyZCk7XG4gICAgICAgICAgICAgIGJvYXJkQ29weS5zZXQodG8sIHsgcGllY2U6IG51bGwgfSk7XG5cbiAgICAgICAgICAgICAgaWYgKGdldExlZ2FsTW92ZXMocywgYm9hcmRDb3B5KS5pbmNsdWRlcyh0bykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbeDEsIHkxXSA9IGZyb20uc3BsaXQoJycpO1xuICAgICAgICAgICAgICAgIGNvbnN0IFt4Ml0gPSBzLnNwbGl0KCcnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzYW1lRmlsZSA9IHgxID09PSB4MjtcblxuICAgICAgICAgICAgICAgIHByZWZpeCA9IHNhbWVGaWxlID8gcHJlZml4ICsgeTEgOiBwcmVmaXggKyB4MTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHByZWZpeDtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY29uc3QgcHJlZml4ID0gdHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICByZXR1cm4gcHJlZml4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjYXN0bGVOb3RhdGlvbjogKHNpZGU6ICdraW5nc2lkZScgfCAncXVlZW5zaWRlJykgPT4ge1xuICAgICAgcmV0dXJuIHNpZGUgPT09ICdraW5nc2lkZScgPyAnTy1PJyA6ICdPLU8tTyc7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGFmZml4ID0ge1xuICAgIGNhcHR1cmU6IChtb3ZlOiBTcXVhcmUsIHByZWZpeDogc3RyaW5nKSA9PiB7XG4gICAgICByZXR1cm4gYCR7cHJlZml4fXgke21vdmV9YDtcbiAgICB9LFxuICAgIHByb21vdGU6IChtb3ZlOiBTcXVhcmUsIHBpZWNlVHlwZTogUGllY2VUeXBlKSA9PiB7XG4gICAgICBjb25zdCBzdWZmaXggPVxuICAgICAgICBwaWVjZVR5cGUgPT09ICdrbmlnaHQnID8gJ04nIDogcGllY2VUeXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICByZXR1cm4gYCR7bW92ZX09JHtzdWZmaXh9YDtcbiAgICB9LFxuICAgIGNoZWNrOiAobm90YXRpb246IHN0cmluZykgPT4ge1xuICAgICAgcmV0dXJuIGAke25vdGF0aW9ufStgO1xuICAgIH0sXG4gICAgY2hlY2ttYXRlOiAobm90YXRpb246IHN0cmluZykgPT4ge1xuICAgICAgcmV0dXJuIGAke25vdGF0aW9ufSNgO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGdldCxcbiAgICBhZmZpeCxcbiAgICBpbnNlcnRNb3ZlOiAobm90YXRpb246IHN0cmluZykgPT4ge1xuICAgICAgY29uc3QgbGFzdE1vdmVQYWlyID0gaGlzdG9yeVtoaXN0b3J5Lmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGxhc3RNb3ZlUGFpci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgbGFzdE1vdmVQYWlyLnB1c2gobm90YXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbmV3TW92ZVBhaXIgPSBbbm90YXRpb25dO1xuICAgICAgICBoaXN0b3J5LnB1c2gobmV3TW92ZVBhaXIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbiIsImltcG9ydCBHYW1lYm9hcmQgZnJvbSAnLi9HYW1lYm9hcmQnO1xuaW1wb3J0IEhpc3RvcnkgZnJvbSAnLi9IaXN0b3J5JztcblxuZXhwb3J0IHsgR2FtZWJvYXJkLCBIaXN0b3J5IH07XG4iXSwibmFtZXMiOlsidG9YWSIsInNxdWFyZSIsIngiLCJ5Iiwic3BsaXQiLCJpbmRleE9mIiwidG9Mb3dlckNhc2UiLCJOdW1iZXIiLCJmcm9tWFkiLCJjb29yZCIsImNvbCIsImNvbmNhdCIsInRvU3RyaW5nIiwiY2FsY0Rpc3RhbmNlIiwic3F1YXJlT25lIiwic3F1YXJlVHdvIiwieDEiLCJ5MSIsIngyIiwieTIiLCJ4RGlmZiIsInlEaWZmIiwibW92ZXMiLCJQaWVjZSIsImNvbG9yIiwidHlwZSIsImhhc01vdmUiLCJmcm9tIiwidG8iLCJvbmVTcXVhcmVWZXJ0IiwieUJ5TiIsInhCeU4iLCJvbmVTcXVhcmVMYXRlcmFsIiwib25lU3F1YXJlRGlhZ29uYWxseSIsImRpYWdvbmFsIiwidmVydEFuZExhdGVyYWwiLCJvbmx5TW92ZXNJbkZyb250IiwicmVndWxhck1vdmUiLCJmaXJzdE1vdmUiLCJqdW1wVHdvIiwiZ2V0UGF3bkNhcHR1cmVzIiwib3JpZ2luIiwibmV3WSIsImNhcHR1cmVPbmUiLCJjYXB0dXJlVHdvIiwiTWF0aCIsImFicyIsIm51bSIsInNwbGl0SW50b1ZlY3RvcnMiLCJhcnJheU9mTW92ZXMiLCJzdGFydCIsInJlZHVjZSIsImFjYyIsImN1cnIiLCJ2ZWN0b3IiLCJjaGFyQXQiLCJzbGljZSIsInB1c2giLCJnZXRCZWdpbm5pbmdPZlZlY3RvciIsImxlbmd0aCIsImFjY0lzQmVnaW5uaW5nIiwiZ2V0TW92ZXNBbG9uZ1ZlY3RvciIsInMxIiwiczIiLCJhbGxTcXVhcmVzIiwibGllc1NhbWVWZXJ0T3JMYXQiLCJsaWVzU2FtZURpYWdvbmFsbHkiLCJsaWVzT25TYW1lTGluZSIsIm1hdGNoaW5nVmVjdG9yIiwic3F1YXJlc0Fsb25nVmVjdG9yIiwiZmlsdGVyIiwicyIsInNvcnRNb3Zlc0Nsb3Nlc3RUbyIsInNvcnQiLCJhIiwiYiIsIngxRGlmZiIsInkxRGlmZiIsImFEaWZmIiwieDJEaWZmIiwieTJEaWZmIiwiYkRpZmYiLCJnZXRQb3NzaWJsZU1vdmVzIiwiYm9hcmQiLCJBcnJheSIsImtleXMiLCJnZXQiLCJwaWVjZSIsImdldExlZ2FsTW92ZXMiLCJwb3NzaWJsZU1vdmVzIiwib2JzdHJ1Y3Rpb25zIiwiX2EiLCJsZWdhbE1vdmVzIiwiY2FwdHVyZXNBdmFpbGFibGUiLCJ1bm9ic3RydWN0ZWRNb3ZlcyIsInJlbW92ZU1vdmVzV2l0aFBpZWNlcyIsInJlbW92ZU9ic3RydWN0ZWRNb3ZlcyIsInJlbW92ZVByb3RlY3RlZFNxdWFyZXMiLCJnZXRMZWdhbE1vdmVzSW5DaGVjayIsImtpbmdQb3MiLCJzcXVhcmVHaXZpbmdDaGVjayIsInNxdWFyZXNUaGF0RGVhbFdpdGhDaGVjayIsImdldFNxdWFyZXNCZXR3ZWVuS2luZ0FuZENoZWNrIiwiaW5jbHVkZXMiLCJnZXRBdHRhY2tpbmdNb3ZlcyIsImdldEFsbE1vdmVzRm9yQ29sb3IiLCJhbGxNb3ZlcyIsImVudHJpZXMiLCJmbGF0IiwiZ2V0QXR0YWNraW5nTW92ZXNGb3JDb2xvciIsInBhd25TcXVhcmUiLCJwYXduIiwiY2FwdHVyZU1vdmVzIiwic3F1YXJlVmFsIiwiZW5QYXNzYW50IiwiY2hlY2tQb3MiLCJzcXVhcmVzQmV0d2VlbktpbmdBbmRQaWVjZSIsInJlbW92ZU1vdmVzQmVoaW5kVHdvU3F1YXJlcyIsInNvcnRlZCIsImZ1cnRoZXN0U3F1YXJlIiwiY2xvc2VzdFNxdWFyZSIsInJlbW92ZWRPbmVFbmQiLCJyZW1vdmVNb3Zlc0JlaGluZFNxdWFyZSIsInJlbW92ZWRCb3RoRW5kcyIsInJldmVyc2UiLCJjb3B5IiwiaW5kZXgiLCJzcGxpY2UiLCJzdGFydGluZ1NxdWFyZSIsImZpbHRlcmVkTW92ZXMiLCJhbGxWZWN0b3JzIiwib2JzdHJ1Y3Rpb25WZWN0b3JzIiwiY2xvc2VzdE9ic3RydWN0aW9uIiwia2luZyIsIm9wcENvbG9yIiwiYWxsRW5lbXlNb3ZlcyIsImdldERpc2NvdmVyZWRDaGVjayIsImtpbmdDb2xvciIsInZhY2F0ZWQiLCJjYW5CbG9ja09yQ2FwdHVyZUNoZWNrIiwiYmxvY2tPckNhcHR1cmVTcXVhcmVzIiwib3duUGllY2VNb3ZlcyIsInNvbWUiLCJtb3ZlIiwiR2FtZWJvYXJkIiwic3F1YXJlc0dpdmluZ0NoZWNrIiwiY3JlYXRlQm9hcmQiLCJmaWxlcyIsInJhbmtzIiwiZmlsZSIsImZvckVhY2giLCJyYW5rIiwic2V0IiwiTWFwIiwiY2FuQ2FzdGxlIiwic2lkZSIsImNhc3RsZVNxdWFyZXMiLCJvcHBNb3ZlcyIsImF0IiwiY2FzdGxlIiwia2luZ1Bvc2l0aW9uIiwicm9va1BvcyIsImdldFJvb2tQb3MiLCJwaWVjZU1hcCIsInJvb2siLCJmaW5kIiwiZ2V0U3F1YXJlIiwiY3VycmVudCIsImNoZWNrVG9nZ2xlIiwidG9nZ2xlIiwiZW5QYXNzYW50U3F1YXJlIiwic2V0RW5QYXNzYW50IiwicmVtb3ZlIiwic3F1YXJlT2JqIiwidmFsdWVzIiwidW5kZWZpbmVkIiwicGxhY2UiLCJwcm9tb3RlIiwicGllY2VUeXBlIiwiT2JqZWN0IiwidmFsdWUiLCJ3aGl0ZSIsImJsYWNrIiwic3F1YXJlc0dpdmluZ0NoZWNrQWZ0ZXJNb3ZlIiwiZW5kIiwicGllY2VIaXRzS2luZyIsImRpc2NvdmVyZWRDaGVjayIsImlzQ2hlY2ttYXRlIiwiSGlzdG9yeSIsInByZXZIaXN0b3J5IiwiaGlzdG9yeSIsInBpZWNlUHJlZml4IiwicHJlZml4IiwiYm9hcmRDb3B5Iiwic2FtZUZpbGUiLCJ0b1VwcGVyQ2FzZSIsImNhc3RsZU5vdGF0aW9uIiwiYWZmaXgiLCJjYXB0dXJlIiwic3VmZml4IiwiY2hlY2siLCJub3RhdGlvbiIsImNoZWNrbWF0ZSIsImluc2VydE1vdmUiLCJsYXN0TW92ZVBhaXIiLCJuZXdNb3ZlUGFpciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///371\n")}},__webpack_require__={d:(Q,F)=>{for(var B in F)__webpack_require__.o(F,B)&&!__webpack_require__.o(Q,B)&&Object.defineProperty(Q,B,{enumerable:!0,get:F[B]})},o:(Q,F)=>Object.prototype.hasOwnProperty.call(Q,F),r:Q=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})}},__webpack_exports__={};return __webpack_modules__[371](0,__webpack_exports__,__webpack_require__),__webpack_exports__})()}));