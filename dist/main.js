!function(Q,F){"object"==typeof exports&&"object"==typeof module?module.exports=F():"function"==typeof define&&define.amd?define([],F):"object"==typeof exports?exports.croChess=F():Q.croChess=F()}(this,(function(){return(()=>{"use strict";var __webpack_modules__={127:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"Gameboard\": () => (/* reexport */ src_Gameboard),\n  \"History\": () => (/* reexport */ History),\n  \"files\": () => (/* reexport */ files),\n  \"ranks\": () => (/* reexport */ ranks),\n  \"startingPositions\": () => (/* reexport */ startingPositions_namespaceObject)\n});\n\n// NAMESPACE OBJECT: ./src/startingPositions.ts\nvar startingPositions_namespaceObject = {};\n__webpack_require__.r(startingPositions_namespaceObject);\n__webpack_require__.d(startingPositions_namespaceObject, {\n  \"standard\": () => (standard)\n});\n\n;// CONCATENATED MODULE: ./src/utils/helpers.ts\nfunction toXY(square) {\n  const [x, y] = square.split('');\n  return {\n    x: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'].indexOf(x.toLowerCase()),\n    y: Number(y)\n  };\n}\n\nfunction fromXY(coord) {\n  const {\n    x,\n    y\n  } = coord;\n  const col = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'][x];\n  if (!col) return '';\n  return col.concat(y.toString());\n}\n\nconst calcDistance = squareOne => squareTwo => {\n  const {\n    x: x1,\n    y: y1\n  } = toXY(squareOne);\n  const {\n    x: x2,\n    y: y2\n  } = toXY(squareTwo);\n  const xDiff = x1 - x2;\n  const yDiff = y1 - y2;\n  return {\n    xDiff,\n    yDiff\n  };\n};\n\n\n;// CONCATENATED MODULE: ./src/Piece.ts\n\n\n\nconst Piece = (color, type) => {\n  function hasMove(from, to) {\n    switch (type) {\n      case 'king':\n        {\n          const oneSquareVert = utils_moves.yByN(1)(from)(to) && utils_moves.xByN(0)(from)(to);\n          const oneSquareLateral = utils_moves.xByN(1)(from)(to) && utils_moves.yByN(0)(from)(to);\n          const oneSquareDiagonally = utils_moves.yByN(1)(from)(to) && utils_moves.xByN(1)(from)(to);\n          return from !== to && (oneSquareDiagonally || oneSquareVert || oneSquareLateral);\n        }\n\n      case 'queen':\n        {\n          return from !== to && (utils_moves.diagonal(from)(to) || utils_moves.vertAndLateral(from)(to));\n        }\n\n      case 'bishop':\n        {\n          return from !== to && utils_moves.diagonal(from)(to);\n        }\n\n      case 'knight':\n        {\n          return from !== to && (utils_moves.xByN(1)(from)(to) && utils_moves.yByN(2)(from)(to) || utils_moves.xByN(2)(from)(to) && utils_moves.yByN(1)(from)(to));\n        }\n\n      case 'rook':\n        {\n          return from !== to && utils_moves.vertAndLateral(to)(from);\n        }\n\n      case 'pawn':\n        {\n          const {\n            x: x1,\n            y: y1\n          } = toXY(from);\n          const {\n            x: x2,\n            y: y2\n          } = toXY(to);\n          const onlyMovesInFront = color === 'white' ? y1 < y2 : y1 > y2;\n          const regularMove = utils_moves.yByN(1)(from)(to) && x1 === x2;\n          const firstMove = color === 'white' ? y1 === 2 : y1 === 7;\n          const jumpTwo = utils_moves.yByN(2)(from)(to) && x1 === x2;\n          return from !== to && onlyMovesInFront && (regularMove || firstMove && jumpTwo);\n        }\n    }\n  }\n\n  function getPawnCaptures(origin) {\n    if (type !== 'pawn') return;\n    const {\n      x,\n      y\n    } = toXY(origin);\n    const newY = color === 'white' ? y + 1 : y - 1;\n    const captureOne = {\n      x: x + 1,\n      y: newY\n    };\n    const captureTwo = {\n      x: x - 1,\n      y: newY\n    };\n    return [fromXY(captureOne), fromXY(captureTwo)];\n  }\n\n  return {\n    hasMove,\n    getPawnCaptures,\n\n    get type() {\n      return type;\n    },\n\n    get color() {\n      return color;\n    }\n\n  };\n};\n\n/* harmony default export */ const src_Piece = (Piece);\n;// CONCATENATED MODULE: ./src/utils/moves.ts\n\n\nconst moves = {\n  vertAndLateral: from => to => {\n    const [x1, y1] = from.split('');\n    const [x2, y2] = to.split('');\n    return x1 === x2 || y1 === y2;\n  },\n  diagonal: from => to => {\n    const {\n      x: x1,\n      y: y1\n    } = toXY(from);\n    const {\n      x: x2,\n      y: y2\n    } = toXY(to);\n    return Math.abs(x2 - x1) === Math.abs(y2 - y1);\n  },\n  xByN: num => from => to => {\n    const {\n      x: x1\n    } = toXY(from);\n    const {\n      x: x2\n    } = toXY(to);\n    return Math.abs(x1 - x2) === num;\n  },\n  yByN: num => from => to => {\n    const {\n      y: y1\n    } = toXY(from);\n    const {\n      y: y2\n    } = toXY(to);\n    return Math.abs(y1 - y2) === num;\n  }\n};\n/* harmony default export */ const utils_moves = (moves);\n/* dealing with move vectors */\n\nfunction splitIntoVectors(arrayOfMoves, start) {\n  return arrayOfMoves.reduce((acc, curr) => {\n    const {\n      xDiff,\n      yDiff\n    } = calcDistance(start)(curr);\n    let vector = '';\n    if (yDiff !== 0) vector = yDiff < 0 ? 'up' : 'down';\n    if (xDiff !== 0) vector += xDiff < 0 ? 'Right' : 'Left'; // normalize vector name\n\n    vector = vector.charAt(0).toLowerCase() + vector.slice(1);\n    acc[vector] = acc[vector] || [];\n    acc[vector].push(curr);\n    return acc;\n  }, {});\n}\n\nfunction getBeginningOfVector(vector) {\n  if (vector.length === 0) return '';\n  return vector.reduce((acc, curr) => {\n    const {\n      x: x1,\n      y: y1\n    } = toXY(acc);\n    const {\n      x: x2,\n      y: y2\n    } = toXY(curr);\n    const accIsBeginning = x1 === x2 ? y1 < y2 : x1 < x2;\n    return accIsBeginning ? acc : curr;\n  });\n}\n\nconst getMovesAlongVector = (s1, s2, allSquares) => {\n  const liesSameVertOrLat = moves.vertAndLateral(s1)(s2);\n  const liesSameDiagonally = moves.diagonal(s1)(s2);\n  const liesOnSameLine = liesSameVertOrLat || liesSameDiagonally;\n  if (!liesOnSameLine) return [];\n  const matchingVector = liesSameDiagonally ? 'diagonal' : 'vertAndLateral';\n  const squaresAlongVector = allSquares.filter(s => moves[matchingVector](s1)(s) && moves[matchingVector](s2)(s));\n  return squaresAlongVector;\n};\n/* sort moves */\n\n\nconst sortMovesClosestTo = square => moves => {\n  return [...moves].sort((a, b) => {\n    const {\n      xDiff: x1Diff,\n      yDiff: y1Diff\n    } = calcDistance(square)(a);\n    const aDiff = Math.abs(x1Diff) + Math.abs(y1Diff);\n    const {\n      xDiff: x2Diff,\n      yDiff: y2Diff\n    } = calcDistance(square)(b);\n    const bDiff = Math.abs(x2Diff) + Math.abs(y2Diff);\n    return aDiff - bDiff;\n  });\n};\n/* get moves */\n\n\nfunction getPossibleMoves(origin, board) {\n  // get all moves that can happen if no other pieces were on the board\n  const allSquares = Array.from(board.keys());\n  const square = board.get(origin);\n  const {\n    type,\n    color\n  } = square.piece;\n  const piece = src_Piece(color, type);\n  return allSquares.filter(s => piece.hasMove(origin, s));\n}\n\nfunction getLegalMoves(origin, board) {\n  // get moves regardless of whether or not there is check\n  const square = board.get(origin);\n  const piece = square.piece;\n  const possibleMoves = getPossibleMoves(origin, board);\n  const obstructions = possibleMoves.filter(s => {\n    var _a;\n\n    return (_a = board.get(s)) === null || _a === void 0 ? void 0 : _a.piece;\n  });\n\n  if (!obstructions.length) {\n    if (piece.type === 'pawn') return [...getPawnCaptures(origin, board), ...possibleMoves];\n    return possibleMoves;\n  }\n\n  let legalMoves = [];\n\n  switch (piece.type) {\n    case 'knight':\n      {\n        legalMoves = possibleMoves;\n        break;\n      }\n\n    case 'pawn':\n      {\n        const capturesAvailable = getPawnCaptures(origin, board);\n        const unobstructedMoves = removeMovesWithPieces(removeObstructedMoves(origin, possibleMoves, obstructions), board);\n        legalMoves = [...capturesAvailable, ...unobstructedMoves];\n        break;\n      }\n\n    case 'king':\n      {\n        legalMoves = removeProtectedSquares(piece, possibleMoves, board);\n        break;\n      }\n\n    default:\n      {\n        legalMoves = removeObstructedMoves(origin, possibleMoves, obstructions);\n      }\n  }\n\n  return removeMovesWithPieces(legalMoves, board, piece.color);\n}\n\nfunction getLegalMovesInCheck(origin, board, kingPos, squareGivingCheck) {\n  const squaresThatDealWithCheck = getSquaresBetweenKingAndCheck(kingPos, squareGivingCheck, Array.from(board.keys()));\n  const moves = getLegalMoves(origin, board);\n  return moves.filter(s => squaresThatDealWithCheck.includes(s));\n}\n\nfunction getAttackingMoves(origin, board) {\n  // for when you need to check for if squares are protected\n  const square = board.get(origin);\n  const {\n    type,\n    color\n  } = square.piece;\n\n  switch (type) {\n    case 'pawn':\n      {\n        const piece = src_Piece(color, 'pawn');\n        return piece.getPawnCaptures(origin);\n      }\n\n    default:\n      return getLegalMoves(origin, board);\n  }\n}\n\nfunction getAllMovesForColor(color, board) {\n  const allMoves = [];\n\n  for (const [square, {\n    piece\n  }] of board.entries()) {\n    if (!piece) continue;\n    if (piece.color !== color) continue;\n    allMoves.push(getLegalMoves(square, board));\n  }\n\n  return allMoves.flat();\n}\n\nfunction getAttackingMovesForColor(color, board) {\n  const allMoves = [];\n\n  for (const [square, {\n    piece\n  }] of board.entries()) {\n    if (!piece) continue;\n    if (piece.color !== color) continue;\n    allMoves.push(getAttackingMoves(square, board));\n  }\n\n  return allMoves.flat();\n}\n\nfunction getPawnCaptures(pawnSquare, board) {\n  var _a;\n\n  const {\n    color\n  } = (_a = board.get(pawnSquare)) === null || _a === void 0 ? void 0 : _a.piece;\n  const pawn = src_Piece(color, 'pawn');\n  const captureMoves = pawn.getPawnCaptures(pawnSquare);\n  if (!captureMoves) return [];\n  return captureMoves.filter(s => {\n    const squareVal = board.get(s);\n    if (!squareVal) return false;\n    const piece = squareVal.piece;\n    const enPassant = squareVal.enPassant;\n    return piece && piece.color !== pawn.color || enPassant && enPassant.color !== pawn.color;\n  });\n}\n\nfunction getSquaresBetweenKingAndCheck(kingPos, checkPos, allSquares) {\n  // includes kingPos and checkPos\n  const squaresAlongVector = getMovesAlongVector(kingPos, checkPos, allSquares);\n  const squaresBetweenKingAndPiece = removeMovesBehindTwoSquares(kingPos, checkPos, squaresAlongVector);\n  return squaresBetweenKingAndPiece;\n}\n/* filter moves */\n\n\nfunction removeMovesBehindTwoSquares(s1, s2, vector) {\n  const sorted = sortMovesClosestTo(getBeginningOfVector(vector))(vector);\n  let furthestSquare;\n  let closestSquare;\n\n  if (sorted.indexOf(s1) > sorted.indexOf(s2)) {\n    furthestSquare = s1;\n    closestSquare = s2;\n  } else {\n    furthestSquare = s2;\n    closestSquare = s1;\n  }\n\n  const removedOneEnd = removeMovesBehindSquare(furthestSquare)(sorted);\n  const removedBothEnds = removeMovesBehindSquare(closestSquare)(removedOneEnd.reverse());\n  return removedBothEnds;\n}\n\nconst removeMovesBehindSquare = square => moves => {\n  const copy = [...moves];\n  const index = moves.indexOf(square);\n  if (index === -1) return [];\n  copy.splice(index + 1);\n  return copy;\n};\n\nfunction removeObstructedMoves(startingSquare, possibleMoves, obstructions) {\n  // a) split possible moves into vectors (up,down,left,right, and/or diagonals)\n  // b) see which obstructions belong to which vector\n  // c) find the closest obstruction\n  // d) remove all the moves behind that obstruction\n  const filteredMoves = [];\n  const allVectors = splitIntoVectors(possibleMoves, startingSquare);\n  const obstructionVectors = splitIntoVectors(obstructions, startingSquare);\n\n  for (const vector in allVectors) {\n    if (!obstructionVectors[vector]) {\n      // look for vector obstruction is on\n      filteredMoves.push(allVectors[vector]);\n      continue;\n    }\n\n    const sorted = sortMovesClosestTo(startingSquare)(allVectors[vector]);\n    const closestObstruction = sortMovesClosestTo(startingSquare)(obstructionVectors[vector])[0];\n    filteredMoves.push(removeMovesBehindSquare(closestObstruction)(sorted));\n  }\n\n  return filteredMoves.flat();\n}\n\nfunction removeProtectedSquares(king, possibleMoves, board) {\n  // bc king cant move if square is protected\n  const oppColor = king.color === 'white' ? 'black' : 'white';\n  const allEnemyMoves = getAttackingMovesForColor(oppColor, board);\n  return possibleMoves.filter(s => {\n    return !allEnemyMoves.includes(s);\n  });\n}\n\nfunction removeMovesWithPieces(moves, board, color) {\n  return moves.filter(s => {\n    const squareVal = board.get(s);\n    if (!squareVal) return false;\n    if (color) return !squareVal.piece || squareVal.piece.color !== color;else return !squareVal.piece;\n  });\n}\n/* gameboard checks */\n\n\nfunction getDiscoveredCheck(kingPos, kingColor, vacated, board) {\n  var _a; // openSquare is a square just vacated\n\n\n  let squaresAlongVector = getMovesAlongVector(kingPos, vacated, Array.from(board.keys()));\n  squaresAlongVector = squaresAlongVector.filter(s => s !== kingPos && s !== vacated);\n  if (!squaresAlongVector.length) return '';\n\n  for (const square of squaresAlongVector) {\n    const piece = (_a = board.get(square)) === null || _a === void 0 ? void 0 : _a.piece;\n    if (!piece || piece.color === kingColor) continue;\n    const legalMoves = getLegalMoves(square, board);\n    if (legalMoves.includes(kingPos)) return square;\n  }\n\n  return '';\n}\n\nfunction canBlockOrCaptureCheck(kingPos, squareGivingCheck, board) {\n  var _a;\n\n  const king = (_a = board.get(kingPos)) === null || _a === void 0 ? void 0 : _a.piece;\n  const blockOrCaptureSquares = getSquaresBetweenKingAndCheck(kingPos, squareGivingCheck, Array.from(board.keys())); // also includes check square\n\n  const ownPieceMoves = getAllMovesForColor(king.color, board);\n  return ownPieceMoves.some(move => blockOrCaptureSquares.includes(move));\n}\n\n\n;// CONCATENATED MODULE: ./src/ranksAndFiles.ts\nconst files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];\nconst ranks = [1, 2, 3, 4, 5, 6, 7, 8];\n\n;// CONCATENATED MODULE: ./src/Gameboard.ts\n\n\n\n\nfunction createBoard() {\n  return files.reduce((acc, file) => {\n    ranks.forEach(rank => {\n      const square = file.concat(rank.toString());\n      acc.set(square, {\n        piece: null\n      });\n    });\n    return acc;\n  }, new Map());\n}\n\nconst Gameboard = (board = createBoard(), squaresGivingCheck, Castle) => {\n  function canCastle(color, side) {\n    if (Castle && !Castle[color][side]) return false; // check if rook still exists\n\n    if (!checkIfRookExists()) return false;\n    const oppColor = color === 'white' ? 'black' : 'white';\n    const oppMoves = getAttackingMovesForColor(oppColor, board);\n    const castleSquares = get.castleSquares(color)[side];\n\n    for (const square of castleSquares) {\n      // check if castle square is cleared\n      if (at(square).piece) return false; // make sure castle square isnt attacked\n\n      if (oppMoves.includes(square)) return false;\n    }\n\n    return true;\n\n    function checkIfRookExists() {\n      let rookExists = false;\n      const rank = color === 'white' ? 1 : 8;\n      const loopStart = side === 'queenside' ? files.indexOf('a') : files.indexOf('d');\n      const loopEnd = side === 'queenside' ? files.indexOf('e') : files.indexOf('h');\n\n      for (let i = loopStart; i <= loopEnd; i++) {\n        const square = files[i] + rank;\n        const piece = at(square).piece;\n        if (!piece) continue;\n        if (piece.type === 'rook') rookExists = true;\n      }\n\n      return rookExists;\n    }\n  }\n\n  function castle(color, side) {\n    const rank = color === 'white' ? 1 : 8;\n    const castleSquares = side === 'kingside' ? [`f${rank}`, `g${rank}`] : [`d${rank}`, `c${rank}`];\n    const kingPos = get.kingPosition(color);\n    const rookPos = getRookPos();\n    from(rookPos).to(castleSquares[0]);\n    from(kingPos).to(castleSquares[1]);\n\n    function getRookPos() {\n      const pieceMap = get.pieceMap();\n      const rookPos = pieceMap[color].rook.find(square => {\n        const file = square.split('')[0];\n        return side === 'kingside' ? files.indexOf(file) > 3 : files.indexOf(file) < 3;\n      });\n      return rookPos;\n    } // need to get king position\n    // need to get castle squares\n    // need to find rook\n\n  }\n\n  const enPassant = (() => {\n    function getSquare(current, color) {\n      const {\n        x,\n        y\n      } = toXY(current);\n      const newY = color === 'white' ? y - 1 : y + 1;\n      return fromXY({\n        x,\n        y: newY\n      });\n    }\n\n    return {\n      checkToggle: (from, to) => {\n        const {\n          y: y1\n        } = toXY(from);\n        const {\n          y: y2\n        } = toXY(to);\n        return Math.abs(y1 - y2) === 2;\n      },\n      toggle: (current, color) => {\n        const enPassantSquare = getSquare(current, color);\n        at(enPassantSquare).setEnPassant(color, current);\n      },\n      remove: () => {\n        for (const squareObj of board.values()) {\n          if (squareObj.enPassant) return squareObj.enPassant = undefined;\n        }\n      }\n    };\n  })();\n\n  const at = square => ({\n    place: piece => {\n      if (!board.get(square)) return;\n      board.set(square, {\n        piece\n      });\n    },\n    remove: () => {\n      if (!board.get(square)) return;\n      board.set(square, {\n        piece: null\n      });\n    },\n    promote: pieceType => {\n      const squareVal = board.get(square);\n      const piece = squareVal === null || squareVal === void 0 ? void 0 : squareVal.piece;\n      if (!piece) return;\n      board.set(square, Object.assign(Object.assign({}, squareVal), {\n        piece: Object.assign(Object.assign({}, piece), {\n          type: pieceType\n        })\n      }));\n    },\n    setEnPassant: (color, current) => {\n      if (!board.get(square)) return;\n      board.set(square, {\n        piece: null,\n        enPassant: {\n          current,\n          color: color\n        }\n      });\n    },\n\n    get piece() {\n      var _a;\n\n      return (_a = board.get(square)) === null || _a === void 0 ? void 0 : _a.piece;\n    },\n\n    getLegalMoves: () => {\n      squaresGivingCheck = squaresGivingCheck || [];\n      const {\n        type,\n        color\n      } = at(square).piece;\n\n      switch (squaresGivingCheck.length) {\n        case 2:\n          {\n            if (type !== 'king') return [];\n            return getLegalMoves(square, board);\n          }\n\n        case 1:\n          {\n            return getLegalMovesInCheck(origin, board, get.kingPosition(color), squaresGivingCheck[0]);\n          }\n\n        default:\n          {\n            if (type === 'king') {\n              let legalMoves = getLegalMoves(square, board);\n              if (canCastle(color, 'kingside')) legalMoves = [...legalMoves, ...get.castleSquares(color).kingside];\n              if (canCastle(color, 'queenside')) legalMoves = [...legalMoves, ...get.castleSquares(color).queenside];\n              return legalMoves;\n            } else return getLegalMoves(square, board);\n          }\n      }\n    }\n  });\n\n  const from = s1 => ({\n    to: s2 => {\n      const piece = at(s1).piece;\n      if (!piece) return; // move piece\n\n      at(s1).remove();\n      at(s2).place(piece);\n    }\n  });\n\n  const get = {\n    kingPosition: color => {\n      for (const [square, value] of board.entries()) {\n        if (value.piece && value.piece.type === 'king' && value.piece.color === color) return square;\n      }\n    },\n    pieceMap: () => {\n      const pieceMap = {\n        white: {},\n        black: {}\n      };\n\n      for (const [square, value] of board.entries()) {\n        const {\n          piece\n        } = value;\n        if (!piece) continue;\n        const {\n          type,\n          color\n        } = piece;\n        pieceMap[color][type] = pieceMap[color][type] ? [...pieceMap[color][type], square] : [square];\n      }\n\n      return pieceMap;\n    },\n    squaresGivingCheckAfterMove: (from, end) => {\n      var _a;\n\n      const squaresGivingCheck = [];\n      const piece = (_a = board.get(end)) === null || _a === void 0 ? void 0 : _a.piece;\n      const oppColor = piece.color === 'white' ? 'black' : 'white';\n      const kingPosition = get.kingPosition(oppColor);\n      const pieceHitsKing = getLegalMoves(end, board).includes(kingPosition);\n      if (pieceHitsKing) squaresGivingCheck.push(end);\n      const discoveredCheck = getDiscoveredCheck(kingPosition, oppColor, from, board);\n      if (discoveredCheck) squaresGivingCheck.push(discoveredCheck);\n      return squaresGivingCheck;\n    },\n    isCheckmate: (color, squaresGivingCheck) => {\n      const kingPos = get.kingPosition(color);\n      const legalMoves = at(kingPos).getLegalMoves(); // check if check can be blocked\n\n      if (squaresGivingCheck.length === 1) {\n        if (canBlockOrCaptureCheck(kingPos, squaresGivingCheck[0], board)) return false;\n      }\n\n      if (!legalMoves || !legalMoves.length) return true;\n      return false;\n    },\n\n    castleSquares(color) {\n      const rank = color === 'white' ? 1 : 8;\n      return {\n        kingside: [`f${rank}`, `g${rank}`],\n        queenside: [`c${rank}`, `d${rank}`]\n      };\n    }\n\n  };\n  return {\n    createBoard,\n    castle,\n    canCastle,\n    enPassant,\n    at,\n    from,\n    get,\n\n    get board() {\n      return board;\n    }\n\n  };\n};\n\n/* harmony default export */ const src_Gameboard = (Gameboard);\n;// CONCATENATED MODULE: ./src/History.ts\n// should output history object that holds move history in 2d array\n// for each move needs to attach piece Type to beginning of move if not pawn\n// should further specify square of piece if, say both rooks, can move to same square\n\nfunction History(prevHistory, board, pieceMap) {\n  const history = prevHistory || [];\n  const get = {\n    piecePrefix: (from, to) => {\n      var _a;\n\n      const {\n        type,\n        color\n      } = (_a = board.get(to)) === null || _a === void 0 ? void 0 : _a.piece;\n\n      switch (type) {\n        case 'pawn':\n          return '';\n\n        case 'knight':\n        case 'rook':\n          {\n            let prefix = type === 'rook' ? 'R' : 'N';\n\n            if (pieceMap[color][type].length !== 1) {\n              // look for piece of same type that couldve also went to the square\n              pieceMap[color][type].forEach(s => {\n                if (s === to) return;\n                const boardCopy = new Map(board);\n                boardCopy.set(to, {\n                  piece: null\n                });\n\n                if (getLegalMoves(s, boardCopy).includes(to)) {\n                  const [x1, y1] = from.split('');\n                  const [x2] = s.split('');\n                  const sameFile = x1 === x2;\n                  prefix = sameFile ? prefix + y1 : prefix + x1;\n                }\n              });\n            }\n\n            return prefix;\n          }\n\n        default:\n          {\n            const prefix = type.charAt(0).toUpperCase();\n            return prefix;\n          }\n      }\n    },\n    castleNotation: side => {\n      return side === 'kingside' ? 'O-O' : 'O-O-O';\n    }\n  };\n  const affix = {\n    capture: (move, prefix) => {\n      return `${prefix}x${move}`;\n    },\n    promote: (move, pieceType) => {\n      const suffix = pieceType === 'knight' ? 'N' : pieceType.charAt(0).toUpperCase();\n      return `${move}=${suffix}`;\n    },\n    check: notation => {\n      return `${notation}+`;\n    },\n    checkmate: notation => {\n      return `${notation}#`;\n    }\n  };\n  return {\n    get,\n    affix,\n    insertMove: notation => {\n      const lastMovePair = history[history.length - 1];\n\n      if (lastMovePair.length === 1) {\n        lastMovePair.push(notation);\n      } else {\n        const newMovePair = [notation];\n        history.push(newMovePair);\n      }\n    }\n  };\n}\n;// CONCATENATED MODULE: ./src/startingPositions.ts\nconst standard = {\n  white: {\n    rook: ['a1', 'h1'],\n    knight: ['g1', 'b1'],\n    bishop: ['f1', 'c1'],\n    king: ['e1'],\n    queen: ['d1'],\n    pawn: ['a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2']\n  },\n  black: {\n    rook: ['a8', 'h8'],\n    knight: ['g8', 'b8'],\n    bishop: ['f8', 'c8'],\n    king: ['e8'],\n    queen: ['d8'],\n    pawn: ['a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7']\n  }\n};\n\n;// CONCATENATED MODULE: ./src/main.ts\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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THBCLFFBQUksRUFBRSxDQUFDLElBQUQsRUFBTyxJQUFQLENBREQ7QUFFTDZDLFVBQU0sRUFBRSxDQUFDLElBQUQsRUFBTyxJQUFQLENBRkg7QUFHTEMsVUFBTSxFQUFFLENBQUMsSUFBRCxFQUFPLElBQVAsQ0FISDtBQUlMbkYsUUFBSSxFQUFFLENBQUMsSUFBRCxDQUpEO0FBS0xvRixTQUFLLEVBQUUsQ0FBQyxJQUFELENBTEY7QUFNTDFHLFFBQUksRUFBRSxDQUFDLElBQUQsRUFBTyxJQUFQLEVBQWEsSUFBYixFQUFtQixJQUFuQixFQUF5QixJQUF6QixFQUErQixJQUEvQixFQUFxQyxJQUFyQyxFQUEyQyxJQUEzQztBQU5EO0FBVHFCLENBQTlCOzs7QUNGQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Nyb0NoZXNzLy4vc3JjL3V0aWxzL2hlbHBlcnMudHM/MjhmMyIsIndlYnBhY2s6Ly9jcm9DaGVzcy8uL3NyYy9QaWVjZS50cz8yZWI4Iiwid2VicGFjazovL2Nyb0NoZXNzLy4vc3JjL3V0aWxzL21vdmVzLnRzPzUwZmIiLCJ3ZWJwYWNrOi8vY3JvQ2hlc3MvLi9zcmMvcmFua3NBbmRGaWxlcy50cz9lNjIxIiwid2VicGFjazovL2Nyb0NoZXNzLy4vc3JjL0dhbWVib2FyZC50cz81N2UzIiwid2VicGFjazovL2Nyb0NoZXNzLy4vc3JjL0hpc3RvcnkudHM/NGMyMSIsIndlYnBhY2s6Ly9jcm9DaGVzcy8uL3NyYy9zdGFydGluZ1Bvc2l0aW9ucy50cz8zYmJjIiwid2VicGFjazovL2Nyb0NoZXNzLy4vc3JjL21haW4udHM/Y2Q0OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb29yZCB9IGZyb20gJy4uL3R5cGVzL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgU3F1YXJlIH0gZnJvbSAnLi4vdHlwZXMvdHlwZXMnO1xuXG5mdW5jdGlvbiB0b1hZKHNxdWFyZTogU3F1YXJlKTogQ29vcmQge1xuICBjb25zdCBbeCwgeV0gPSBzcXVhcmUuc3BsaXQoJycpO1xuICByZXR1cm4ge1xuICAgIHg6IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJywgJ2YnLCAnZycsICdoJ10uaW5kZXhPZih4LnRvTG93ZXJDYXNlKCkpLFxuICAgIHk6IE51bWJlcih5KVxuICB9O1xufVxuXG5mdW5jdGlvbiBmcm9tWFkoY29vcmQ6IENvb3JkKTogU3F1YXJlIHtcbiAgY29uc3QgeyB4LCB5IH0gPSBjb29yZDtcbiAgY29uc3QgY29sID0gWydhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJywgJ2gnXVt4XTtcbiAgaWYgKCFjb2wpIHJldHVybiAnJztcbiAgcmV0dXJuIGNvbC5jb25jYXQoeS50b1N0cmluZygpKTtcbn1cblxuY29uc3QgY2FsY0Rpc3RhbmNlID0gKHNxdWFyZU9uZTogc3RyaW5nKSA9PiAoc3F1YXJlVHdvOiBzdHJpbmcpID0+IHtcbiAgY29uc3QgeyB4OiB4MSwgeTogeTEgfSA9IHRvWFkoc3F1YXJlT25lKTtcbiAgY29uc3QgeyB4OiB4MiwgeTogeTIgfSA9IHRvWFkoc3F1YXJlVHdvKTtcblxuICBjb25zdCB4RGlmZiA9IHgxIC0geDI7XG4gIGNvbnN0IHlEaWZmID0geTEgLSB5MjtcbiAgcmV0dXJuIHtcbiAgICB4RGlmZixcbiAgICB5RGlmZlxuICB9O1xufTtcblxuZXhwb3J0IHsgdG9YWSwgZnJvbVhZLCBjYWxjRGlzdGFuY2UgfTtcbiIsImltcG9ydCBtb3ZlcyBmcm9tICcuL3V0aWxzL21vdmVzJztcbmltcG9ydCB7IHRvWFksIGZyb21YWSB9IGZyb20gJy4vdXRpbHMvaGVscGVycyc7XG5cbmltcG9ydCB7IENvbG9yLCBTcXVhcmUsIFBpZWNlVHlwZSB9IGZyb20gJy4vdHlwZXMvdHlwZXMnO1xuXG5jb25zdCBQaWVjZSA9IChjb2xvcjogQ29sb3IsIHR5cGU6IFBpZWNlVHlwZSkgPT4ge1xuICBmdW5jdGlvbiBoYXNNb3ZlKGZyb206IFNxdWFyZSwgdG86IFNxdWFyZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAna2luZyc6IHtcbiAgICAgICAgY29uc3Qgb25lU3F1YXJlVmVydCA9XG4gICAgICAgICAgbW92ZXMueUJ5TigxKShmcm9tKSh0bykgJiYgbW92ZXMueEJ5TigwKShmcm9tKSh0byk7XG4gICAgICAgIGNvbnN0IG9uZVNxdWFyZUxhdGVyYWwgPVxuICAgICAgICAgIG1vdmVzLnhCeU4oMSkoZnJvbSkodG8pICYmIG1vdmVzLnlCeU4oMCkoZnJvbSkodG8pO1xuICAgICAgICBjb25zdCBvbmVTcXVhcmVEaWFnb25hbGx5ID1cbiAgICAgICAgICBtb3Zlcy55QnlOKDEpKGZyb20pKHRvKSAmJiBtb3Zlcy54QnlOKDEpKGZyb20pKHRvKTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGZyb20gIT09IHRvICYmXG4gICAgICAgICAgKG9uZVNxdWFyZURpYWdvbmFsbHkgfHwgb25lU3F1YXJlVmVydCB8fCBvbmVTcXVhcmVMYXRlcmFsKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2FzZSAncXVlZW4nOiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgZnJvbSAhPT0gdG8gJiZcbiAgICAgICAgICAobW92ZXMuZGlhZ29uYWwoZnJvbSkodG8pIHx8IG1vdmVzLnZlcnRBbmRMYXRlcmFsKGZyb20pKHRvKSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2Jpc2hvcCc6IHtcbiAgICAgICAgcmV0dXJuIGZyb20gIT09IHRvICYmIG1vdmVzLmRpYWdvbmFsKGZyb20pKHRvKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2tuaWdodCc6IHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBmcm9tICE9PSB0byAmJlxuICAgICAgICAgICgobW92ZXMueEJ5TigxKShmcm9tKSh0bykgJiYgbW92ZXMueUJ5TigyKShmcm9tKSh0bykpIHx8XG4gICAgICAgICAgICAobW92ZXMueEJ5TigyKShmcm9tKSh0bykgJiYgbW92ZXMueUJ5TigxKShmcm9tKSh0bykpKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2FzZSAncm9vayc6IHtcbiAgICAgICAgcmV0dXJuIGZyb20gIT09IHRvICYmIG1vdmVzLnZlcnRBbmRMYXRlcmFsKHRvKShmcm9tKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ3Bhd24nOiB7XG4gICAgICAgIGNvbnN0IHsgeDogeDEsIHk6IHkxIH0gPSB0b1hZKGZyb20pO1xuICAgICAgICBjb25zdCB7IHg6IHgyLCB5OiB5MiB9ID0gdG9YWSh0byk7XG5cbiAgICAgICAgY29uc3Qgb25seU1vdmVzSW5Gcm9udCA9IGNvbG9yID09PSAnd2hpdGUnID8geTEgPCB5MiA6IHkxID4geTI7XG4gICAgICAgIGNvbnN0IHJlZ3VsYXJNb3ZlID0gbW92ZXMueUJ5TigxKShmcm9tKSh0bykgJiYgeDEgPT09IHgyO1xuXG4gICAgICAgIGNvbnN0IGZpcnN0TW92ZSA9IGNvbG9yID09PSAnd2hpdGUnID8geTEgPT09IDIgOiB5MSA9PT0gNztcbiAgICAgICAgY29uc3QganVtcFR3byA9IG1vdmVzLnlCeU4oMikoZnJvbSkodG8pICYmIHgxID09PSB4MjtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGZyb20gIT09IHRvICYmXG4gICAgICAgICAgb25seU1vdmVzSW5Gcm9udCAmJlxuICAgICAgICAgIChyZWd1bGFyTW92ZSB8fCAoZmlyc3RNb3ZlICYmIGp1bXBUd28pKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFBhd25DYXB0dXJlcyhvcmlnaW46IFNxdWFyZSkge1xuICAgIGlmICh0eXBlICE9PSAncGF3bicpIHJldHVybjtcblxuICAgIGNvbnN0IHsgeCwgeSB9ID0gdG9YWShvcmlnaW4pO1xuXG4gICAgY29uc3QgbmV3WSA9IGNvbG9yID09PSAnd2hpdGUnID8geSArIDEgOiB5IC0gMTtcblxuICAgIGNvbnN0IGNhcHR1cmVPbmUgPSB7IHg6IHggKyAxLCB5OiBuZXdZIH07XG4gICAgY29uc3QgY2FwdHVyZVR3byA9IHsgeDogeCAtIDEsIHk6IG5ld1kgfTtcblxuICAgIHJldHVybiBbZnJvbVhZKGNhcHR1cmVPbmUpLCBmcm9tWFkoY2FwdHVyZVR3byldO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBoYXNNb3ZlLFxuICAgIGdldFBhd25DYXB0dXJlcyxcbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH0sXG4gICAgZ2V0IGNvbG9yKCkge1xuICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFBpZWNlO1xuIiwiaW1wb3J0IHsgY2FsY0Rpc3RhbmNlLCB0b1hZIH0gZnJvbSAnLi9oZWxwZXJzJztcbmltcG9ydCB7XG4gIFBpZWNlSW50ZXJmYWNlLFxuICBTcXVhcmVPYmosXG4gIFBpZWNlT2JqLFxuICBFblBhc3NhbnRPYmpcbn0gZnJvbSAnLi4vdHlwZXMvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBNb3ZlcywgQm9hcmQsIFNxdWFyZSwgQ29sb3IgfSBmcm9tICcuLi90eXBlcy90eXBlcyc7XG5pbXBvcnQgUGllY2UgZnJvbSAnLi4vUGllY2UnO1xuXG5jb25zdCBtb3ZlcyA9IHtcbiAgdmVydEFuZExhdGVyYWw6IChmcm9tOiBTcXVhcmUpID0+ICh0bzogU3F1YXJlKSA9PiB7XG4gICAgY29uc3QgW3gxLCB5MV0gPSBmcm9tLnNwbGl0KCcnKTtcbiAgICBjb25zdCBbeDIsIHkyXSA9IHRvLnNwbGl0KCcnKTtcbiAgICByZXR1cm4geDEgPT09IHgyIHx8IHkxID09PSB5MjtcbiAgfSxcbiAgZGlhZ29uYWw6IChmcm9tOiBTcXVhcmUpID0+ICh0bzogU3F1YXJlKSA9PiB7XG4gICAgY29uc3QgeyB4OiB4MSwgeTogeTEgfSA9IHRvWFkoZnJvbSk7XG4gICAgY29uc3QgeyB4OiB4MiwgeTogeTIgfSA9IHRvWFkodG8pO1xuICAgIHJldHVybiBNYXRoLmFicyh4MiAtIHgxKSA9PT0gTWF0aC5hYnMoeTIgLSB5MSk7XG4gIH0sXG4gIHhCeU46IChudW06IG51bWJlcikgPT4gKGZyb206IFNxdWFyZSkgPT4gKHRvOiBTcXVhcmUpID0+IHtcbiAgICBjb25zdCB7IHg6IHgxIH0gPSB0b1hZKGZyb20pO1xuICAgIGNvbnN0IHsgeDogeDIgfSA9IHRvWFkodG8pO1xuICAgIHJldHVybiBNYXRoLmFicyh4MSAtIHgyKSA9PT0gbnVtO1xuICB9LFxuICB5QnlOOiAobnVtOiBudW1iZXIpID0+IChmcm9tOiBTcXVhcmUpID0+ICh0bzogU3F1YXJlKSA9PiB7XG4gICAgY29uc3QgeyB5OiB5MSB9ID0gdG9YWShmcm9tKTtcbiAgICBjb25zdCB7IHk6IHkyIH0gPSB0b1hZKHRvKTtcbiAgICByZXR1cm4gTWF0aC5hYnMoeTEgLSB5MikgPT09IG51bTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgbW92ZXM7XG5cbi8qIGRlYWxpbmcgd2l0aCBtb3ZlIHZlY3RvcnMgKi9cblxuZnVuY3Rpb24gc3BsaXRJbnRvVmVjdG9ycyhhcnJheU9mTW92ZXM6IE1vdmVzLCBzdGFydDogU3F1YXJlKSB7XG4gIGludGVyZmFjZSBWZWN0b3JzIHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmdbXTtcbiAgfVxuICByZXR1cm4gYXJyYXlPZk1vdmVzLnJlZHVjZSgoYWNjOiBWZWN0b3JzLCBjdXJyOiBTcXVhcmUpID0+IHtcbiAgICBjb25zdCB7IHhEaWZmLCB5RGlmZiB9ID0gY2FsY0Rpc3RhbmNlKHN0YXJ0KShjdXJyKTtcblxuICAgIGxldCB2ZWN0b3IgPSAnJztcbiAgICBpZiAoeURpZmYgIT09IDApIHZlY3RvciA9IHlEaWZmIDwgMCA/ICd1cCcgOiAnZG93bic7XG4gICAgaWYgKHhEaWZmICE9PSAwKSB2ZWN0b3IgKz0geERpZmYgPCAwID8gJ1JpZ2h0JyA6ICdMZWZ0JztcblxuICAgIC8vIG5vcm1hbGl6ZSB2ZWN0b3IgbmFtZVxuICAgIHZlY3RvciA9IHZlY3Rvci5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIHZlY3Rvci5zbGljZSgxKTtcblxuICAgIGFjY1t2ZWN0b3JdID0gYWNjW3ZlY3Rvcl0gfHwgW107XG4gICAgYWNjW3ZlY3Rvcl0ucHVzaChjdXJyKTtcblxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gZ2V0QmVnaW5uaW5nT2ZWZWN0b3IodmVjdG9yOiBNb3Zlcykge1xuICBpZiAodmVjdG9yLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuXG4gIHJldHVybiB2ZWN0b3IucmVkdWNlKChhY2MsIGN1cnIpID0+IHtcbiAgICBjb25zdCB7IHg6IHgxLCB5OiB5MSB9ID0gdG9YWShhY2MpO1xuICAgIGNvbnN0IHsgeDogeDIsIHk6IHkyIH0gPSB0b1hZKGN1cnIpO1xuXG4gICAgY29uc3QgYWNjSXNCZWdpbm5pbmcgPSB4MSA9PT0geDIgPyB5MSA8IHkyIDogeDEgPCB4MjtcbiAgICByZXR1cm4gYWNjSXNCZWdpbm5pbmcgPyBhY2MgOiBjdXJyO1xuICB9KTtcbn1cblxuY29uc3QgZ2V0TW92ZXNBbG9uZ1ZlY3RvciA9IChcbiAgczE6IFNxdWFyZSxcbiAgczI6IFNxdWFyZSxcbiAgYWxsU3F1YXJlczogTW92ZXNcbik6IE1vdmVzID0+IHtcbiAgY29uc3QgbGllc1NhbWVWZXJ0T3JMYXQgPSBtb3Zlcy52ZXJ0QW5kTGF0ZXJhbChzMSkoczIpO1xuICBjb25zdCBsaWVzU2FtZURpYWdvbmFsbHkgPSBtb3Zlcy5kaWFnb25hbChzMSkoczIpO1xuXG4gIGNvbnN0IGxpZXNPblNhbWVMaW5lID0gbGllc1NhbWVWZXJ0T3JMYXQgfHwgbGllc1NhbWVEaWFnb25hbGx5O1xuICBpZiAoIWxpZXNPblNhbWVMaW5lKSByZXR1cm4gW107XG5cbiAgY29uc3QgbWF0Y2hpbmdWZWN0b3IgPSBsaWVzU2FtZURpYWdvbmFsbHkgPyAnZGlhZ29uYWwnIDogJ3ZlcnRBbmRMYXRlcmFsJztcblxuICBjb25zdCBzcXVhcmVzQWxvbmdWZWN0b3IgPSBhbGxTcXVhcmVzLmZpbHRlcihcbiAgICAocykgPT4gbW92ZXNbbWF0Y2hpbmdWZWN0b3JdKHMxKShzKSAmJiBtb3Zlc1ttYXRjaGluZ1ZlY3Rvcl0oczIpKHMpXG4gICk7XG4gIHJldHVybiBzcXVhcmVzQWxvbmdWZWN0b3I7XG59O1xuXG4vKiBzb3J0IG1vdmVzICovXG5cbmNvbnN0IHNvcnRNb3Zlc0Nsb3Nlc3RUbyA9XG4gIChzcXVhcmU6IFNxdWFyZSkgPT5cbiAgKG1vdmVzOiBNb3Zlcyk6IE1vdmVzID0+IHtcbiAgICByZXR1cm4gWy4uLm1vdmVzXS5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBjb25zdCB7IHhEaWZmOiB4MURpZmYsIHlEaWZmOiB5MURpZmYgfSA9IGNhbGNEaXN0YW5jZShzcXVhcmUpKGEpO1xuICAgICAgY29uc3QgYURpZmYgPSBNYXRoLmFicyh4MURpZmYpICsgTWF0aC5hYnMoeTFEaWZmKTtcblxuICAgICAgY29uc3QgeyB4RGlmZjogeDJEaWZmLCB5RGlmZjogeTJEaWZmIH0gPSBjYWxjRGlzdGFuY2Uoc3F1YXJlKShiKTtcbiAgICAgIGNvbnN0IGJEaWZmID0gTWF0aC5hYnMoeDJEaWZmKSArIE1hdGguYWJzKHkyRGlmZik7XG5cbiAgICAgIHJldHVybiBhRGlmZiAtIGJEaWZmO1xuICAgIH0pO1xuICB9O1xuXG4vKiBnZXQgbW92ZXMgKi9cblxuZnVuY3Rpb24gZ2V0UG9zc2libGVNb3ZlcyhvcmlnaW46IFNxdWFyZSwgYm9hcmQ6IEJvYXJkKSB7XG4gIC8vIGdldCBhbGwgbW92ZXMgdGhhdCBjYW4gaGFwcGVuIGlmIG5vIG90aGVyIHBpZWNlcyB3ZXJlIG9uIHRoZSBib2FyZFxuICBjb25zdCBhbGxTcXVhcmVzID0gQXJyYXkuZnJvbShib2FyZC5rZXlzKCkpO1xuXG4gIGNvbnN0IHNxdWFyZSA9IGJvYXJkLmdldChvcmlnaW4pIGFzIFNxdWFyZU9iajtcblxuICBjb25zdCB7IHR5cGUsIGNvbG9yIH0gPSBzcXVhcmUucGllY2UgYXMgUGllY2VPYmo7XG4gIGNvbnN0IHBpZWNlID0gUGllY2UoY29sb3IsIHR5cGUpO1xuXG4gIHJldHVybiBhbGxTcXVhcmVzLmZpbHRlcigocykgPT4gcGllY2UuaGFzTW92ZShvcmlnaW4sIHMpKTtcbn1cblxuZnVuY3Rpb24gZ2V0TGVnYWxNb3ZlcyhvcmlnaW46IFNxdWFyZSwgYm9hcmQ6IEJvYXJkKSB7XG4gIC8vIGdldCBtb3ZlcyByZWdhcmRsZXNzIG9mIHdoZXRoZXIgb3Igbm90IHRoZXJlIGlzIGNoZWNrXG5cbiAgY29uc3Qgc3F1YXJlID0gYm9hcmQuZ2V0KG9yaWdpbikgYXMgU3F1YXJlT2JqO1xuXG4gIGNvbnN0IHBpZWNlID0gc3F1YXJlLnBpZWNlIGFzIFBpZWNlT2JqO1xuXG4gIGNvbnN0IHBvc3NpYmxlTW92ZXMgPSBnZXRQb3NzaWJsZU1vdmVzKG9yaWdpbiwgYm9hcmQpO1xuXG4gIGNvbnN0IG9ic3RydWN0aW9ucyA9IHBvc3NpYmxlTW92ZXMuZmlsdGVyKChzKSA9PiBib2FyZC5nZXQocyk/LnBpZWNlKTtcbiAgaWYgKCFvYnN0cnVjdGlvbnMubGVuZ3RoKSB7XG4gICAgaWYgKHBpZWNlLnR5cGUgPT09ICdwYXduJylcbiAgICAgIHJldHVybiBbLi4uZ2V0UGF3bkNhcHR1cmVzKG9yaWdpbiwgYm9hcmQpLCAuLi5wb3NzaWJsZU1vdmVzXTtcbiAgICByZXR1cm4gcG9zc2libGVNb3ZlcztcbiAgfVxuXG4gIGxldCBsZWdhbE1vdmVzOiBNb3ZlcyA9IFtdO1xuICBzd2l0Y2ggKHBpZWNlLnR5cGUpIHtcbiAgICBjYXNlICdrbmlnaHQnOiB7XG4gICAgICBsZWdhbE1vdmVzID0gcG9zc2libGVNb3ZlcztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlICdwYXduJzoge1xuICAgICAgY29uc3QgY2FwdHVyZXNBdmFpbGFibGUgPSBnZXRQYXduQ2FwdHVyZXMob3JpZ2luLCBib2FyZCk7XG4gICAgICBjb25zdCB1bm9ic3RydWN0ZWRNb3ZlcyA9IHJlbW92ZU1vdmVzV2l0aFBpZWNlcyhcbiAgICAgICAgcmVtb3ZlT2JzdHJ1Y3RlZE1vdmVzKG9yaWdpbiwgcG9zc2libGVNb3Zlcywgb2JzdHJ1Y3Rpb25zKSxcbiAgICAgICAgYm9hcmRcbiAgICAgICk7XG4gICAgICBsZWdhbE1vdmVzID0gWy4uLmNhcHR1cmVzQXZhaWxhYmxlLCAuLi51bm9ic3RydWN0ZWRNb3Zlc107XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAna2luZyc6IHtcbiAgICAgIGxlZ2FsTW92ZXMgPSByZW1vdmVQcm90ZWN0ZWRTcXVhcmVzKHBpZWNlLCBwb3NzaWJsZU1vdmVzLCBib2FyZCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgbGVnYWxNb3ZlcyA9IHJlbW92ZU9ic3RydWN0ZWRNb3ZlcyhvcmlnaW4sIHBvc3NpYmxlTW92ZXMsIG9ic3RydWN0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlbW92ZU1vdmVzV2l0aFBpZWNlcyhsZWdhbE1vdmVzLCBib2FyZCwgcGllY2UuY29sb3IpO1xufVxuXG5mdW5jdGlvbiBnZXRMZWdhbE1vdmVzSW5DaGVjayhcbiAgb3JpZ2luOiBTcXVhcmUsXG4gIGJvYXJkOiBCb2FyZCxcbiAga2luZ1BvczogU3F1YXJlLFxuICBzcXVhcmVHaXZpbmdDaGVjazogU3F1YXJlXG4pIHtcbiAgY29uc3Qgc3F1YXJlc1RoYXREZWFsV2l0aENoZWNrID0gZ2V0U3F1YXJlc0JldHdlZW5LaW5nQW5kQ2hlY2soXG4gICAga2luZ1BvcyxcbiAgICBzcXVhcmVHaXZpbmdDaGVjayxcbiAgICBBcnJheS5mcm9tKGJvYXJkLmtleXMoKSlcbiAgKTtcblxuICBjb25zdCBtb3ZlcyA9IGdldExlZ2FsTW92ZXMob3JpZ2luLCBib2FyZCk7XG5cbiAgcmV0dXJuIG1vdmVzLmZpbHRlcigocykgPT4gc3F1YXJlc1RoYXREZWFsV2l0aENoZWNrLmluY2x1ZGVzKHMpKTtcbn1cblxuZnVuY3Rpb24gZ2V0QXR0YWNraW5nTW92ZXMob3JpZ2luOiBTcXVhcmUsIGJvYXJkOiBCb2FyZCkge1xuICAvLyBmb3Igd2hlbiB5b3UgbmVlZCB0byBjaGVjayBmb3IgaWYgc3F1YXJlcyBhcmUgcHJvdGVjdGVkXG4gIGNvbnN0IHNxdWFyZSA9IGJvYXJkLmdldChvcmlnaW4pIGFzIFNxdWFyZU9iajtcblxuICBjb25zdCB7IHR5cGUsIGNvbG9yIH0gPSBzcXVhcmUucGllY2UgYXMgUGllY2VPYmo7XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAncGF3bic6IHtcbiAgICAgIGNvbnN0IHBpZWNlID0gUGllY2UoY29sb3IsICdwYXduJyk7XG4gICAgICByZXR1cm4gcGllY2UuZ2V0UGF3bkNhcHR1cmVzKG9yaWdpbikgYXMgTW92ZXM7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZ2V0TGVnYWxNb3ZlcyhvcmlnaW4sIGJvYXJkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRBbGxNb3Zlc0ZvckNvbG9yKGNvbG9yOiBDb2xvciwgYm9hcmQ6IEJvYXJkKTogTW92ZXMge1xuICBjb25zdCBhbGxNb3ZlczogTW92ZXNbXSA9IFtdO1xuICBmb3IgKGNvbnN0IFtzcXVhcmUsIHsgcGllY2UgfV0gb2YgYm9hcmQuZW50cmllcygpKSB7XG4gICAgaWYgKCFwaWVjZSkgY29udGludWU7XG4gICAgaWYgKHBpZWNlLmNvbG9yICE9PSBjb2xvcikgY29udGludWU7XG5cbiAgICBhbGxNb3Zlcy5wdXNoKGdldExlZ2FsTW92ZXMoc3F1YXJlLCBib2FyZCkpO1xuICB9XG5cbiAgcmV0dXJuIGFsbE1vdmVzLmZsYXQoKTtcbn1cblxuZnVuY3Rpb24gZ2V0QXR0YWNraW5nTW92ZXNGb3JDb2xvcihjb2xvcjogQ29sb3IsIGJvYXJkOiBCb2FyZCk6IE1vdmVzIHtcbiAgY29uc3QgYWxsTW92ZXM6IE1vdmVzW10gPSBbXTtcbiAgZm9yIChjb25zdCBbc3F1YXJlLCB7IHBpZWNlIH1dIG9mIGJvYXJkLmVudHJpZXMoKSkge1xuICAgIGlmICghcGllY2UpIGNvbnRpbnVlO1xuICAgIGlmIChwaWVjZS5jb2xvciAhPT0gY29sb3IpIGNvbnRpbnVlO1xuXG4gICAgYWxsTW92ZXMucHVzaChnZXRBdHRhY2tpbmdNb3ZlcyhzcXVhcmUsIGJvYXJkKSk7XG4gIH1cblxuICByZXR1cm4gYWxsTW92ZXMuZmxhdCgpO1xufVxuXG5mdW5jdGlvbiBnZXRQYXduQ2FwdHVyZXMocGF3blNxdWFyZTogU3F1YXJlLCBib2FyZDogQm9hcmQpIHtcbiAgY29uc3QgeyBjb2xvciB9ID0gYm9hcmQuZ2V0KHBhd25TcXVhcmUpPy5waWVjZSBhcyBQaWVjZU9iajtcbiAgY29uc3QgcGF3biA9IFBpZWNlKGNvbG9yLCAncGF3bicpO1xuXG4gIGNvbnN0IGNhcHR1cmVNb3ZlcyA9IHBhd24uZ2V0UGF3bkNhcHR1cmVzKHBhd25TcXVhcmUpO1xuICBpZiAoIWNhcHR1cmVNb3ZlcykgcmV0dXJuIFtdO1xuXG4gIHJldHVybiBjYXB0dXJlTW92ZXMuZmlsdGVyKChzKSA9PiB7XG4gICAgY29uc3Qgc3F1YXJlVmFsID0gYm9hcmQuZ2V0KHMpO1xuICAgIGlmICghc3F1YXJlVmFsKSByZXR1cm4gZmFsc2U7XG5cbiAgICBjb25zdCBwaWVjZSA9IHNxdWFyZVZhbC5waWVjZTtcbiAgICBjb25zdCBlblBhc3NhbnQ6IEVuUGFzc2FudE9iaiB8IHVuZGVmaW5lZCA9IHNxdWFyZVZhbC5lblBhc3NhbnQ7XG5cbiAgICByZXR1cm4gKFxuICAgICAgKHBpZWNlICYmIHBpZWNlLmNvbG9yICE9PSBwYXduLmNvbG9yKSB8fFxuICAgICAgKGVuUGFzc2FudCAmJiBlblBhc3NhbnQuY29sb3IgIT09IHBhd24uY29sb3IpXG4gICAgKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFNxdWFyZXNCZXR3ZWVuS2luZ0FuZENoZWNrKFxuICBraW5nUG9zOiBTcXVhcmUsXG4gIGNoZWNrUG9zOiBTcXVhcmUsXG4gIGFsbFNxdWFyZXM6IE1vdmVzXG4pIHtcbiAgLy8gaW5jbHVkZXMga2luZ1BvcyBhbmQgY2hlY2tQb3NcbiAgY29uc3Qgc3F1YXJlc0Fsb25nVmVjdG9yID0gZ2V0TW92ZXNBbG9uZ1ZlY3RvcihraW5nUG9zLCBjaGVja1BvcywgYWxsU3F1YXJlcyk7XG4gIGNvbnN0IHNxdWFyZXNCZXR3ZWVuS2luZ0FuZFBpZWNlID0gcmVtb3ZlTW92ZXNCZWhpbmRUd29TcXVhcmVzKFxuICAgIGtpbmdQb3MsXG4gICAgY2hlY2tQb3MsXG4gICAgc3F1YXJlc0Fsb25nVmVjdG9yXG4gICk7XG4gIHJldHVybiBzcXVhcmVzQmV0d2VlbktpbmdBbmRQaWVjZTtcbn1cblxuLyogZmlsdGVyIG1vdmVzICovXG5cbmZ1bmN0aW9uIHJlbW92ZU1vdmVzQmVoaW5kVHdvU3F1YXJlcyhcbiAgczE6IFNxdWFyZSxcbiAgczI6IFNxdWFyZSxcbiAgdmVjdG9yOiBNb3Zlc1xuKTogTW92ZXMge1xuICBjb25zdCBzb3J0ZWQgPSBzb3J0TW92ZXNDbG9zZXN0VG8oZ2V0QmVnaW5uaW5nT2ZWZWN0b3IodmVjdG9yKSkodmVjdG9yKTtcbiAgbGV0IGZ1cnRoZXN0U3F1YXJlO1xuICBsZXQgY2xvc2VzdFNxdWFyZTtcblxuICBpZiAoc29ydGVkLmluZGV4T2YoczEpID4gc29ydGVkLmluZGV4T2YoczIpKSB7XG4gICAgZnVydGhlc3RTcXVhcmUgPSBzMTtcbiAgICBjbG9zZXN0U3F1YXJlID0gczI7XG4gIH0gZWxzZSB7XG4gICAgZnVydGhlc3RTcXVhcmUgPSBzMjtcbiAgICBjbG9zZXN0U3F1YXJlID0gczE7XG4gIH1cbiAgY29uc3QgcmVtb3ZlZE9uZUVuZCA9IHJlbW92ZU1vdmVzQmVoaW5kU3F1YXJlKGZ1cnRoZXN0U3F1YXJlKShzb3J0ZWQpO1xuICBjb25zdCByZW1vdmVkQm90aEVuZHMgPSByZW1vdmVNb3Zlc0JlaGluZFNxdWFyZShjbG9zZXN0U3F1YXJlKShcbiAgICByZW1vdmVkT25lRW5kLnJldmVyc2UoKVxuICApO1xuXG4gIHJldHVybiByZW1vdmVkQm90aEVuZHM7XG59XG5cbmNvbnN0IHJlbW92ZU1vdmVzQmVoaW5kU3F1YXJlID1cbiAgKHNxdWFyZTogU3F1YXJlKSA9PlxuICAobW92ZXM6IE1vdmVzKTogTW92ZXMgPT4ge1xuICAgIGNvbnN0IGNvcHkgPSBbLi4ubW92ZXNdO1xuICAgIGNvbnN0IGluZGV4ID0gbW92ZXMuaW5kZXhPZihzcXVhcmUpO1xuXG4gICAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIFtdO1xuXG4gICAgY29weS5zcGxpY2UoaW5kZXggKyAxKTtcblxuICAgIHJldHVybiBjb3B5O1xuICB9O1xuXG5mdW5jdGlvbiByZW1vdmVPYnN0cnVjdGVkTW92ZXMoXG4gIHN0YXJ0aW5nU3F1YXJlOiBTcXVhcmUsXG4gIHBvc3NpYmxlTW92ZXM6IE1vdmVzLFxuICBvYnN0cnVjdGlvbnM6IE1vdmVzXG4pOiBNb3ZlcyB7XG4gIC8vIGEpIHNwbGl0IHBvc3NpYmxlIG1vdmVzIGludG8gdmVjdG9ycyAodXAsZG93bixsZWZ0LHJpZ2h0LCBhbmQvb3IgZGlhZ29uYWxzKVxuICAvLyBiKSBzZWUgd2hpY2ggb2JzdHJ1Y3Rpb25zIGJlbG9uZyB0byB3aGljaCB2ZWN0b3JcbiAgLy8gYykgZmluZCB0aGUgY2xvc2VzdCBvYnN0cnVjdGlvblxuICAvLyBkKSByZW1vdmUgYWxsIHRoZSBtb3ZlcyBiZWhpbmQgdGhhdCBvYnN0cnVjdGlvblxuXG4gIGNvbnN0IGZpbHRlcmVkTW92ZXM6IE1vdmVzW10gPSBbXTtcblxuICBjb25zdCBhbGxWZWN0b3JzID0gc3BsaXRJbnRvVmVjdG9ycyhwb3NzaWJsZU1vdmVzLCBzdGFydGluZ1NxdWFyZSk7XG4gIGNvbnN0IG9ic3RydWN0aW9uVmVjdG9ycyA9IHNwbGl0SW50b1ZlY3RvcnMob2JzdHJ1Y3Rpb25zLCBzdGFydGluZ1NxdWFyZSk7XG4gIGZvciAoY29uc3QgdmVjdG9yIGluIGFsbFZlY3RvcnMpIHtcbiAgICBpZiAoIW9ic3RydWN0aW9uVmVjdG9yc1t2ZWN0b3JdKSB7XG4gICAgICAvLyBsb29rIGZvciB2ZWN0b3Igb2JzdHJ1Y3Rpb24gaXMgb25cbiAgICAgIGZpbHRlcmVkTW92ZXMucHVzaChhbGxWZWN0b3JzW3ZlY3Rvcl0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3Qgc29ydGVkID0gc29ydE1vdmVzQ2xvc2VzdFRvKHN0YXJ0aW5nU3F1YXJlKShhbGxWZWN0b3JzW3ZlY3Rvcl0pO1xuICAgIGNvbnN0IGNsb3Nlc3RPYnN0cnVjdGlvbiA9IHNvcnRNb3Zlc0Nsb3Nlc3RUbyhzdGFydGluZ1NxdWFyZSkoXG4gICAgICBvYnN0cnVjdGlvblZlY3RvcnNbdmVjdG9yXVxuICAgIClbMF07XG5cbiAgICBmaWx0ZXJlZE1vdmVzLnB1c2gocmVtb3ZlTW92ZXNCZWhpbmRTcXVhcmUoY2xvc2VzdE9ic3RydWN0aW9uKShzb3J0ZWQpKTtcbiAgfVxuXG4gIHJldHVybiBmaWx0ZXJlZE1vdmVzLmZsYXQoKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlUHJvdGVjdGVkU3F1YXJlcyhcbiAga2luZzogUGllY2VPYmosXG4gIHBvc3NpYmxlTW92ZXM6IE1vdmVzLFxuICBib2FyZDogQm9hcmRcbik6IE1vdmVzIHtcbiAgLy8gYmMga2luZyBjYW50IG1vdmUgaWYgc3F1YXJlIGlzIHByb3RlY3RlZFxuICBjb25zdCBvcHBDb2xvciA9IGtpbmcuY29sb3IgPT09ICd3aGl0ZScgPyAnYmxhY2snIDogJ3doaXRlJztcblxuICBjb25zdCBhbGxFbmVteU1vdmVzID0gZ2V0QXR0YWNraW5nTW92ZXNGb3JDb2xvcihvcHBDb2xvciwgYm9hcmQpO1xuICByZXR1cm4gcG9zc2libGVNb3Zlcy5maWx0ZXIoKHMpID0+IHtcbiAgICByZXR1cm4gIWFsbEVuZW15TW92ZXMuaW5jbHVkZXMocyk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZW1vdmVNb3Zlc1dpdGhQaWVjZXMoXG4gIG1vdmVzOiBNb3ZlcyxcbiAgYm9hcmQ6IEJvYXJkLFxuICBjb2xvcj86IENvbG9yXG4pOiBNb3ZlcyB7XG4gIHJldHVybiBtb3Zlcy5maWx0ZXIoKHMpID0+IHtcbiAgICBjb25zdCBzcXVhcmVWYWwgPSBib2FyZC5nZXQocyk7XG4gICAgaWYgKCFzcXVhcmVWYWwpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChjb2xvcikgcmV0dXJuICFzcXVhcmVWYWwucGllY2UgfHwgc3F1YXJlVmFsLnBpZWNlLmNvbG9yICE9PSBjb2xvcjtcbiAgICBlbHNlIHJldHVybiAhc3F1YXJlVmFsLnBpZWNlO1xuICB9KTtcbn1cblxuLyogZ2FtZWJvYXJkIGNoZWNrcyAqL1xuXG5mdW5jdGlvbiBnZXREaXNjb3ZlcmVkQ2hlY2soXG4gIGtpbmdQb3M6IFNxdWFyZSxcbiAga2luZ0NvbG9yOiBDb2xvcixcbiAgdmFjYXRlZDogU3F1YXJlLFxuICBib2FyZDogQm9hcmRcbik6IFNxdWFyZSB7XG4gIC8vIG9wZW5TcXVhcmUgaXMgYSBzcXVhcmUganVzdCB2YWNhdGVkXG4gIGxldCBzcXVhcmVzQWxvbmdWZWN0b3IgPSBnZXRNb3Zlc0Fsb25nVmVjdG9yKFxuICAgIGtpbmdQb3MsXG4gICAgdmFjYXRlZCxcbiAgICBBcnJheS5mcm9tKGJvYXJkLmtleXMoKSlcbiAgKTtcbiAgc3F1YXJlc0Fsb25nVmVjdG9yID0gc3F1YXJlc0Fsb25nVmVjdG9yLmZpbHRlcihcbiAgICAocykgPT4gcyAhPT0ga2luZ1BvcyAmJiBzICE9PSB2YWNhdGVkXG4gICk7XG4gIGlmICghc3F1YXJlc0Fsb25nVmVjdG9yLmxlbmd0aCkgcmV0dXJuICcnO1xuXG4gIGZvciAoY29uc3Qgc3F1YXJlIG9mIHNxdWFyZXNBbG9uZ1ZlY3Rvcikge1xuICAgIGNvbnN0IHBpZWNlID0gYm9hcmQuZ2V0KHNxdWFyZSk/LnBpZWNlO1xuICAgIGlmICghcGllY2UgfHwgcGllY2UuY29sb3IgPT09IGtpbmdDb2xvcikgY29udGludWU7XG5cbiAgICBjb25zdCBsZWdhbE1vdmVzID0gZ2V0TGVnYWxNb3ZlcyhzcXVhcmUsIGJvYXJkKTtcbiAgICBpZiAobGVnYWxNb3Zlcy5pbmNsdWRlcyhraW5nUG9zKSkgcmV0dXJuIHNxdWFyZTtcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gY2FuQmxvY2tPckNhcHR1cmVDaGVjayhcbiAga2luZ1BvczogU3F1YXJlLFxuICBzcXVhcmVHaXZpbmdDaGVjazogU3F1YXJlLFxuICBib2FyZDogQm9hcmRcbik6IGJvb2xlYW4ge1xuICBjb25zdCBraW5nID0gYm9hcmQuZ2V0KGtpbmdQb3MpPy5waWVjZSBhcyBQaWVjZU9iajtcblxuICBjb25zdCBibG9ja09yQ2FwdHVyZVNxdWFyZXMgPSBnZXRTcXVhcmVzQmV0d2VlbktpbmdBbmRDaGVjayhcbiAgICBraW5nUG9zLFxuICAgIHNxdWFyZUdpdmluZ0NoZWNrLFxuICAgIEFycmF5LmZyb20oYm9hcmQua2V5cygpKVxuICApOyAvLyBhbHNvIGluY2x1ZGVzIGNoZWNrIHNxdWFyZVxuXG4gIGNvbnN0IG93blBpZWNlTW92ZXMgPSBnZXRBbGxNb3Zlc0ZvckNvbG9yKGtpbmcuY29sb3IsIGJvYXJkKTtcbiAgcmV0dXJuIG93blBpZWNlTW92ZXMuc29tZSgobW92ZSkgPT4gYmxvY2tPckNhcHR1cmVTcXVhcmVzLmluY2x1ZGVzKG1vdmUpKTtcbn1cblxuZXhwb3J0IHtcbiAgZ2V0QXR0YWNraW5nTW92ZXNGb3JDb2xvcixcbiAgZ2V0TGVnYWxNb3ZlcyxcbiAgZ2V0TGVnYWxNb3Zlc0luQ2hlY2ssXG4gIGdldERpc2NvdmVyZWRDaGVjayxcbiAgY2FuQmxvY2tPckNhcHR1cmVDaGVja1xufTtcbiIsImNvbnN0IGZpbGVzID0gWydhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJywgJ2gnXTtcbmNvbnN0IHJhbmtzID0gWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDhdO1xuXG5leHBvcnQgeyBmaWxlcywgcmFua3MgfTtcbiIsImltcG9ydCB7XG4gIGdldExlZ2FsTW92ZXMsXG4gIGdldERpc2NvdmVyZWRDaGVjayxcbiAgY2FuQmxvY2tPckNhcHR1cmVDaGVjayxcbiAgZ2V0QXR0YWNraW5nTW92ZXNGb3JDb2xvcixcbiAgZ2V0TGVnYWxNb3Zlc0luQ2hlY2tcbn0gZnJvbSAnLi91dGlscy9tb3Zlcyc7XG5pbXBvcnQgeyB0b1hZLCBmcm9tWFkgfSBmcm9tICcuL3V0aWxzL2hlbHBlcnMnO1xuaW1wb3J0IHsgcmFua3MsIGZpbGVzIH0gZnJvbSAnLi9yYW5rc0FuZEZpbGVzJztcbmltcG9ydCB7IENvbG9yLCBTcXVhcmUsIEJvYXJkLCBQaWVjZVR5cGUsIE1vdmVzIH0gZnJvbSAnLi90eXBlcy90eXBlcyc7XG5pbXBvcnQge1xuICBBbGxQaWVjZU1hcCxcbiAgQ2FzdGxlT2JqLFxuICBHYW1lYm9hcmRPYmosXG4gIFBpZWNlTWFwLFxuICBQaWVjZU9ialxufSBmcm9tICcuL3R5cGVzL2ludGVyZmFjZXMnO1xuXG5mdW5jdGlvbiBjcmVhdGVCb2FyZCgpOiBCb2FyZCB7XG4gIHJldHVybiBmaWxlcy5yZWR1Y2UoKGFjYywgZmlsZSkgPT4ge1xuICAgIHJhbmtzLmZvckVhY2goKHJhbmspID0+IHtcbiAgICAgIGNvbnN0IHNxdWFyZSA9IGZpbGUuY29uY2F0KHJhbmsudG9TdHJpbmcoKSk7XG4gICAgICBhY2Muc2V0KHNxdWFyZSwgeyBwaWVjZTogbnVsbCB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCBuZXcgTWFwKCkpO1xufVxuXG5jb25zdCBHYW1lYm9hcmQgPSAoXG4gIGJvYXJkID0gY3JlYXRlQm9hcmQoKSxcbiAgc3F1YXJlc0dpdmluZ0NoZWNrPzogTW92ZXMsXG4gIENhc3RsZT86IENhc3RsZU9ialxuKTogR2FtZWJvYXJkT2JqID0+IHtcbiAgZnVuY3Rpb24gY2FuQ2FzdGxlKGNvbG9yOiBDb2xvciwgc2lkZTogJ2tpbmdzaWRlJyB8ICdxdWVlbnNpZGUnKTogYm9vbGVhbiB7XG4gICAgaWYgKENhc3RsZSAmJiAhQ2FzdGxlW2NvbG9yXVtzaWRlXSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gY2hlY2sgaWYgcm9vayBzdGlsbCBleGlzdHNcbiAgICBpZiAoIWNoZWNrSWZSb29rRXhpc3RzKCkpIHJldHVybiBmYWxzZTtcblxuICAgIGNvbnN0IG9wcENvbG9yID0gY29sb3IgPT09ICd3aGl0ZScgPyAnYmxhY2snIDogJ3doaXRlJztcbiAgICBjb25zdCBvcHBNb3ZlcyA9IGdldEF0dGFja2luZ01vdmVzRm9yQ29sb3Iob3BwQ29sb3IsIGJvYXJkKTtcblxuICAgIGNvbnN0IGNhc3RsZVNxdWFyZXMgPSBnZXQuY2FzdGxlU3F1YXJlcyhjb2xvcilbc2lkZV07XG4gICAgZm9yIChjb25zdCBzcXVhcmUgb2YgY2FzdGxlU3F1YXJlcykge1xuICAgICAgLy8gY2hlY2sgaWYgY2FzdGxlIHNxdWFyZSBpcyBjbGVhcmVkXG4gICAgICBpZiAoYXQoc3F1YXJlKS5waWVjZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gbWFrZSBzdXJlIGNhc3RsZSBzcXVhcmUgaXNudCBhdHRhY2tlZFxuICAgICAgaWYgKG9wcE1vdmVzLmluY2x1ZGVzKHNxdWFyZSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGZ1bmN0aW9uIGNoZWNrSWZSb29rRXhpc3RzKCk6IGJvb2xlYW4ge1xuICAgICAgbGV0IHJvb2tFeGlzdHMgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHJhbmsgPSBjb2xvciA9PT0gJ3doaXRlJyA/IDEgOiA4O1xuICAgICAgY29uc3QgbG9vcFN0YXJ0ID1cbiAgICAgICAgc2lkZSA9PT0gJ3F1ZWVuc2lkZScgPyBmaWxlcy5pbmRleE9mKCdhJykgOiBmaWxlcy5pbmRleE9mKCdkJyk7XG4gICAgICBjb25zdCBsb29wRW5kID1cbiAgICAgICAgc2lkZSA9PT0gJ3F1ZWVuc2lkZScgPyBmaWxlcy5pbmRleE9mKCdlJykgOiBmaWxlcy5pbmRleE9mKCdoJyk7XG4gICAgICBmb3IgKGxldCBpID0gbG9vcFN0YXJ0OyBpIDw9IGxvb3BFbmQ7IGkrKykge1xuICAgICAgICBjb25zdCBzcXVhcmUgPSBmaWxlc1tpXSArIHJhbms7XG5cbiAgICAgICAgY29uc3QgcGllY2UgPSBhdChzcXVhcmUpLnBpZWNlO1xuICAgICAgICBpZiAoIXBpZWNlKSBjb250aW51ZTtcblxuICAgICAgICBpZiAocGllY2UudHlwZSA9PT0gJ3Jvb2snKSByb29rRXhpc3RzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByb29rRXhpc3RzO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNhc3RsZShjb2xvcjogQ29sb3IsIHNpZGU6ICdraW5nc2lkZScgfCAncXVlZW5zaWRlJyk6IHZvaWQge1xuICAgIGNvbnN0IHJhbmsgPSBjb2xvciA9PT0gJ3doaXRlJyA/IDEgOiA4O1xuICAgIGNvbnN0IGNhc3RsZVNxdWFyZXMgPVxuICAgICAgc2lkZSA9PT0gJ2tpbmdzaWRlJyA/IFtgZiR7cmFua31gLCBgZyR7cmFua31gXSA6IFtgZCR7cmFua31gLCBgYyR7cmFua31gXTtcblxuICAgIGNvbnN0IGtpbmdQb3MgPSBnZXQua2luZ1Bvc2l0aW9uKGNvbG9yKSBhcyBTcXVhcmU7XG4gICAgY29uc3Qgcm9va1BvcyA9IGdldFJvb2tQb3MoKSBhcyBTcXVhcmU7XG5cbiAgICBmcm9tKHJvb2tQb3MpLnRvKGNhc3RsZVNxdWFyZXNbMF0pO1xuICAgIGZyb20oa2luZ1BvcykudG8oY2FzdGxlU3F1YXJlc1sxXSk7XG5cbiAgICBmdW5jdGlvbiBnZXRSb29rUG9zKCkge1xuICAgICAgY29uc3QgcGllY2VNYXAgPSBnZXQucGllY2VNYXAoKTtcbiAgICAgIGNvbnN0IHJvb2tQb3MgPSBwaWVjZU1hcFtjb2xvcl0ucm9vay5maW5kKChzcXVhcmUpID0+IHtcbiAgICAgICAgY29uc3QgZmlsZSA9IHNxdWFyZS5zcGxpdCgnJylbMF07XG4gICAgICAgIHJldHVybiBzaWRlID09PSAna2luZ3NpZGUnXG4gICAgICAgICAgPyBmaWxlcy5pbmRleE9mKGZpbGUpID4gM1xuICAgICAgICAgIDogZmlsZXMuaW5kZXhPZihmaWxlKSA8IDM7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHJvb2tQb3M7XG4gICAgfVxuICAgIC8vIG5lZWQgdG8gZ2V0IGtpbmcgcG9zaXRpb25cbiAgICAvLyBuZWVkIHRvIGdldCBjYXN0bGUgc3F1YXJlc1xuICAgIC8vIG5lZWQgdG8gZmluZCByb29rXG4gIH1cblxuICBjb25zdCBlblBhc3NhbnQgPSAoKCkgPT4ge1xuICAgIGZ1bmN0aW9uIGdldFNxdWFyZShjdXJyZW50OiBTcXVhcmUsIGNvbG9yOiBDb2xvcik6IFNxdWFyZSB7XG4gICAgICBjb25zdCB7IHgsIHkgfSA9IHRvWFkoY3VycmVudCk7XG4gICAgICBjb25zdCBuZXdZID0gY29sb3IgPT09ICd3aGl0ZScgPyB5IC0gMSA6IHkgKyAxO1xuICAgICAgcmV0dXJuIGZyb21YWSh7IHgsIHk6IG5ld1kgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNoZWNrVG9nZ2xlOiAoZnJvbTogU3F1YXJlLCB0bzogU3F1YXJlKTogYm9vbGVhbiA9PiB7XG4gICAgICAgIGNvbnN0IHsgeTogeTEgfSA9IHRvWFkoZnJvbSk7XG4gICAgICAgIGNvbnN0IHsgeTogeTIgfSA9IHRvWFkodG8pO1xuXG4gICAgICAgIHJldHVybiBNYXRoLmFicyh5MSAtIHkyKSA9PT0gMjtcbiAgICAgIH0sXG4gICAgICB0b2dnbGU6IChjdXJyZW50OiBTcXVhcmUsIGNvbG9yOiBDb2xvcik6IHZvaWQgPT4ge1xuICAgICAgICBjb25zdCBlblBhc3NhbnRTcXVhcmUgPSBnZXRTcXVhcmUoY3VycmVudCwgY29sb3IpO1xuICAgICAgICBhdChlblBhc3NhbnRTcXVhcmUpLnNldEVuUGFzc2FudChjb2xvciwgY3VycmVudCk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlOiAoKTogdm9pZCA9PiB7XG4gICAgICAgIGZvciAoY29uc3Qgc3F1YXJlT2JqIG9mIGJvYXJkLnZhbHVlcygpKSB7XG4gICAgICAgICAgaWYgKHNxdWFyZU9iai5lblBhc3NhbnQpIHJldHVybiAoc3F1YXJlT2JqLmVuUGFzc2FudCA9IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9KSgpO1xuXG4gIGNvbnN0IGF0ID0gKHNxdWFyZTogU3F1YXJlKSA9PiAoe1xuICAgIHBsYWNlOiAocGllY2U6IFBpZWNlT2JqKTogdm9pZCA9PiB7XG4gICAgICBpZiAoIWJvYXJkLmdldChzcXVhcmUpKSByZXR1cm47XG5cbiAgICAgIGJvYXJkLnNldChzcXVhcmUsIHsgcGllY2UgfSk7XG4gICAgfSxcbiAgICByZW1vdmU6ICgpOiB2b2lkID0+IHtcbiAgICAgIGlmICghYm9hcmQuZ2V0KHNxdWFyZSkpIHJldHVybjtcblxuICAgICAgYm9hcmQuc2V0KHNxdWFyZSwgeyBwaWVjZTogbnVsbCB9KTtcbiAgICB9LFxuICAgIHByb21vdGU6IChwaWVjZVR5cGU6IFBpZWNlVHlwZSk6IHZvaWQgPT4ge1xuICAgICAgY29uc3Qgc3F1YXJlVmFsID0gYm9hcmQuZ2V0KHNxdWFyZSk7XG4gICAgICBjb25zdCBwaWVjZSA9IHNxdWFyZVZhbD8ucGllY2U7XG4gICAgICBpZiAoIXBpZWNlKSByZXR1cm47XG5cbiAgICAgIGJvYXJkLnNldChzcXVhcmUsIHsgLi4uc3F1YXJlVmFsLCBwaWVjZTogeyAuLi5waWVjZSwgdHlwZTogcGllY2VUeXBlIH0gfSk7XG4gICAgfSxcbiAgICBzZXRFblBhc3NhbnQ6IChjb2xvcjogQ29sb3IsIGN1cnJlbnQ6IFNxdWFyZSk6IHZvaWQgPT4ge1xuICAgICAgaWYgKCFib2FyZC5nZXQoc3F1YXJlKSkgcmV0dXJuO1xuXG4gICAgICBib2FyZC5zZXQoc3F1YXJlLCB7XG4gICAgICAgIHBpZWNlOiBudWxsLFxuICAgICAgICBlblBhc3NhbnQ6IHtcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIGNvbG9yOiBjb2xvclxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGdldCBwaWVjZSgpIHtcbiAgICAgIHJldHVybiBib2FyZC5nZXQoc3F1YXJlKT8ucGllY2U7XG4gICAgfSxcbiAgICBnZXRMZWdhbE1vdmVzOiAoKTogTW92ZXMgPT4ge1xuICAgICAgc3F1YXJlc0dpdmluZ0NoZWNrID0gc3F1YXJlc0dpdmluZ0NoZWNrIHx8IFtdO1xuICAgICAgY29uc3QgeyB0eXBlLCBjb2xvciB9ID0gYXQoc3F1YXJlKS5waWVjZSBhcyBQaWVjZU9iajtcblxuICAgICAgc3dpdGNoIChzcXVhcmVzR2l2aW5nQ2hlY2subGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgIGlmICh0eXBlICE9PSAna2luZycpIHJldHVybiBbXTtcbiAgICAgICAgICByZXR1cm4gZ2V0TGVnYWxNb3ZlcyhzcXVhcmUsIGJvYXJkKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICByZXR1cm4gZ2V0TGVnYWxNb3Zlc0luQ2hlY2soXG4gICAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICAgICBib2FyZCxcbiAgICAgICAgICAgIGdldC5raW5nUG9zaXRpb24oY29sb3IpIGFzIFNxdWFyZSxcbiAgICAgICAgICAgIHNxdWFyZXNHaXZpbmdDaGVja1swXVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGlmICh0eXBlID09PSAna2luZycpIHtcbiAgICAgICAgICAgIGxldCBsZWdhbE1vdmVzID0gZ2V0TGVnYWxNb3ZlcyhzcXVhcmUsIGJvYXJkKTtcbiAgICAgICAgICAgIGlmIChjYW5DYXN0bGUoY29sb3IsICdraW5nc2lkZScpKVxuICAgICAgICAgICAgICBsZWdhbE1vdmVzID0gW1xuICAgICAgICAgICAgICAgIC4uLmxlZ2FsTW92ZXMsXG4gICAgICAgICAgICAgICAgLi4uZ2V0LmNhc3RsZVNxdWFyZXMoY29sb3IpLmtpbmdzaWRlXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgICBpZiAoY2FuQ2FzdGxlKGNvbG9yLCAncXVlZW5zaWRlJykpXG4gICAgICAgICAgICAgIGxlZ2FsTW92ZXMgPSBbXG4gICAgICAgICAgICAgICAgLi4ubGVnYWxNb3ZlcyxcbiAgICAgICAgICAgICAgICAuLi5nZXQuY2FzdGxlU3F1YXJlcyhjb2xvcikucXVlZW5zaWRlXG4gICAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIHJldHVybiBsZWdhbE1vdmVzO1xuICAgICAgICAgIH0gZWxzZSByZXR1cm4gZ2V0TGVnYWxNb3ZlcyhzcXVhcmUsIGJvYXJkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgZnJvbSA9IChzMTogU3F1YXJlKSA9PiAoe1xuICAgIHRvOiAoczI6IFNxdWFyZSk6IHZvaWQgPT4ge1xuICAgICAgY29uc3QgcGllY2UgPSBhdChzMSkucGllY2U7XG4gICAgICBpZiAoIXBpZWNlKSByZXR1cm47XG5cbiAgICAgIC8vIG1vdmUgcGllY2VcbiAgICAgIGF0KHMxKS5yZW1vdmUoKTtcbiAgICAgIGF0KHMyKS5wbGFjZShwaWVjZSk7XG4gICAgfVxuICB9KTtcblxuICBjb25zdCBnZXQgPSB7XG4gICAga2luZ1Bvc2l0aW9uOiAoY29sb3I6IENvbG9yKTogU3F1YXJlIHwgdW5kZWZpbmVkID0+IHtcbiAgICAgIGZvciAoY29uc3QgW3NxdWFyZSwgdmFsdWVdIG9mIGJvYXJkLmVudHJpZXMoKSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdmFsdWUucGllY2UgJiZcbiAgICAgICAgICB2YWx1ZS5waWVjZS50eXBlID09PSAna2luZycgJiZcbiAgICAgICAgICB2YWx1ZS5waWVjZS5jb2xvciA9PT0gY29sb3JcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiBzcXVhcmU7XG4gICAgICB9XG4gICAgfSxcbiAgICBwaWVjZU1hcDogKCk6IEFsbFBpZWNlTWFwID0+IHtcbiAgICAgIGNvbnN0IHBpZWNlTWFwID0geyB3aGl0ZToge30gYXMgUGllY2VNYXAsIGJsYWNrOiB7fSBhcyBQaWVjZU1hcCB9O1xuICAgICAgZm9yIChjb25zdCBbc3F1YXJlLCB2YWx1ZV0gb2YgYm9hcmQuZW50cmllcygpKSB7XG4gICAgICAgIGNvbnN0IHsgcGllY2UgfSA9IHZhbHVlO1xuICAgICAgICBpZiAoIXBpZWNlKSBjb250aW51ZTtcblxuICAgICAgICBjb25zdCB7IHR5cGUsIGNvbG9yIH0gPSBwaWVjZTtcbiAgICAgICAgcGllY2VNYXBbY29sb3JdW3R5cGVdID0gcGllY2VNYXBbY29sb3JdW3R5cGVdXG4gICAgICAgICAgPyBbLi4ucGllY2VNYXBbY29sb3JdW3R5cGVdLCBzcXVhcmVdXG4gICAgICAgICAgOiBbc3F1YXJlXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwaWVjZU1hcDtcbiAgICB9LFxuICAgIHNxdWFyZXNHaXZpbmdDaGVja0FmdGVyTW92ZTogKGZyb206IFNxdWFyZSwgZW5kOiBTcXVhcmUpOiBTcXVhcmVbXSA9PiB7XG4gICAgICBjb25zdCBzcXVhcmVzR2l2aW5nQ2hlY2s6IHN0cmluZ1tdID0gW107XG5cbiAgICAgIGNvbnN0IHBpZWNlID0gYm9hcmQuZ2V0KGVuZCk/LnBpZWNlIGFzIFBpZWNlT2JqO1xuICAgICAgY29uc3Qgb3BwQ29sb3IgPSBwaWVjZS5jb2xvciA9PT0gJ3doaXRlJyA/ICdibGFjaycgOiAnd2hpdGUnO1xuICAgICAgY29uc3Qga2luZ1Bvc2l0aW9uID0gZ2V0LmtpbmdQb3NpdGlvbihvcHBDb2xvcikgYXMgU3F1YXJlO1xuXG4gICAgICBjb25zdCBwaWVjZUhpdHNLaW5nID0gZ2V0TGVnYWxNb3ZlcyhlbmQsIGJvYXJkKS5pbmNsdWRlcyhraW5nUG9zaXRpb24pO1xuICAgICAgaWYgKHBpZWNlSGl0c0tpbmcpIHNxdWFyZXNHaXZpbmdDaGVjay5wdXNoKGVuZCk7XG5cbiAgICAgIGNvbnN0IGRpc2NvdmVyZWRDaGVjayA9IGdldERpc2NvdmVyZWRDaGVjayhcbiAgICAgICAga2luZ1Bvc2l0aW9uLFxuICAgICAgICBvcHBDb2xvcixcbiAgICAgICAgZnJvbSxcbiAgICAgICAgYm9hcmRcbiAgICAgICk7XG4gICAgICBpZiAoZGlzY292ZXJlZENoZWNrKSBzcXVhcmVzR2l2aW5nQ2hlY2sucHVzaChkaXNjb3ZlcmVkQ2hlY2spO1xuXG4gICAgICByZXR1cm4gc3F1YXJlc0dpdmluZ0NoZWNrO1xuICAgIH0sXG4gICAgaXNDaGVja21hdGU6IChjb2xvcjogQ29sb3IsIHNxdWFyZXNHaXZpbmdDaGVjazogc3RyaW5nW10pOiBib29sZWFuID0+IHtcbiAgICAgIGNvbnN0IGtpbmdQb3MgPSBnZXQua2luZ1Bvc2l0aW9uKGNvbG9yKSBhcyBTcXVhcmU7XG4gICAgICBjb25zdCBsZWdhbE1vdmVzID0gYXQoa2luZ1BvcykuZ2V0TGVnYWxNb3ZlcygpO1xuICAgICAgLy8gY2hlY2sgaWYgY2hlY2sgY2FuIGJlIGJsb2NrZWRcbiAgICAgIGlmIChzcXVhcmVzR2l2aW5nQ2hlY2subGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmIChjYW5CbG9ja09yQ2FwdHVyZUNoZWNrKGtpbmdQb3MsIHNxdWFyZXNHaXZpbmdDaGVja1swXSwgYm9hcmQpKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghbGVnYWxNb3ZlcyB8fCAhbGVnYWxNb3Zlcy5sZW5ndGgpIHJldHVybiB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgY2FzdGxlU3F1YXJlcyhjb2xvcjogQ29sb3IpIHtcbiAgICAgIGNvbnN0IHJhbmsgPSBjb2xvciA9PT0gJ3doaXRlJyA/IDEgOiA4O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2luZ3NpZGU6IFtgZiR7cmFua31gLCBgZyR7cmFua31gXSxcbiAgICAgICAgcXVlZW5zaWRlOiBbYGMke3Jhbmt9YCwgYGQke3Jhbmt9YF1cbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgY3JlYXRlQm9hcmQsXG4gICAgY2FzdGxlLFxuICAgIGNhbkNhc3RsZSxcbiAgICBlblBhc3NhbnQsXG4gICAgYXQsXG4gICAgZnJvbSxcbiAgICBnZXQsXG4gICAgZ2V0IGJvYXJkKCkge1xuICAgICAgcmV0dXJuIGJvYXJkO1xuICAgIH1cbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEdhbWVib2FyZDtcbiIsIi8vIHNob3VsZCBvdXRwdXQgaGlzdG9yeSBvYmplY3QgdGhhdCBob2xkcyBtb3ZlIGhpc3RvcnkgaW4gMmQgYXJyYXlcbi8vIGZvciBlYWNoIG1vdmUgbmVlZHMgdG8gYXR0YWNoIHBpZWNlIFR5cGUgdG8gYmVnaW5uaW5nIG9mIG1vdmUgaWYgbm90IHBhd25cbi8vIHNob3VsZCBmdXJ0aGVyIHNwZWNpZnkgc3F1YXJlIG9mIHBpZWNlIGlmLCBzYXkgYm90aCByb29rcywgY2FuIG1vdmUgdG8gc2FtZSBzcXVhcmVcblxuaW1wb3J0IHsgQWxsUGllY2VNYXAsIEhpc3RvcnlPYmosIFBpZWNlT2JqIH0gZnJvbSAnLi90eXBlcy9pbnRlcmZhY2VzJztcbmltcG9ydCB7IEJvYXJkLCBQaWVjZVR5cGUsIFNxdWFyZSB9IGZyb20gJy4vdHlwZXMvdHlwZXMnO1xuaW1wb3J0IHsgZ2V0TGVnYWxNb3ZlcyB9IGZyb20gJy4vdXRpbHMvbW92ZXMnO1xuXG50eXBlIEhpc3RvcnlUeXBlID0gU3F1YXJlW11bXTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSGlzdG9yeShcbiAgcHJldkhpc3Rvcnk6IEhpc3RvcnlUeXBlLFxuICBib2FyZDogQm9hcmQsXG4gIHBpZWNlTWFwOiBBbGxQaWVjZU1hcFxuKTogSGlzdG9yeU9iaiB7XG4gIGNvbnN0IGhpc3Rvcnk6IEhpc3RvcnlUeXBlID0gcHJldkhpc3RvcnkgfHwgW107XG5cbiAgY29uc3QgZ2V0ID0ge1xuICAgIHBpZWNlUHJlZml4OiAoZnJvbTogU3F1YXJlLCB0bzogU3F1YXJlKSA9PiB7XG4gICAgICBjb25zdCB7IHR5cGUsIGNvbG9yIH0gPSBib2FyZC5nZXQodG8pPy5waWVjZSBhcyBQaWVjZU9iajtcblxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ3Bhd24nOlxuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgY2FzZSAna25pZ2h0JzpcbiAgICAgICAgY2FzZSAncm9vayc6IHtcbiAgICAgICAgICBsZXQgcHJlZml4ID0gdHlwZSA9PT0gJ3Jvb2snID8gJ1InIDogJ04nO1xuICAgICAgICAgIGlmIChwaWVjZU1hcFtjb2xvcl1bdHlwZV0ubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICAvLyBsb29rIGZvciBwaWVjZSBvZiBzYW1lIHR5cGUgdGhhdCBjb3VsZHZlIGFsc28gd2VudCB0byB0aGUgc3F1YXJlXG4gICAgICAgICAgICBwaWVjZU1hcFtjb2xvcl1bdHlwZV0uZm9yRWFjaCgocykgPT4ge1xuICAgICAgICAgICAgICBpZiAocyA9PT0gdG8pIHJldHVybjtcblxuICAgICAgICAgICAgICBjb25zdCBib2FyZENvcHkgPSBuZXcgTWFwKGJvYXJkKTtcbiAgICAgICAgICAgICAgYm9hcmRDb3B5LnNldCh0bywgeyBwaWVjZTogbnVsbCB9KTtcblxuICAgICAgICAgICAgICBpZiAoZ2V0TGVnYWxNb3ZlcyhzLCBib2FyZENvcHkpLmluY2x1ZGVzKHRvKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFt4MSwgeTFdID0gZnJvbS5zcGxpdCgnJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgW3gyXSA9IHMuc3BsaXQoJycpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNhbWVGaWxlID0geDEgPT09IHgyO1xuXG4gICAgICAgICAgICAgICAgcHJlZml4ID0gc2FtZUZpbGUgPyBwcmVmaXggKyB5MSA6IHByZWZpeCArIHgxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcHJlZml4O1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBjb25zdCBwcmVmaXggPSB0eXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgIHJldHVybiBwcmVmaXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNhc3RsZU5vdGF0aW9uOiAoc2lkZTogJ2tpbmdzaWRlJyB8ICdxdWVlbnNpZGUnKSA9PiB7XG4gICAgICByZXR1cm4gc2lkZSA9PT0gJ2tpbmdzaWRlJyA/ICdPLU8nIDogJ08tTy1PJztcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgYWZmaXggPSB7XG4gICAgY2FwdHVyZTogKG1vdmU6IFNxdWFyZSwgcHJlZml4OiBzdHJpbmcpID0+IHtcbiAgICAgIHJldHVybiBgJHtwcmVmaXh9eCR7bW92ZX1gO1xuICAgIH0sXG4gICAgcHJvbW90ZTogKG1vdmU6IFNxdWFyZSwgcGllY2VUeXBlOiBQaWVjZVR5cGUpID0+IHtcbiAgICAgIGNvbnN0IHN1ZmZpeCA9XG4gICAgICAgIHBpZWNlVHlwZSA9PT0gJ2tuaWdodCcgPyAnTicgOiBwaWVjZVR5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgIHJldHVybiBgJHttb3ZlfT0ke3N1ZmZpeH1gO1xuICAgIH0sXG4gICAgY2hlY2s6IChub3RhdGlvbjogc3RyaW5nKSA9PiB7XG4gICAgICByZXR1cm4gYCR7bm90YXRpb259K2A7XG4gICAgfSxcbiAgICBjaGVja21hdGU6IChub3RhdGlvbjogc3RyaW5nKSA9PiB7XG4gICAgICByZXR1cm4gYCR7bm90YXRpb259I2A7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgZ2V0LFxuICAgIGFmZml4LFxuICAgIGluc2VydE1vdmU6IChub3RhdGlvbjogc3RyaW5nKSA9PiB7XG4gICAgICBjb25zdCBsYXN0TW92ZVBhaXIgPSBoaXN0b3J5W2hpc3RvcnkubGVuZ3RoIC0gMV07XG4gICAgICBpZiAobGFzdE1vdmVQYWlyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBsYXN0TW92ZVBhaXIucHVzaChub3RhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBuZXdNb3ZlUGFpciA9IFtub3RhdGlvbl07XG4gICAgICAgIGhpc3RvcnkucHVzaChuZXdNb3ZlUGFpcik7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuIiwiaW1wb3J0IHsgQWxsUGllY2VNYXAgfSBmcm9tICcuL3R5cGVzL2ludGVyZmFjZXMnO1xuXG5jb25zdCBzdGFuZGFyZDogQWxsUGllY2VNYXAgPSB7XG4gIHdoaXRlOiB7XG4gICAgcm9vazogWydhMScsICdoMSddLFxuICAgIGtuaWdodDogWydnMScsICdiMSddLFxuICAgIGJpc2hvcDogWydmMScsICdjMSddLFxuICAgIGtpbmc6IFsnZTEnXSxcbiAgICBxdWVlbjogWydkMSddLFxuICAgIHBhd246IFsnYTInLCAnYjInLCAnYzInLCAnZDInLCAnZTInLCAnZjInLCAnZzInLCAnaDInXVxuICB9LFxuICBibGFjazoge1xuICAgIHJvb2s6IFsnYTgnLCAnaDgnXSxcbiAgICBrbmlnaHQ6IFsnZzgnLCAnYjgnXSxcbiAgICBiaXNob3A6IFsnZjgnLCAnYzgnXSxcbiAgICBraW5nOiBbJ2U4J10sXG4gICAgcXVlZW46IFsnZDgnXSxcbiAgICBwYXduOiBbJ2E3JywgJ2I3JywgJ2M3JywgJ2Q3JywgJ2U3JywgJ2Y3JywgJ2c3JywgJ2g3J11cbiAgfVxufTtcblxuZXhwb3J0IHsgc3RhbmRhcmQgfTtcbiIsImltcG9ydCBHYW1lYm9hcmQgZnJvbSAnLi9HYW1lYm9hcmQnO1xuaW1wb3J0IEhpc3RvcnkgZnJvbSAnLi9IaXN0b3J5JztcbmltcG9ydCAqIGFzIHN0YXJ0aW5nUG9zaXRpb25zIGZyb20gJy4vc3RhcnRpbmdQb3NpdGlvbnMnO1xuaW1wb3J0IHsgcmFua3MsIGZpbGVzIH0gZnJvbSAnLi9yYW5rc0FuZEZpbGVzJztcblxuZXhwb3J0IHsgR2FtZWJvYXJkLCBIaXN0b3J5LCBzdGFydGluZ1Bvc2l0aW9ucywgcmFua3MsIGZpbGVzIH07XG4iXSwibmFtZXMiOlsidG9YWSIsInNxdWFyZSIsIngiLCJ5Iiwic3BsaXQiLCJpbmRleE9mIiwidG9Mb3dlckNhc2UiLCJOdW1iZXIiLCJmcm9tWFkiLCJjb29yZCIsImNvbCIsImNvbmNhdCIsInRvU3RyaW5nIiwiY2FsY0Rpc3RhbmNlIiwic3F1YXJlT25lIiwic3F1YXJlVHdvIiwieDEiLCJ5MSIsIngyIiwieTIiLCJ4RGlmZiIsInlEaWZmIiwibW92ZXMiLCJQaWVjZSIsImNvbG9yIiwidHlwZSIsImhhc01vdmUiLCJmcm9tIiwidG8iLCJvbmVTcXVhcmVWZXJ0IiwieUJ5TiIsInhCeU4iLCJvbmVTcXVhcmVMYXRlcmFsIiwib25lU3F1YXJlRGlhZ29uYWxseSIsImRpYWdvbmFsIiwidmVydEFuZExhdGVyYWwiLCJvbmx5TW92ZXNJbkZyb250IiwicmVndWxhck1vdmUiLCJmaXJzdE1vdmUiLCJqdW1wVHdvIiwiZ2V0UGF3bkNhcHR1cmVzIiwib3JpZ2luIiwibmV3WSIsImNhcHR1cmVPbmUiLCJjYXB0dXJlVHdvIiwiTWF0aCIsImFicyIsIm51bSIsInNwbGl0SW50b1ZlY3RvcnMiLCJhcnJheU9mTW92ZXMiLCJzdGFydCIsInJlZHVjZSIsImFjYyIsImN1cnIiLCJ2ZWN0b3IiLCJjaGFyQXQiLCJzbGljZSIsInB1c2giLCJnZXRCZWdpbm5pbmdPZlZlY3RvciIsImxlbmd0aCIsImFjY0lzQmVnaW5uaW5nIiwiZ2V0TW92ZXNBbG9uZ1ZlY3RvciIsInMxIiwiczIiLCJhbGxTcXVhcmVzIiwibGllc1NhbWVWZXJ0T3JMYXQiLCJsaWVzU2FtZURpYWdvbmFsbHkiLCJsaWVzT25TYW1lTGluZSIsIm1hdGNoaW5nVmVjdG9yIiwic3F1YXJlc0Fsb25nVmVjdG9yIiwiZmlsdGVyIiwicyIsInNvcnRNb3Zlc0Nsb3Nlc3RUbyIsInNvcnQiLCJhIiwiYiIsIngxRGlmZiIsInkxRGlmZiIsImFEaWZmIiwieDJEaWZmIiwieTJEaWZmIiwiYkRpZmYiLCJnZXRQb3NzaWJsZU1vdmVzIiwiYm9hcmQiLCJBcnJheSIsImtleXMiLCJnZXQiLCJwaWVjZSIsImdldExlZ2FsTW92ZXMiLCJwb3NzaWJsZU1vdmVzIiwib2JzdHJ1Y3Rpb25zIiwiX2EiLCJsZWdhbE1vdmVzIiwiY2FwdHVyZXNBdmFpbGFibGUiLCJ1bm9ic3RydWN0ZWRNb3ZlcyIsInJlbW92ZU1vdmVzV2l0aFBpZWNlcyIsInJlbW92ZU9ic3RydWN0ZWRNb3ZlcyIsInJlbW92ZVByb3RlY3RlZFNxdWFyZXMiLCJnZXRMZWdhbE1vdmVzSW5DaGVjayIsImtpbmdQb3MiLCJzcXVhcmVHaXZpbmdDaGVjayIsInNxdWFyZXNUaGF0RGVhbFdpdGhDaGVjayIsImdldFNxdWFyZXNCZXR3ZWVuS2luZ0FuZENoZWNrIiwiaW5jbHVkZXMiLCJnZXRBdHRhY2tpbmdNb3ZlcyIsImdldEFsbE1vdmVzRm9yQ29sb3IiLCJhbGxNb3ZlcyIsImVudHJpZXMiLCJmbGF0IiwiZ2V0QXR0YWNraW5nTW92ZXNGb3JDb2xvciIsInBhd25TcXVhcmUiLCJwYXduIiwiY2FwdHVyZU1vdmVzIiwic3F1YXJlVmFsIiwiZW5QYXNzYW50IiwiY2hlY2tQb3MiLCJzcXVhcmVzQmV0d2VlbktpbmdBbmRQaWVjZSIsInJlbW92ZU1vdmVzQmVoaW5kVHdvU3F1YXJlcyIsInNvcnRlZCIsImZ1cnRoZXN0U3F1YXJlIiwiY2xvc2VzdFNxdWFyZSIsInJlbW92ZWRPbmVFbmQiLCJyZW1vdmVNb3Zlc0JlaGluZFNxdWFyZSIsInJlbW92ZWRCb3RoRW5kcyIsInJldmVyc2UiLCJjb3B5IiwiaW5kZXgiLCJzcGxpY2UiLCJzdGFydGluZ1NxdWFyZSIsImZpbHRlcmVkTW92ZXMiLCJhbGxWZWN0b3JzIiwib2JzdHJ1Y3Rpb25WZWN0b3JzIiwiY2xvc2VzdE9ic3RydWN0aW9uIiwia2luZyIsIm9wcENvbG9yIiwiYWxsRW5lbXlNb3ZlcyIsImdldERpc2NvdmVyZWRDaGVjayIsImtpbmdDb2xvciIsInZhY2F0ZWQiLCJjYW5CbG9ja09yQ2FwdHVyZUNoZWNrIiwiYmxvY2tPckNhcHR1cmVTcXVhcmVzIiwib3duUGllY2VNb3ZlcyIsInNvbWUiLCJtb3ZlIiwiZmlsZXMiLCJyYW5rcyIsImNyZWF0ZUJvYXJkIiwiZmlsZSIsImZvckVhY2giLCJyYW5rIiwic2V0IiwiTWFwIiwiR2FtZWJvYXJkIiwic3F1YXJlc0dpdmluZ0NoZWNrIiwiQ2FzdGxlIiwiY2FuQ2FzdGxlIiwic2lkZSIsImNoZWNrSWZSb29rRXhpc3RzIiwib3BwTW92ZXMiLCJjYXN0bGVTcXVhcmVzIiwiYXQiLCJyb29rRXhpc3RzIiwibG9vcFN0YXJ0IiwibG9vcEVuZCIsImkiLCJjYXN0bGUiLCJraW5nUG9zaXRpb24iLCJyb29rUG9zIiwiZ2V0Um9va1BvcyIsInBpZWNlTWFwIiwicm9vayIsImZpbmQiLCJnZXRTcXVhcmUiLCJjdXJyZW50IiwiY2hlY2tUb2dnbGUiLCJ0b2dnbGUiLCJlblBhc3NhbnRTcXVhcmUiLCJzZXRFblBhc3NhbnQiLCJyZW1vdmUiLCJzcXVhcmVPYmoiLCJ2YWx1ZXMiLCJ1bmRlZmluZWQiLCJwbGFjZSIsInByb21vdGUiLCJwaWVjZVR5cGUiLCJPYmplY3QiLCJraW5nc2lkZSIsInF1ZWVuc2lkZSIsInZhbHVlIiwid2hpdGUiLCJibGFjayIsInNxdWFyZXNHaXZpbmdDaGVja0FmdGVyTW92ZSIsImVuZCIsInBpZWNlSGl0c0tpbmciLCJkaXNjb3ZlcmVkQ2hlY2siLCJpc0NoZWNrbWF0ZSIsIkhpc3RvcnkiLCJwcmV2SGlzdG9yeSIsImhpc3RvcnkiLCJwaWVjZVByZWZpeCIsInByZWZpeCIsImJvYXJkQ29weSIsInNhbWVGaWxlIiwidG9VcHBlckNhc2UiLCJjYXN0bGVOb3RhdGlvbiIsImFmZml4IiwiY2FwdHVyZSIsInN1ZmZpeCIsImNoZWNrIiwibm90YXRpb24iLCJjaGVja21hdGUiLCJpbnNlcnRNb3ZlIiwibGFzdE1vdmVQYWlyIiwibmV3TW92ZVBhaXIiLCJzdGFuZGFyZCIsImtuaWdodCIsImJpc2hvcCIsInF1ZWVuIiwic3RhcnRpbmdQb3NpdGlvbnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///127\n")}},__webpack_require__={d:(Q,F)=>{for(var B in F)__webpack_require__.o(F,B)&&!__webpack_require__.o(Q,B)&&Object.defineProperty(Q,B,{enumerable:!0,get:F[B]})},o:(Q,F)=>Object.prototype.hasOwnProperty.call(Q,F),r:Q=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})}},__webpack_exports__={};return __webpack_modules__[127](0,__webpack_exports__,__webpack_require__),__webpack_exports__})()}));