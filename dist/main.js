!function(Q,F){"object"==typeof exports&&"object"==typeof module?module.exports=F():"function"==typeof define&&define.amd?define([],F):"object"==typeof exports?exports.croChess=F():Q.croChess=F()}(this,(()=>(()=>{"use strict";var __webpack_modules__={327:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"Castle\": () => (/* reexport */ Castle),\n  \"Gameboard\": () => (/* reexport */ src_Gameboard),\n  \"History\": () => (/* reexport */ History),\n  \"files\": () => (/* reexport */ files),\n  \"ranks\": () => (/* reexport */ ranks),\n  \"startingPositions\": () => (/* reexport */ startingPositions_namespaceObject)\n});\n\n// NAMESPACE OBJECT: ./src/startingPositions.ts\nvar startingPositions_namespaceObject = {};\n__webpack_require__.r(startingPositions_namespaceObject);\n__webpack_require__.d(startingPositions_namespaceObject, {\n  \"standard\": () => (standard)\n});\n\n;// CONCATENATED MODULE: ./src/utils/helpers.ts\nfunction toXY(square) {\n  const [x, y] = square.split('');\n  return {\n    x: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'].indexOf(x.toLowerCase()),\n    y: Number(y)\n  };\n}\nfunction fromXY(coord) {\n  const {\n    x,\n    y\n  } = coord;\n  const col = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'][x];\n  if (!col) return '';\n  return col.concat(y.toString());\n}\nconst calcDistance = squareOne => squareTwo => {\n  const {\n    x: x1,\n    y: y1\n  } = toXY(squareOne);\n  const {\n    x: x2,\n    y: y2\n  } = toXY(squareTwo);\n  const xDiff = x1 - x2;\n  const yDiff = y1 - y2;\n  return {\n    xDiff,\n    yDiff\n  };\n};\nfunction getPieceFromAbbr(abbr) {\n  switch (abbr) {\n    case 'K':\n      return 'king';\n\n    case 'Q':\n      return 'queen';\n\n    case 'N':\n      return 'knight';\n\n    case 'B':\n      return 'bishop';\n\n    case 'R':\n      return 'rook';\n  }\n}\nfunction parseNotation(notation) {\n  const move = {};\n  const replaced = notation.replace(/[+x#]/, '');\n\n  if (+replaced[0] === 0) {\n    // this is castle\n    move.castle = replaced.length === 3 ? 'kingside' : 'queenside';\n    return move;\n  }\n\n  if (replaced[0].toUpperCase() === replaced[0]) {\n    // this is piece move\n    move.pieceType = getPieceFromAbbr(replaced[0]);\n    move.to = replaced.slice(-2);\n\n    switch (replaced.length) {\n      case 4:\n        move.from = replaced[1];\n        break;\n\n      case 5:\n        move.from = replaced.slice(1, 3);\n        break;\n    }\n\n    return move;\n  } else {\n    // is a pawn move\n    move.pieceType = 'pawn';\n\n    if (replaced.includes('=')) {\n      // indicates promotion\n      move.promote = getPieceFromAbbr(replaced.slice(-1));\n    }\n\n    const promoteNoteIndex = replaced.indexOf('=');\n    const noPromoteNotation = replaced.slice(0, promoteNoteIndex === -1 ? replaced.length : promoteNoteIndex);\n\n    if (noPromoteNotation.length === 3) {\n      move.from = replaced[0];\n    }\n\n    move.to = noPromoteNotation.slice(-2);\n  }\n\n  return move;\n}\nfunction deepCopy2dArray(arr) {\n  return arr.map(n => [...n]);\n}\n;// CONCATENATED MODULE: ./src/Piece.ts\n\n\n\nconst Piece = (color, type) => {\n  function hasMove(from, to) {\n    switch (type) {\n      case 'king':\n        {\n          const oneSquareVert = utils_moves.yByN(1)(from)(to) && utils_moves.xByN(0)(from)(to);\n          const oneSquareLateral = utils_moves.xByN(1)(from)(to) && utils_moves.yByN(0)(from)(to);\n          const oneSquareDiagonally = utils_moves.yByN(1)(from)(to) && utils_moves.xByN(1)(from)(to);\n          return from !== to && (oneSquareDiagonally || oneSquareVert || oneSquareLateral);\n        }\n\n      case 'queen':\n        {\n          return from !== to && (utils_moves.diagonal(from)(to) || utils_moves.vertAndLateral(from)(to));\n        }\n\n      case 'bishop':\n        {\n          return from !== to && utils_moves.diagonal(from)(to);\n        }\n\n      case 'knight':\n        {\n          return from !== to && (utils_moves.xByN(1)(from)(to) && utils_moves.yByN(2)(from)(to) || utils_moves.xByN(2)(from)(to) && utils_moves.yByN(1)(from)(to));\n        }\n\n      case 'rook':\n        {\n          return from !== to && utils_moves.vertAndLateral(to)(from);\n        }\n\n      case 'pawn':\n        {\n          const {\n            x: x1,\n            y: y1\n          } = toXY(from);\n          const {\n            x: x2,\n            y: y2\n          } = toXY(to);\n          const onlyMovesInFront = color === 'white' ? y1 < y2 : y1 > y2;\n          const regularMove = utils_moves.yByN(1)(from)(to) && x1 === x2;\n          const firstMove = color === 'white' ? y1 === 2 : y1 === 7;\n          const jumpTwo = utils_moves.yByN(2)(from)(to) && x1 === x2;\n          return from !== to && onlyMovesInFront && (regularMove || firstMove && jumpTwo);\n        }\n    }\n  }\n\n  function getPawnCaptures(origin) {\n    if (type !== 'pawn') return;\n    const {\n      x,\n      y\n    } = toXY(origin);\n    const newY = color === 'white' ? y + 1 : y - 1;\n    const captureOne = {\n      x: x + 1,\n      y: newY\n    };\n    const captureTwo = {\n      x: x - 1,\n      y: newY\n    };\n    return [fromXY(captureOne), fromXY(captureTwo)];\n  }\n\n  return {\n    hasMove,\n    getPawnCaptures,\n\n    get type() {\n      return type;\n    },\n\n    get color() {\n      return color;\n    }\n\n  };\n};\n\n/* harmony default export */ const src_Piece = (Piece);\n;// CONCATENATED MODULE: ./src/utils/moves.ts\n\n\nconst moves = {\n  vertAndLateral: from => to => {\n    const [x1, y1] = from.split('');\n    const [x2, y2] = to.split('');\n    return x1 === x2 || y1 === y2;\n  },\n  diagonal: from => to => {\n    const {\n      x: x1,\n      y: y1\n    } = toXY(from);\n    const {\n      x: x2,\n      y: y2\n    } = toXY(to);\n    return Math.abs(x2 - x1) === Math.abs(y2 - y1);\n  },\n  xByN: num => from => to => {\n    const {\n      x: x1\n    } = toXY(from);\n    const {\n      x: x2\n    } = toXY(to);\n    return Math.abs(x1 - x2) === num;\n  },\n  yByN: num => from => to => {\n    const {\n      y: y1\n    } = toXY(from);\n    const {\n      y: y2\n    } = toXY(to);\n    return Math.abs(y1 - y2) === num;\n  }\n};\n/* harmony default export */ const utils_moves = (moves);\n/* dealing with move vectors */\n\nfunction splitIntoVectors(arrayOfMoves, start) {\n  return arrayOfMoves.reduce((acc, curr) => {\n    const {\n      xDiff,\n      yDiff\n    } = calcDistance(start)(curr);\n    let vector = '';\n    if (yDiff !== 0) vector = yDiff < 0 ? 'up' : 'down';\n    if (xDiff !== 0) vector += xDiff < 0 ? 'Right' : 'Left'; // normalize vector name\n\n    vector = vector.charAt(0).toLowerCase() + vector.slice(1);\n    acc[vector] = acc[vector] || [];\n    acc[vector].push(curr);\n    return acc;\n  }, {});\n}\n\nfunction getBeginningOfVector(vector) {\n  if (vector.length === 0) return '';\n  return vector.reduce((acc, curr) => {\n    const {\n      x: x1,\n      y: y1\n    } = toXY(acc);\n    const {\n      x: x2,\n      y: y2\n    } = toXY(curr);\n    const accIsBeginning = x1 === x2 ? y1 < y2 : x1 < x2;\n    return accIsBeginning ? acc : curr;\n  });\n}\n\nconst getMovesAlongVector = (s1, s2, allSquares) => {\n  const liesSameVertOrLat = moves.vertAndLateral(s1)(s2);\n  const liesSameDiagonally = moves.diagonal(s1)(s2);\n  const liesOnSameLine = liesSameVertOrLat || liesSameDiagonally;\n  if (!liesOnSameLine) return [];\n  const matchingVector = liesSameDiagonally ? 'diagonal' : 'vertAndLateral';\n  const squaresAlongVector = allSquares.filter(s => moves[matchingVector](s1)(s) && moves[matchingVector](s2)(s));\n  return squaresAlongVector;\n};\n/* sort moves */\n\n\nconst sortMovesClosestTo = square => moves => {\n  return [...moves].sort((a, b) => {\n    const {\n      xDiff: x1Diff,\n      yDiff: y1Diff\n    } = calcDistance(square)(a);\n    const aDiff = Math.abs(x1Diff) + Math.abs(y1Diff);\n    const {\n      xDiff: x2Diff,\n      yDiff: y2Diff\n    } = calcDistance(square)(b);\n    const bDiff = Math.abs(x2Diff) + Math.abs(y2Diff);\n    return aDiff - bDiff;\n  });\n};\n/* get moves */\n\n\nfunction getPossibleMoves(origin, board) {\n  // get all moves that can happen if no other pieces were on the board\n  const allSquares = Array.from(board.keys());\n  const square = board.get(origin);\n  const {\n    type,\n    color\n  } = square.piece;\n  const piece = src_Piece(color, type);\n  return allSquares.filter(s => piece.hasMove(origin, s));\n}\n\nfunction getLegalMoves(origin, board) {\n  // get moves regardless of whether or not there is check\n  const square = board.get(origin);\n  const piece = square.piece;\n  const possibleMoves = getPossibleMoves(origin, board);\n  const obstructions = possibleMoves.filter(s => {\n    var _a;\n\n    return (_a = board.get(s)) === null || _a === void 0 ? void 0 : _a.piece;\n  });\n\n  if (!obstructions.length) {\n    if (piece.type === 'pawn') return [...getPawnCaptures(origin, board), ...possibleMoves];\n    return possibleMoves;\n  }\n\n  let legalMoves = [];\n\n  switch (piece.type) {\n    case 'knight':\n      {\n        legalMoves = possibleMoves;\n        break;\n      }\n\n    case 'pawn':\n      {\n        const capturesAvailable = getPawnCaptures(origin, board);\n        const unobstructedMoves = removeMovesWithPieces(removeObstructedMoves(origin, possibleMoves, obstructions), board);\n        legalMoves = [...capturesAvailable, ...unobstructedMoves];\n        break;\n      }\n\n    case 'king':\n      {\n        legalMoves = removeProtectedSquares(origin, possibleMoves, board);\n        break;\n      }\n\n    default:\n      {\n        legalMoves = removeObstructedMoves(origin, possibleMoves, obstructions);\n      }\n  }\n\n  return removeMovesWithPieces(legalMoves, board, piece.color);\n}\n\nfunction getLegalMovesInCheck(origin, board, kingPos, squareGivingCheck) {\n  const squaresThatDealWithCheck = getSquaresBetweenKingAndCheck(kingPos, squareGivingCheck, Array.from(board.keys()));\n  const moves = getLegalMoves(origin, board);\n  return moves.filter(s => squaresThatDealWithCheck.includes(s));\n}\n\nfunction getAttackingMoves(origin, board) {\n  const square = board.get(origin);\n  const {\n    type,\n    color\n  } = square.piece;\n\n  switch (type) {\n    case 'pawn':\n      {\n        const piece = src_Piece(color, 'pawn');\n        return piece.getPawnCaptures(origin);\n      }\n\n    case 'king':\n      {\n        // need to do this because getLegalMoves will recursively call removeProtectedSquares otherwise\n        const attackingMoves = removeMovesWithPieces(getPossibleMoves(origin, board), board, color);\n        return attackingMoves;\n      }\n\n    default:\n      return getLegalMoves(origin, board);\n  }\n}\n\nfunction getAllMovesForColor(color, board, skipKing) {\n  const allMoves = [];\n\n  for (const [square, {\n    piece\n  }] of board.entries()) {\n    if (!piece) continue;\n    if (piece.color !== color) continue;\n    if (skipKing && piece.type === 'king') continue;\n    allMoves.push(getLegalMoves(square, board));\n  }\n\n  return allMoves.flat();\n}\n\nfunction getAttackingMovesForColor(color, board) {\n  const allMoves = [];\n\n  for (const [square, {\n    piece\n  }] of board.entries()) {\n    if (!piece) continue;\n    if (piece.color !== color) continue;\n    allMoves.push(getAttackingMoves(square, board));\n  }\n\n  return allMoves.flat();\n}\n\nfunction getPawnCaptures(pawnSquare, board) {\n  var _a;\n\n  const {\n    color\n  } = (_a = board.get(pawnSquare)) === null || _a === void 0 ? void 0 : _a.piece;\n  const pawn = src_Piece(color, 'pawn');\n  const captureMoves = pawn.getPawnCaptures(pawnSquare);\n  if (!captureMoves) return [];\n  return captureMoves.filter(s => {\n    const squareVal = board.get(s);\n    if (!squareVal) return false;\n    const piece = squareVal.piece;\n    const enPassant = squareVal.enPassant;\n    return piece && piece.color !== pawn.color || enPassant && enPassant.color !== pawn.color;\n  });\n}\n\nfunction getSquaresBetweenKingAndCheck(kingPos, checkPos, allSquares) {\n  // includes kingPos and checkPos\n  const squaresAlongVector = getMovesAlongVector(kingPos, checkPos, allSquares);\n  const squaresBetweenKingAndPiece = removeMovesBehindTwoSquares(kingPos, checkPos, squaresAlongVector);\n  return squaresBetweenKingAndPiece;\n}\n/* filter moves */\n\n\nfunction removeMovesBehindTwoSquares(s1, s2, vector) {\n  const sorted = sortMovesClosestTo(getBeginningOfVector(vector))(vector);\n  let furthestSquare;\n  let closestSquare;\n\n  if (sorted.indexOf(s1) > sorted.indexOf(s2)) {\n    furthestSquare = s1;\n    closestSquare = s2;\n  } else {\n    furthestSquare = s2;\n    closestSquare = s1;\n  }\n\n  const removedOneEnd = removeMovesBehindSquare(furthestSquare)(sorted);\n  const removedBothEnds = removeMovesBehindSquare(closestSquare)(removedOneEnd.reverse());\n  return removedBothEnds;\n}\n\nconst removeMovesBehindSquare = square => moves => {\n  const copy = [...moves];\n  const index = moves.indexOf(square);\n  if (index === -1) return [];\n  copy.splice(index + 1);\n  return copy;\n};\n\nfunction removeObstructedMoves(startingSquare, possibleMoves, obstructions) {\n  // a) split possible moves into vectors (up,down,left,right, and/or diagonals)\n  // b) see which obstructions belong to which vector\n  // c) find the closest obstruction\n  // d) remove all the moves behind that obstruction\n  const filteredMoves = [];\n  const allVectors = splitIntoVectors(possibleMoves, startingSquare);\n  const obstructionVectors = splitIntoVectors(obstructions, startingSquare);\n\n  for (const vector in allVectors) {\n    if (!obstructionVectors[vector]) {\n      // look for vector obstruction is on\n      filteredMoves.push(allVectors[vector]);\n      continue;\n    }\n\n    const sorted = sortMovesClosestTo(startingSquare)(allVectors[vector]);\n    const closestObstruction = sortMovesClosestTo(startingSquare)(obstructionVectors[vector])[0];\n    filteredMoves.push(removeMovesBehindSquare(closestObstruction)(sorted));\n  }\n\n  return filteredMoves.flat();\n}\n\nfunction removeProtectedSquares(kingPos, possibleMoves, board) {\n  var _a;\n\n  const king = (_a = board.get(kingPos)) === null || _a === void 0 ? void 0 : _a.piece;\n  const oppColor = king.color === 'white' ? 'black' : 'white'; // bc king cant move if square is protected\n  // set king piece on each square in possible moves to find which squares are protected\n\n  const boardCopy = new Map(board);\n  possibleMoves.forEach(s => boardCopy.set(s, {\n    piece: king\n  }));\n  const allEnemyMoves = getAttackingMovesForColor(oppColor, boardCopy);\n  return possibleMoves.filter(s => {\n    return !allEnemyMoves.includes(s);\n  });\n}\n\nfunction removeMovesWithPieces(moves, board, color) {\n  return moves.filter(s => {\n    const squareVal = board.get(s);\n    if (!squareVal) return false;\n    if (color) return !squareVal.piece || squareVal.piece.color !== color;else return !squareVal.piece;\n  });\n}\n/* gameboard checks */\n\n\nfunction getDiscoveredCheck(kingPos, kingColor, vacated, board) {\n  var _a; // openSquare is a square just vacated\n\n\n  let squaresAlongVector = getMovesAlongVector(kingPos, vacated, Array.from(board.keys()));\n  squaresAlongVector = squaresAlongVector.filter(s => s !== kingPos && s !== vacated);\n  if (!squaresAlongVector.length) return '';\n\n  for (const square of squaresAlongVector) {\n    const piece = (_a = board.get(square)) === null || _a === void 0 ? void 0 : _a.piece;\n    if (!piece || piece.color === kingColor) continue;\n    const legalMoves = getLegalMoves(square, board);\n    if (legalMoves.includes(kingPos)) return square;\n  }\n\n  return '';\n}\n\nfunction canBlockOrCaptureCheck(kingPos, squareGivingCheck, board) {\n  var _a;\n\n  const king = (_a = board.get(kingPos)) === null || _a === void 0 ? void 0 : _a.piece;\n  const blockOrCaptureSquares = getSquaresBetweenKingAndCheck(kingPos, squareGivingCheck, Array.from(board.keys())); // also includes check square\n\n  const ownPieceMoves = getAllMovesForColor(king.color, board, true);\n  return ownPieceMoves.some(move => blockOrCaptureSquares.includes(move));\n}\n\nfunction getPiecesWithMove(board, move, pieceType, color) {\n  const pieceSquares = [];\n\n  for (const [square, {\n    piece\n  }] of board.entries()) {\n    if (!piece) continue;\n    if (piece.color !== color) continue;\n    if (piece.type !== pieceType) continue;\n  }\n}\n\n\n;// CONCATENATED MODULE: ./src/ranksAndFiles.ts\nconst files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];\nconst ranks = [1, 2, 3, 4, 5, 6, 7, 8];\n\n;// CONCATENATED MODULE: ./src/Castle.ts\nfunction Castle(whiteKingside, whiteQueenside, blackKingside, blackQueenside) {\n  return {\n    white: {\n      kingside: whiteKingside,\n      queenside: whiteQueenside\n    },\n    black: {\n      kingside: blackKingside,\n      queenside: blackQueenside\n    }\n  };\n}\n;// CONCATENATED MODULE: ./src/moveNotation.ts\nconst moveNotation = notation => {\n  function castle(side) {\n    notation = side === 'kingside' ? '0-0' : '0-0-0';\n    return notation;\n  }\n\n  const affix = {\n    pieceNotation: (pieceType, differentiation) => {\n      differentiation = differentiation || '';\n\n      switch (pieceType) {\n        case 'pawn':\n          {\n            notation = differentiation + notation;\n            return notation;\n          }\n\n        case 'king':\n          {\n            notation = 'K' + notation;\n            return notation;\n          }\n\n        case 'knight':\n          {\n            notation = 'N' + differentiation + notation;\n            return notation;\n          }\n\n        default:\n          {\n            notation = pieceType[0].toUpperCase() + differentiation + notation;\n            return notation;\n          }\n      }\n    },\n    capture: () => {\n      notation = `x${notation}`;\n      return notation;\n    },\n    promote: pieceType => {\n      const suffix = '=' + pieceType === 'knight' ? 'N' : pieceType.charAt(0).toUpperCase();\n      notation += '=' + suffix;\n      return notation;\n    },\n    check: () => {\n      notation += '+';\n      return notation;\n    },\n    checkmate: () => {\n      notation += '#';\n      return notation;\n    }\n  };\n\n  function get(moveDetails) {\n    const {\n      capture,\n      castle: castleSide,\n      promote,\n      check,\n      checkmate,\n      pieceType,\n      differentiation\n    } = moveDetails;\n    if (castleSide) return castle(castleSide);\n    if (capture) affix.capture();\n    affix.pieceNotation(pieceType, differentiation);\n    if (promote) affix.promote(promote);\n    if (checkmate) affix.checkmate();else if (check) affix.check();\n    return notation;\n  }\n\n  return {\n    get\n  };\n};\n\n/* harmony default export */ const src_moveNotation = (moveNotation);\n;// CONCATENATED MODULE: ./src/Gameboard.ts\n\n\n\n\n\n\n\n\nfunction createBoard() {\n  return files.reduce((acc, file) => {\n    ranks.forEach(rank => {\n      const square = file.concat(rank.toString());\n      acc.set(square, {\n        piece: null\n      });\n    });\n    return acc;\n  }, new Map());\n}\n\nconst Gameboard = (board = createBoard(), squaresGivingCheck, CastleRights) => {\n  board = new Map(board);\n\n  function placePieces(pieceMap, boardMap = board) {\n    let color;\n\n    for (color in pieceMap) {\n      const map = pieceMap[color];\n      let pieceType;\n\n      for (pieceType in map) {\n        const squares = map[pieceType];\n        squares.forEach(s => at(s, boardMap).place({\n          type: pieceType,\n          color: color\n        }));\n      }\n    }\n  }\n\n  function makeMove(s1, s2, promote) {\n    const piece = at(s1).piece; // validate move\n\n    if (!piece) return;\n    if (!validate.move(s1, s2)) return;\n    if (promote && !validate.promotion(s1, s2)) return;\n\n    switch (piece.type) {\n      case 'pawn':\n        {\n          if (promote) {\n            at(s1).promote(promote);\n          }\n\n          if (enPassant.isCapture(s1, s2)) {\n            enPassant.capture(s2);\n          }\n\n          enPassant.remove();\n\n          if (enPassant.checkToggle(s1, s2)) {\n            enPassant.toggle(piece.color, s2);\n          }\n\n          from(s1).to(s2);\n          break;\n        }\n\n      case 'king':\n        {\n          // check if move is castle\n          const castleSide = get.castleSide(piece.color, s2);\n          if (castleSide) castle(piece.color, castleSide);else from(s1).to(s2);\n          enPassant.remove();\n          break;\n        }\n\n      default:\n        from(s1).to(s2);\n        enPassant.remove();\n    }\n\n    return board;\n  }\n\n  function castle(color, side, boardMap = board) {\n    const castleSquares = get.castleSquares(color)[side];\n    const kingPos = get.kingPosition(color, boardMap);\n    const rookPos = getRookPos();\n    from(rookPos, boardMap).to(castleSquares[0]);\n    from(kingPos, boardMap).to(castleSquares[1]);\n\n    function getRookPos() {\n      const pieceMap = get.pieceMap(boardMap);\n      const rookPos = pieceMap[color].rook.find(square => {\n        const file = square.split('')[0];\n        return side === 'kingside' ? files.indexOf(file) > 3 : files.indexOf(file) < 3;\n      });\n      return rookPos;\n    } // need to get king position\n    // need to get castle squares\n    // need to find rook\n\n  }\n\n  const enPassant = (() => {\n    function getSquare(current, color) {\n      const {\n        x,\n        y\n      } = toXY(current);\n      const newY = color === 'white' ? y - 1 : y + 1;\n      return fromXY({\n        x,\n        y: newY\n      });\n    }\n\n    return {\n      checkToggle: (from, to) => {\n        const {\n          y: y1\n        } = toXY(from);\n        const {\n          y: y2\n        } = toXY(to);\n        return Math.abs(y1 - y2) === 2;\n      },\n      toggle: (color, current, boardMap = board) => {\n        const enPassantSquare = getSquare(current, color);\n        at(enPassantSquare, boardMap).setEnPassant(color, current);\n      },\n      remove: (boardMap = board) => {\n        for (const squareObj of boardMap.values()) {\n          if (squareObj.enPassant) return squareObj.enPassant = undefined;\n        }\n      },\n      isCapture: (from, to, boardMap = board) => {\n        var _a;\n\n        const piece = at(from, boardMap).piece;\n        const enPassant = (_a = boardMap.get(to)) === null || _a === void 0 ? void 0 : _a.enPassant;\n        if (!piece || piece.type !== 'pawn') return false;\n        if (!enPassant) return false;\n        if (enPassant.color === piece.color) return false;\n        return true;\n      },\n      capture: (to, boardMap = board) => {\n        var _a;\n\n        const enPassant = (_a = boardMap.get(to)) === null || _a === void 0 ? void 0 : _a.enPassant;\n        at(enPassant.current, boardMap).remove();\n      }\n    };\n  })();\n\n  const at = (square, boardMap = board) => ({\n    place: piece => {\n      if (!boardMap.get(square)) return;\n      boardMap.set(square, {\n        piece\n      });\n    },\n    remove: () => {\n      if (!boardMap.get(square)) return;\n      boardMap.set(square, {\n        piece: null\n      });\n    },\n    promote: pieceType => {\n      const squareVal = boardMap.get(square);\n      const piece = squareVal === null || squareVal === void 0 ? void 0 : squareVal.piece;\n      if (!piece) return;\n      boardMap.set(square, Object.assign(Object.assign({}, squareVal), {\n        piece: Object.assign(Object.assign({}, piece), {\n          type: pieceType\n        })\n      }));\n    },\n    setEnPassant: (color, current) => {\n      if (!boardMap.get(square)) return;\n      boardMap.set(square, {\n        piece: null,\n        enPassant: {\n          current\n          /* square pawn is on */\n          ,\n          color\n        }\n      });\n    },\n\n    get piece() {\n      var _a;\n\n      return (_a = boardMap.get(square)) === null || _a === void 0 ? void 0 : _a.piece;\n    },\n\n    getLegalMoves: (checks = squaresGivingCheck || []) => {\n      const {\n        type,\n        color\n      } = at(square, boardMap).piece;\n\n      switch (checks.length) {\n        case 2:\n          {\n            if (type !== 'king') return [];\n            return getLegalMoves(square, boardMap);\n          }\n\n        case 1:\n          {\n            return getLegalMovesInCheck(origin, boardMap, get.kingPosition(color), checks[0]);\n          }\n\n        default:\n          {\n            if (type === 'king') {\n              let legalMoves = getLegalMoves(square, boardMap);\n              if (get.canCastle(color, 'kingside')) legalMoves = [...legalMoves, ...get.castleSquares(color).kingside];\n              if (get.canCastle(color, 'queenside')) legalMoves = [...legalMoves, ...get.castleSquares(color).queenside];\n              return legalMoves;\n            } else return getLegalMoves(square, boardMap);\n          }\n      }\n    }\n  });\n\n  const from = (s1, boardMap = board) => ({\n    to: s2 => {\n      const piece = at(s1, boardMap).piece;\n      if (!piece) return; // move piece\n\n      at(s1, boardMap).remove();\n      at(s2, boardMap).place(piece);\n    }\n  });\n\n  const get = {\n    kingPosition: (color, boardMap = board) => {\n      for (const [square, value] of boardMap.entries()) {\n        if (value.piece && value.piece.type === 'king' && value.piece.color === color) return square;\n      }\n    },\n    pieceMap: (boardMap = board) => {\n      const pieceMap = {\n        white: {},\n        black: {}\n      };\n\n      for (const [square, value] of boardMap.entries()) {\n        const {\n          piece\n        } = value;\n        if (!piece) continue;\n        const {\n          type,\n          color\n        } = piece;\n        pieceMap[color][type] = pieceMap[color][type] ? [...pieceMap[color][type], square] : [square];\n      }\n\n      return pieceMap;\n    },\n    piecesThatHitSquare: (color, pieceType, square, boardMap = board) => {\n      const pieceMap = get.pieceMap(boardMap);\n      if (pieceMap[color][pieceType].includes(square)) return [];\n      const pieces = [];\n      if (pieceMap[color][pieceType].length <= 1) return [];\n      pieceMap[color][pieceType].forEach(s => {\n        if (at(s, boardMap).getLegalMoves().includes(square)) pieces.push(s);\n      });\n      return pieces;\n    },\n    squaresGivingCheckAfterMove: (from, end) => {\n      var _a;\n\n      const squaresGivingCheck = [];\n      const piece = (_a = board.get(end)) === null || _a === void 0 ? void 0 : _a.piece;\n      const oppColor = piece.color === 'white' ? 'black' : 'white';\n      const kingPosition = get.kingPosition(oppColor);\n      const pieceHitsKing = getLegalMoves(end, board).includes(kingPosition);\n      if (pieceHitsKing) squaresGivingCheck.push(end);\n      const discoveredCheck = getDiscoveredCheck(kingPosition, oppColor, from, board);\n      if (discoveredCheck) squaresGivingCheck.push(discoveredCheck);\n      return squaresGivingCheck;\n    },\n    isCheckmate: (colorOfKing, squaresGivingCheck, boardMap = board) => {\n      const kingPos = get.kingPosition(colorOfKing, boardMap);\n      const legalMoves = at(kingPos, boardMap).getLegalMoves(); // check if check can be blocked\n\n      if (squaresGivingCheck.length === 1) {\n        if (canBlockOrCaptureCheck(kingPos, squaresGivingCheck[0], boardMap)) return false;\n      }\n\n      if (legalMoves.length) return false;\n      return true;\n    },\n\n    castleSquares(color) {\n      const rank = color === 'white' ? 1 : 8;\n      return {\n        kingside: [`f${rank}`, `g${rank}`],\n        queenside: [`d${rank}`, `c${rank}`]\n      };\n    },\n\n    castleSide(color, to) {\n      let castleSide = '';\n      const castleSquares = get.castleSquares(color);\n\n      for (const [side, squares] of Object.entries(castleSquares)) {\n        if (squares[1] === to) castleSide = side;\n      }\n\n      return castleSide;\n    },\n\n    castleRightsAfterMove: (square, boardMap = board) => {\n      const piece = at(square, boardMap).piece;\n      const castleRights = CastleRights || Castle(true, true, true, true);\n\n      if (castleRights[piece.color].kingside || castleRights[piece.color].queenside) {\n        // check if i need to change castling rights\n        if (piece.type === 'king') {\n          castleRights[piece.color].kingside = false;\n          castleRights[piece.color].queenside = false;\n        }\n\n        if (piece.type === 'rook') {\n          // need to find if it is kingside or queenside rook\n          const [file] = square.split('');\n          const kingside = files.indexOf(file) > 3;\n          if (kingside) castleRights[piece.color].kingside = false;else castleRights[piece.color].queenside = false;\n        }\n      }\n\n      return castleRights;\n    },\n    canCastle: (color, side, boardMap = board) => {\n      if (CastleRights && !CastleRights[color][side]) return false; // check if rook still exists\n\n      if (!checkIfRookExists()) return false;\n      const oppColor = color === 'white' ? 'black' : 'white';\n      const oppMoves = getAttackingMovesForColor(oppColor, boardMap);\n      const castleSquares = get.castleSquares(color)[side];\n\n      for (const square of castleSquares) {\n        // check if castle square is cleared\n        if (at(square, boardMap).piece) return false; // make sure castle square isnt attacked\n\n        if (oppMoves.includes(square)) return false;\n      }\n\n      return true;\n\n      function checkIfRookExists() {\n        let rookExists = false;\n        const rank = color === 'white' ? 1 : 8;\n        const loopStart = side === 'queenside' ? files.indexOf('a') : files.indexOf('d');\n        const loopEnd = side === 'queenside' ? files.indexOf('e') : files.indexOf('h');\n\n        for (let i = loopStart; i <= loopEnd; i++) {\n          const square = files[i] + rank;\n          const piece = at(square, boardMap).piece;\n          if (!piece) continue;\n          if (piece.type === 'rook') rookExists = true;\n        }\n\n        return rookExists;\n      }\n    },\n    boardStateFromHistory: history => {\n      const boardStates = [];\n      const boardMap = createBoard();\n      placePieces(standard, boardMap);\n      let pieceMap = standard; // history is 2d array\n\n      const flat = history.flat();\n      /* iterate over history */\n\n      for (const [i, m] of flat.entries()) {\n        const parsed = parseNotation(m);\n        const color = i % 2 === 0 ? 'white' : 'black';\n\n        if (parsed.castle) {\n          castle(color, parsed.castle, boardMap);\n          pieceMap = get.pieceMap(boardMap);\n          boardStates.push(new Map(boardMap));\n          continue;\n        }\n\n        const possiblePieces = pieceMap[color][parsed.pieceType].filter(s => getLegalMoves(s, boardMap).includes(parsed.to)); // get 'from' square\n\n        let s1;\n\n        if (parsed.from) {\n          const notation = parsed.from;\n          if (notation.length === 2) s1 = notation;else {\n            s1 = possiblePieces.find(s => {\n              // if notation is a number, that means piece is on the rank === notation, if not, same file\n              return isNaN(Number(notation)) ? s[0] === notation : s[1] === notation;\n            }) || '';\n          }\n        } else s1 = possiblePieces[0];\n\n        const piece = at(s1, boardMap).piece;\n\n        if (!s1 || !piece) {\n          break;\n        } // make move\n\n\n        if (piece.type === 'pawn') {\n          if (enPassant.isCapture(s1, parsed.to, boardMap)) {\n            enPassant.capture(parsed.to, boardMap);\n          }\n\n          enPassant.remove(boardMap);\n          if (enPassant.checkToggle(s1, parsed.to)) enPassant.toggle(color, parsed.to, boardMap);\n\n          if (parsed.promote) {\n            at(s1, boardMap).promote(parsed.promote);\n          }\n        } else enPassant.remove(boardMap);\n\n        from(s1, boardMap).to(parsed.to);\n        pieceMap = get.pieceMap(boardMap);\n        boardStates.push(new Map(boardMap));\n      }\n\n      return boardStates;\n    },\n\n    moveNotation(from, to, promote, check, checkmate, boardMap = board) {\n      var _a;\n\n      const moveDetails = {};\n      const {\n        type,\n        color\n      } = at(from, boardMap).piece;\n      moveDetails.pieceType = type;\n      if (checkmate) moveDetails.checkmate = checkmate;else if (check) moveDetails.check = check;\n      let capture = false;\n\n      switch (type) {\n        case 'pawn':\n          {\n            capture = (_a = src_Piece(color, type).getPawnCaptures(from)) === null || _a === void 0 ? void 0 : _a.includes(to);\n            moveDetails.capture = capture;\n            if (capture) moveDetails.differentiation = from[0];\n            break;\n          }\n\n        default:\n          {\n            capture = !!at(to, boardMap).piece;\n            moveDetails.capture = capture;\n          }\n      }\n\n      if (promote) moveDetails.promote = promote; // get differentiation ie. when multiple pieces hit the same square\n\n      const piecesThatHitSquare = get.piecesThatHitSquare(color, type, to, boardMap);\n\n      switch (piecesThatHitSquare.length) {\n        case 3:\n          moveDetails.differentiation = from;\n          break;\n\n        case 2:\n          {\n            // need to find if on same file or rank\n            const otherPiece = piecesThatHitSquare.find(s => s !== from);\n            moveDetails.differentiation = otherPiece[0] === from[0] ? from[1] : from[0];\n          }\n      }\n\n      return src_moveNotation(to).get(moveDetails);\n    }\n\n  };\n  const validate = {\n    move: (from, to, boardMap = board) => {\n      const piece = at(from, boardMap).piece;\n      if (!piece) return false;\n      if (!at(from, boardMap).getLegalMoves().includes(to)) return false;\n      return true;\n    },\n    promotion: (from, to, boardMap = board) => {\n      const piece = at(from, boardMap).piece;\n      if ((piece === null || piece === void 0 ? void 0 : piece.type) !== 'pawn') return false;\n      const endOfBoard = piece.color === 'white' ? 8 : 1;\n      const [, rank] = to.split('');\n      if (+rank !== endOfBoard) return false;\n      return true;\n    }\n  };\n  return {\n    createBoard,\n    placePieces,\n    castle,\n    enPassant,\n    at,\n    from,\n    get,\n    validate,\n    makeMove,\n\n    get board() {\n      return board;\n    }\n\n  };\n};\n\n/* harmony default export */ const src_Gameboard = (Gameboard);\n;// CONCATENATED MODULE: ./src/History.ts\n// should output history object that holds move history in 2d array\n// for each move needs to attach piece Type to beginning of move if not pawn\n// should further specify square of piece if, say both rooks, can move to same square\n\nfunction History(prevHistory) {\n  const history = deepCopy2dArray(prevHistory) || [];\n  return {\n    insertMove: notation => {\n      const lastPair = history[history.length - 1];\n\n      if (lastPair && lastPair.length === 1) {\n        lastPair.push(notation);\n      } else {\n        const newPair = [notation];\n        history.push(newPair);\n      }\n\n      return history;\n    }\n  };\n}\n;// CONCATENATED MODULE: ./src/startingPositions.ts\nconst standard = {\n  white: {\n    rook: ['a1', 'h1'],\n    knight: ['g1', 'b1'],\n    bishop: ['f1', 'c1'],\n    king: ['e1'],\n    queen: ['d1'],\n    pawn: ['a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2']\n  },\n  black: {\n    rook: ['a8', 'h8'],\n    knight: ['g8', 'b8'],\n    bishop: ['f8', 'c8'],\n    king: ['e8'],\n    queen: ['d8'],\n    pawn: ['a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7']\n  }\n};\n\n;// CONCATENATED MODULE: ./src/main.ts\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFQLENBSEg7QUFJTDNHLFFBQUksRUFBRSxDQUFDLElBQUQsQ0FKRDtBQUtMNEcsU0FBSyxFQUFFLENBQUMsSUFBRCxDQUxGO0FBTUxsSSxRQUFJLEVBQUUsQ0FBQyxJQUFELEVBQU8sSUFBUCxFQUFhLElBQWIsRUFBbUIsSUFBbkIsRUFBeUIsSUFBekIsRUFBK0IsSUFBL0IsRUFBcUMsSUFBckMsRUFBMkMsSUFBM0M7QUFORDtBQVRxQixDQUE5Qjs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Nyb0NoZXNzLy4vc3JjL3V0aWxzL2hlbHBlcnMudHM/MjhmMyIsIndlYnBhY2s6Ly9jcm9DaGVzcy8uL3NyYy9QaWVjZS50cz8yZWI4Iiwid2VicGFjazovL2Nyb0NoZXNzLy4vc3JjL3V0aWxzL21vdmVzLnRzPzUwZmIiLCJ3ZWJwYWNrOi8vY3JvQ2hlc3MvLi9zcmMvcmFua3NBbmRGaWxlcy50cz9lNjIxIiwid2VicGFjazovL2Nyb0NoZXNzLy4vc3JjL0Nhc3RsZS50cz8xY2VhIiwid2VicGFjazovL2Nyb0NoZXNzLy4vc3JjL21vdmVOb3RhdGlvbi50cz83NmU1Iiwid2VicGFjazovL2Nyb0NoZXNzLy4vc3JjL0dhbWVib2FyZC50cz81N2UzIiwid2VicGFjazovL2Nyb0NoZXNzLy4vc3JjL0hpc3RvcnkudHM/NGMyMSIsIndlYnBhY2s6Ly9jcm9DaGVzcy8uL3NyYy9zdGFydGluZ1Bvc2l0aW9ucy50cz8zYmJjIiwid2VicGFjazovL2Nyb0NoZXNzLy4vc3JjL21haW4udHM/Y2Q0OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb29yZCwgUGFyc2VkTm90YXRpb25JbnRlcmZhY2UgfSBmcm9tICcuLi90eXBlcy9pbnRlcmZhY2VzJztcbmltcG9ydCB7IFBpZWNlQWJicmV2aWF0aW9uLCBQaWVjZVR5cGUsIFNxdWFyZSB9IGZyb20gJy4uL3R5cGVzL3R5cGVzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHRvWFkoc3F1YXJlOiBTcXVhcmUpOiBDb29yZCB7XG4gIGNvbnN0IFt4LCB5XSA9IHNxdWFyZS5zcGxpdCgnJyk7XG4gIHJldHVybiB7XG4gICAgeDogWydhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJywgJ2gnXS5pbmRleE9mKHgudG9Mb3dlckNhc2UoKSksXG4gICAgeTogTnVtYmVyKHkpXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tWFkoY29vcmQ6IENvb3JkKTogU3F1YXJlIHtcbiAgY29uc3QgeyB4LCB5IH0gPSBjb29yZDtcbiAgY29uc3QgY29sID0gWydhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJywgJ2gnXVt4XTtcbiAgaWYgKCFjb2wpIHJldHVybiAnJztcbiAgcmV0dXJuIGNvbC5jb25jYXQoeS50b1N0cmluZygpKTtcbn1cblxuZXhwb3J0IGNvbnN0IGNhbGNEaXN0YW5jZSA9IChzcXVhcmVPbmU6IHN0cmluZykgPT4gKHNxdWFyZVR3bzogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IHsgeDogeDEsIHk6IHkxIH0gPSB0b1hZKHNxdWFyZU9uZSk7XG4gIGNvbnN0IHsgeDogeDIsIHk6IHkyIH0gPSB0b1hZKHNxdWFyZVR3byk7XG5cbiAgY29uc3QgeERpZmYgPSB4MSAtIHgyO1xuICBjb25zdCB5RGlmZiA9IHkxIC0geTI7XG4gIHJldHVybiB7XG4gICAgeERpZmYsXG4gICAgeURpZmZcbiAgfTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQaWVjZUZyb21BYmJyKGFiYnI6IFBpZWNlQWJicmV2aWF0aW9uKSB7XG4gIHN3aXRjaCAoYWJicikge1xuICAgIGNhc2UgJ0snOlxuICAgICAgcmV0dXJuICdraW5nJztcblxuICAgIGNhc2UgJ1EnOlxuICAgICAgcmV0dXJuICdxdWVlbic7XG5cbiAgICBjYXNlICdOJzpcbiAgICAgIHJldHVybiAna25pZ2h0JztcblxuICAgIGNhc2UgJ0InOlxuICAgICAgcmV0dXJuICdiaXNob3AnO1xuXG4gICAgY2FzZSAnUic6XG4gICAgICByZXR1cm4gJ3Jvb2snO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZU5vdGF0aW9uKG5vdGF0aW9uOiBzdHJpbmcpIHtcbiAgY29uc3QgbW92ZSA9IDxQYXJzZWROb3RhdGlvbkludGVyZmFjZT57fTtcblxuICBjb25zdCByZXBsYWNlZCA9IG5vdGF0aW9uLnJlcGxhY2UoL1sreCNdLywgJycpO1xuXG4gIGlmICgrcmVwbGFjZWRbMF0gPT09IDApIHtcbiAgICAvLyB0aGlzIGlzIGNhc3RsZVxuICAgIG1vdmUuY2FzdGxlID0gcmVwbGFjZWQubGVuZ3RoID09PSAzID8gJ2tpbmdzaWRlJyA6ICdxdWVlbnNpZGUnO1xuICAgIHJldHVybiBtb3ZlO1xuICB9XG5cbiAgaWYgKHJlcGxhY2VkWzBdLnRvVXBwZXJDYXNlKCkgPT09IHJlcGxhY2VkWzBdKSB7XG4gICAgLy8gdGhpcyBpcyBwaWVjZSBtb3ZlXG4gICAgbW92ZS5waWVjZVR5cGUgPSBnZXRQaWVjZUZyb21BYmJyKHJlcGxhY2VkWzBdIGFzIFBpZWNlQWJicmV2aWF0aW9uKTtcbiAgICBtb3ZlLnRvID0gcmVwbGFjZWQuc2xpY2UoLTIpO1xuXG4gICAgc3dpdGNoIChyZXBsYWNlZC5sZW5ndGgpIHtcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgbW92ZS5mcm9tID0gcmVwbGFjZWRbMV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA1OlxuICAgICAgICBtb3ZlLmZyb20gPSByZXBsYWNlZC5zbGljZSgxLCAzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vdmU7XG4gIH0gZWxzZSB7XG4gICAgLy8gaXMgYSBwYXduIG1vdmVcbiAgICBtb3ZlLnBpZWNlVHlwZSA9ICdwYXduJztcblxuICAgIGlmIChyZXBsYWNlZC5pbmNsdWRlcygnPScpKSB7XG4gICAgICAvLyBpbmRpY2F0ZXMgcHJvbW90aW9uXG4gICAgICBtb3ZlLnByb21vdGUgPSBnZXRQaWVjZUZyb21BYmJyKHJlcGxhY2VkLnNsaWNlKC0xKSBhcyBQaWVjZUFiYnJldmlhdGlvbik7XG4gICAgfVxuXG4gICAgY29uc3QgcHJvbW90ZU5vdGVJbmRleCA9IHJlcGxhY2VkLmluZGV4T2YoJz0nKTtcbiAgICBjb25zdCBub1Byb21vdGVOb3RhdGlvbiA9IHJlcGxhY2VkLnNsaWNlKFxuICAgICAgMCxcbiAgICAgIHByb21vdGVOb3RlSW5kZXggPT09IC0xID8gcmVwbGFjZWQubGVuZ3RoIDogcHJvbW90ZU5vdGVJbmRleFxuICAgICk7XG4gICAgaWYgKG5vUHJvbW90ZU5vdGF0aW9uLmxlbmd0aCA9PT0gMykge1xuICAgICAgbW92ZS5mcm9tID0gcmVwbGFjZWRbMF07XG4gICAgfVxuICAgIG1vdmUudG8gPSBub1Byb21vdGVOb3RhdGlvbi5zbGljZSgtMik7XG4gIH1cblxuICByZXR1cm4gbW92ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZXBDb3B5MmRBcnJheShhcnI6IHN0cmluZ1tdW10pOiBzdHJpbmdbXVtdIHtcbiAgcmV0dXJuIGFyci5tYXAoKG4pID0+IFsuLi5uXSk7XG59XG4iLCJpbXBvcnQgbW92ZXMgZnJvbSAnLi91dGlscy9tb3Zlcyc7XG5pbXBvcnQgeyB0b1hZLCBmcm9tWFkgfSBmcm9tICcuL3V0aWxzL2hlbHBlcnMnO1xuXG5pbXBvcnQgeyBDb2xvciwgU3F1YXJlLCBQaWVjZVR5cGUgfSBmcm9tICcuL3R5cGVzL3R5cGVzJztcblxuY29uc3QgUGllY2UgPSAoY29sb3I6IENvbG9yLCB0eXBlOiBQaWVjZVR5cGUpID0+IHtcbiAgZnVuY3Rpb24gaGFzTW92ZShmcm9tOiBTcXVhcmUsIHRvOiBTcXVhcmUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2tpbmcnOiB7XG4gICAgICAgIGNvbnN0IG9uZVNxdWFyZVZlcnQgPVxuICAgICAgICAgIG1vdmVzLnlCeU4oMSkoZnJvbSkodG8pICYmIG1vdmVzLnhCeU4oMCkoZnJvbSkodG8pO1xuICAgICAgICBjb25zdCBvbmVTcXVhcmVMYXRlcmFsID1cbiAgICAgICAgICBtb3Zlcy54QnlOKDEpKGZyb20pKHRvKSAmJiBtb3Zlcy55QnlOKDApKGZyb20pKHRvKTtcbiAgICAgICAgY29uc3Qgb25lU3F1YXJlRGlhZ29uYWxseSA9XG4gICAgICAgICAgbW92ZXMueUJ5TigxKShmcm9tKSh0bykgJiYgbW92ZXMueEJ5TigxKShmcm9tKSh0byk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBmcm9tICE9PSB0byAmJlxuICAgICAgICAgIChvbmVTcXVhcmVEaWFnb25hbGx5IHx8IG9uZVNxdWFyZVZlcnQgfHwgb25lU3F1YXJlTGF0ZXJhbClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ3F1ZWVuJzoge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGZyb20gIT09IHRvICYmXG4gICAgICAgICAgKG1vdmVzLmRpYWdvbmFsKGZyb20pKHRvKSB8fCBtb3Zlcy52ZXJ0QW5kTGF0ZXJhbChmcm9tKSh0bykpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjYXNlICdiaXNob3AnOiB7XG4gICAgICAgIHJldHVybiBmcm9tICE9PSB0byAmJiBtb3Zlcy5kaWFnb25hbChmcm9tKSh0byk7XG4gICAgICB9XG4gICAgICBjYXNlICdrbmlnaHQnOiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgZnJvbSAhPT0gdG8gJiZcbiAgICAgICAgICAoKG1vdmVzLnhCeU4oMSkoZnJvbSkodG8pICYmIG1vdmVzLnlCeU4oMikoZnJvbSkodG8pKSB8fFxuICAgICAgICAgICAgKG1vdmVzLnhCeU4oMikoZnJvbSkodG8pICYmIG1vdmVzLnlCeU4oMSkoZnJvbSkodG8pKSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ3Jvb2snOiB7XG4gICAgICAgIHJldHVybiBmcm9tICE9PSB0byAmJiBtb3Zlcy52ZXJ0QW5kTGF0ZXJhbCh0bykoZnJvbSk7XG4gICAgICB9XG4gICAgICBjYXNlICdwYXduJzoge1xuICAgICAgICBjb25zdCB7IHg6IHgxLCB5OiB5MSB9ID0gdG9YWShmcm9tKTtcbiAgICAgICAgY29uc3QgeyB4OiB4MiwgeTogeTIgfSA9IHRvWFkodG8pO1xuXG4gICAgICAgIGNvbnN0IG9ubHlNb3Zlc0luRnJvbnQgPSBjb2xvciA9PT0gJ3doaXRlJyA/IHkxIDwgeTIgOiB5MSA+IHkyO1xuICAgICAgICBjb25zdCByZWd1bGFyTW92ZSA9IG1vdmVzLnlCeU4oMSkoZnJvbSkodG8pICYmIHgxID09PSB4MjtcblxuICAgICAgICBjb25zdCBmaXJzdE1vdmUgPSBjb2xvciA9PT0gJ3doaXRlJyA/IHkxID09PSAyIDogeTEgPT09IDc7XG4gICAgICAgIGNvbnN0IGp1bXBUd28gPSBtb3Zlcy55QnlOKDIpKGZyb20pKHRvKSAmJiB4MSA9PT0geDI7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBmcm9tICE9PSB0byAmJlxuICAgICAgICAgIG9ubHlNb3Zlc0luRnJvbnQgJiZcbiAgICAgICAgICAocmVndWxhck1vdmUgfHwgKGZpcnN0TW92ZSAmJiBqdW1wVHdvKSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQYXduQ2FwdHVyZXMob3JpZ2luOiBTcXVhcmUpIHtcbiAgICBpZiAodHlwZSAhPT0gJ3Bhd24nKSByZXR1cm47XG5cbiAgICBjb25zdCB7IHgsIHkgfSA9IHRvWFkob3JpZ2luKTtcblxuICAgIGNvbnN0IG5ld1kgPSBjb2xvciA9PT0gJ3doaXRlJyA/IHkgKyAxIDogeSAtIDE7XG5cbiAgICBjb25zdCBjYXB0dXJlT25lID0geyB4OiB4ICsgMSwgeTogbmV3WSB9O1xuICAgIGNvbnN0IGNhcHR1cmVUd28gPSB7IHg6IHggLSAxLCB5OiBuZXdZIH07XG5cbiAgICByZXR1cm4gW2Zyb21YWShjYXB0dXJlT25lKSwgZnJvbVhZKGNhcHR1cmVUd28pXTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaGFzTW92ZSxcbiAgICBnZXRQYXduQ2FwdHVyZXMsXG4gICAgZ2V0IHR5cGUoKSB7XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9LFxuICAgIGdldCBjb2xvcigpIHtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG4gIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBQaWVjZTtcbiIsImltcG9ydCB7IGNhbGNEaXN0YW5jZSwgdG9YWSB9IGZyb20gJy4vaGVscGVycyc7XG5pbXBvcnQgeyBTcXVhcmVPYmosIFBpZWNlT2JqLCBFblBhc3NhbnRPYmogfSBmcm9tICcuLi90eXBlcy9pbnRlcmZhY2VzJztcbmltcG9ydCB7IE1vdmVzLCBCb2FyZCwgU3F1YXJlLCBDb2xvciwgUGllY2VUeXBlIH0gZnJvbSAnLi4vdHlwZXMvdHlwZXMnO1xuaW1wb3J0IFBpZWNlIGZyb20gJy4uL1BpZWNlJztcblxuY29uc3QgbW92ZXMgPSB7XG4gIHZlcnRBbmRMYXRlcmFsOiAoZnJvbTogU3F1YXJlKSA9PiAodG86IFNxdWFyZSkgPT4ge1xuICAgIGNvbnN0IFt4MSwgeTFdID0gZnJvbS5zcGxpdCgnJyk7XG4gICAgY29uc3QgW3gyLCB5Ml0gPSB0by5zcGxpdCgnJyk7XG4gICAgcmV0dXJuIHgxID09PSB4MiB8fCB5MSA9PT0geTI7XG4gIH0sXG4gIGRpYWdvbmFsOiAoZnJvbTogU3F1YXJlKSA9PiAodG86IFNxdWFyZSkgPT4ge1xuICAgIGNvbnN0IHsgeDogeDEsIHk6IHkxIH0gPSB0b1hZKGZyb20pO1xuICAgIGNvbnN0IHsgeDogeDIsIHk6IHkyIH0gPSB0b1hZKHRvKTtcbiAgICByZXR1cm4gTWF0aC5hYnMoeDIgLSB4MSkgPT09IE1hdGguYWJzKHkyIC0geTEpO1xuICB9LFxuICB4QnlOOiAobnVtOiBudW1iZXIpID0+IChmcm9tOiBTcXVhcmUpID0+ICh0bzogU3F1YXJlKSA9PiB7XG4gICAgY29uc3QgeyB4OiB4MSB9ID0gdG9YWShmcm9tKTtcbiAgICBjb25zdCB7IHg6IHgyIH0gPSB0b1hZKHRvKTtcbiAgICByZXR1cm4gTWF0aC5hYnMoeDEgLSB4MikgPT09IG51bTtcbiAgfSxcbiAgeUJ5TjogKG51bTogbnVtYmVyKSA9PiAoZnJvbTogU3F1YXJlKSA9PiAodG86IFNxdWFyZSkgPT4ge1xuICAgIGNvbnN0IHsgeTogeTEgfSA9IHRvWFkoZnJvbSk7XG4gICAgY29uc3QgeyB5OiB5MiB9ID0gdG9YWSh0byk7XG4gICAgcmV0dXJuIE1hdGguYWJzKHkxIC0geTIpID09PSBudW07XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IG1vdmVzO1xuXG4vKiBkZWFsaW5nIHdpdGggbW92ZSB2ZWN0b3JzICovXG5cbmZ1bmN0aW9uIHNwbGl0SW50b1ZlY3RvcnMoYXJyYXlPZk1vdmVzOiBNb3Zlcywgc3RhcnQ6IFNxdWFyZSkge1xuICBpbnRlcmZhY2UgVmVjdG9ycyB7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nW107XG4gIH1cbiAgcmV0dXJuIGFycmF5T2ZNb3Zlcy5yZWR1Y2UoKGFjYzogVmVjdG9ycywgY3VycjogU3F1YXJlKSA9PiB7XG4gICAgY29uc3QgeyB4RGlmZiwgeURpZmYgfSA9IGNhbGNEaXN0YW5jZShzdGFydCkoY3Vycik7XG5cbiAgICBsZXQgdmVjdG9yID0gJyc7XG4gICAgaWYgKHlEaWZmICE9PSAwKSB2ZWN0b3IgPSB5RGlmZiA8IDAgPyAndXAnIDogJ2Rvd24nO1xuICAgIGlmICh4RGlmZiAhPT0gMCkgdmVjdG9yICs9IHhEaWZmIDwgMCA/ICdSaWdodCcgOiAnTGVmdCc7XG5cbiAgICAvLyBub3JtYWxpemUgdmVjdG9yIG5hbWVcbiAgICB2ZWN0b3IgPSB2ZWN0b3IuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyB2ZWN0b3Iuc2xpY2UoMSk7XG5cbiAgICBhY2NbdmVjdG9yXSA9IGFjY1t2ZWN0b3JdIHx8IFtdO1xuICAgIGFjY1t2ZWN0b3JdLnB1c2goY3Vycik7XG5cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59XG5cbmZ1bmN0aW9uIGdldEJlZ2lubmluZ09mVmVjdG9yKHZlY3RvcjogTW92ZXMpIHtcbiAgaWYgKHZlY3Rvci5sZW5ndGggPT09IDApIHJldHVybiAnJztcblxuICByZXR1cm4gdmVjdG9yLnJlZHVjZSgoYWNjLCBjdXJyKSA9PiB7XG4gICAgY29uc3QgeyB4OiB4MSwgeTogeTEgfSA9IHRvWFkoYWNjKTtcbiAgICBjb25zdCB7IHg6IHgyLCB5OiB5MiB9ID0gdG9YWShjdXJyKTtcblxuICAgIGNvbnN0IGFjY0lzQmVnaW5uaW5nID0geDEgPT09IHgyID8geTEgPCB5MiA6IHgxIDwgeDI7XG4gICAgcmV0dXJuIGFjY0lzQmVnaW5uaW5nID8gYWNjIDogY3VycjtcbiAgfSk7XG59XG5cbmNvbnN0IGdldE1vdmVzQWxvbmdWZWN0b3IgPSAoXG4gIHMxOiBTcXVhcmUsXG4gIHMyOiBTcXVhcmUsXG4gIGFsbFNxdWFyZXM6IE1vdmVzXG4pOiBNb3ZlcyA9PiB7XG4gIGNvbnN0IGxpZXNTYW1lVmVydE9yTGF0ID0gbW92ZXMudmVydEFuZExhdGVyYWwoczEpKHMyKTtcbiAgY29uc3QgbGllc1NhbWVEaWFnb25hbGx5ID0gbW92ZXMuZGlhZ29uYWwoczEpKHMyKTtcblxuICBjb25zdCBsaWVzT25TYW1lTGluZSA9IGxpZXNTYW1lVmVydE9yTGF0IHx8IGxpZXNTYW1lRGlhZ29uYWxseTtcbiAgaWYgKCFsaWVzT25TYW1lTGluZSkgcmV0dXJuIFtdO1xuXG4gIGNvbnN0IG1hdGNoaW5nVmVjdG9yID0gbGllc1NhbWVEaWFnb25hbGx5ID8gJ2RpYWdvbmFsJyA6ICd2ZXJ0QW5kTGF0ZXJhbCc7XG5cbiAgY29uc3Qgc3F1YXJlc0Fsb25nVmVjdG9yID0gYWxsU3F1YXJlcy5maWx0ZXIoXG4gICAgKHMpID0+IG1vdmVzW21hdGNoaW5nVmVjdG9yXShzMSkocykgJiYgbW92ZXNbbWF0Y2hpbmdWZWN0b3JdKHMyKShzKVxuICApO1xuICByZXR1cm4gc3F1YXJlc0Fsb25nVmVjdG9yO1xufTtcblxuLyogc29ydCBtb3ZlcyAqL1xuXG5jb25zdCBzb3J0TW92ZXNDbG9zZXN0VG8gPVxuICAoc3F1YXJlOiBTcXVhcmUpID0+XG4gIChtb3ZlczogTW92ZXMpOiBNb3ZlcyA9PiB7XG4gICAgcmV0dXJuIFsuLi5tb3Zlc10uc29ydCgoYSwgYikgPT4ge1xuICAgICAgY29uc3QgeyB4RGlmZjogeDFEaWZmLCB5RGlmZjogeTFEaWZmIH0gPSBjYWxjRGlzdGFuY2Uoc3F1YXJlKShhKTtcbiAgICAgIGNvbnN0IGFEaWZmID0gTWF0aC5hYnMoeDFEaWZmKSArIE1hdGguYWJzKHkxRGlmZik7XG5cbiAgICAgIGNvbnN0IHsgeERpZmY6IHgyRGlmZiwgeURpZmY6IHkyRGlmZiB9ID0gY2FsY0Rpc3RhbmNlKHNxdWFyZSkoYik7XG4gICAgICBjb25zdCBiRGlmZiA9IE1hdGguYWJzKHgyRGlmZikgKyBNYXRoLmFicyh5MkRpZmYpO1xuXG4gICAgICByZXR1cm4gYURpZmYgLSBiRGlmZjtcbiAgICB9KTtcbiAgfTtcblxuLyogZ2V0IG1vdmVzICovXG5cbmZ1bmN0aW9uIGdldFBvc3NpYmxlTW92ZXMob3JpZ2luOiBTcXVhcmUsIGJvYXJkOiBCb2FyZCkge1xuICAvLyBnZXQgYWxsIG1vdmVzIHRoYXQgY2FuIGhhcHBlbiBpZiBubyBvdGhlciBwaWVjZXMgd2VyZSBvbiB0aGUgYm9hcmRcbiAgY29uc3QgYWxsU3F1YXJlcyA9IEFycmF5LmZyb20oYm9hcmQua2V5cygpKTtcblxuICBjb25zdCBzcXVhcmUgPSBib2FyZC5nZXQob3JpZ2luKSBhcyBTcXVhcmVPYmo7XG5cbiAgY29uc3QgeyB0eXBlLCBjb2xvciB9ID0gc3F1YXJlLnBpZWNlIGFzIFBpZWNlT2JqO1xuICBjb25zdCBwaWVjZSA9IFBpZWNlKGNvbG9yLCB0eXBlKTtcblxuICByZXR1cm4gYWxsU3F1YXJlcy5maWx0ZXIoKHMpID0+IHBpZWNlLmhhc01vdmUob3JpZ2luLCBzKSk7XG59XG5cbmZ1bmN0aW9uIGdldExlZ2FsTW92ZXMob3JpZ2luOiBTcXVhcmUsIGJvYXJkOiBCb2FyZCkge1xuICAvLyBnZXQgbW92ZXMgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIG9yIG5vdCB0aGVyZSBpcyBjaGVja1xuXG4gIGNvbnN0IHNxdWFyZSA9IGJvYXJkLmdldChvcmlnaW4pIGFzIFNxdWFyZU9iajtcblxuICBjb25zdCBwaWVjZSA9IHNxdWFyZS5waWVjZSBhcyBQaWVjZU9iajtcblxuICBjb25zdCBwb3NzaWJsZU1vdmVzID0gZ2V0UG9zc2libGVNb3ZlcyhvcmlnaW4sIGJvYXJkKTtcblxuICBjb25zdCBvYnN0cnVjdGlvbnMgPSBwb3NzaWJsZU1vdmVzLmZpbHRlcigocykgPT4gYm9hcmQuZ2V0KHMpPy5waWVjZSk7XG4gIGlmICghb2JzdHJ1Y3Rpb25zLmxlbmd0aCkge1xuICAgIGlmIChwaWVjZS50eXBlID09PSAncGF3bicpXG4gICAgICByZXR1cm4gWy4uLmdldFBhd25DYXB0dXJlcyhvcmlnaW4sIGJvYXJkKSwgLi4ucG9zc2libGVNb3Zlc107XG4gICAgcmV0dXJuIHBvc3NpYmxlTW92ZXM7XG4gIH1cblxuICBsZXQgbGVnYWxNb3ZlczogTW92ZXMgPSBbXTtcbiAgc3dpdGNoIChwaWVjZS50eXBlKSB7XG4gICAgY2FzZSAna25pZ2h0Jzoge1xuICAgICAgbGVnYWxNb3ZlcyA9IHBvc3NpYmxlTW92ZXM7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAncGF3bic6IHtcbiAgICAgIGNvbnN0IGNhcHR1cmVzQXZhaWxhYmxlID0gZ2V0UGF3bkNhcHR1cmVzKG9yaWdpbiwgYm9hcmQpO1xuICAgICAgY29uc3QgdW5vYnN0cnVjdGVkTW92ZXMgPSByZW1vdmVNb3Zlc1dpdGhQaWVjZXMoXG4gICAgICAgIHJlbW92ZU9ic3RydWN0ZWRNb3ZlcyhvcmlnaW4sIHBvc3NpYmxlTW92ZXMsIG9ic3RydWN0aW9ucyksXG4gICAgICAgIGJvYXJkXG4gICAgICApO1xuICAgICAgbGVnYWxNb3ZlcyA9IFsuLi5jYXB0dXJlc0F2YWlsYWJsZSwgLi4udW5vYnN0cnVjdGVkTW92ZXNdO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgJ2tpbmcnOiB7XG4gICAgICBsZWdhbE1vdmVzID0gcmVtb3ZlUHJvdGVjdGVkU3F1YXJlcyhvcmlnaW4sIHBvc3NpYmxlTW92ZXMsIGJvYXJkKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBsZWdhbE1vdmVzID0gcmVtb3ZlT2JzdHJ1Y3RlZE1vdmVzKG9yaWdpbiwgcG9zc2libGVNb3Zlcywgb2JzdHJ1Y3Rpb25zKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVtb3ZlTW92ZXNXaXRoUGllY2VzKGxlZ2FsTW92ZXMsIGJvYXJkLCBwaWVjZS5jb2xvcik7XG59XG5cbmZ1bmN0aW9uIGdldExlZ2FsTW92ZXNJbkNoZWNrKFxuICBvcmlnaW46IFNxdWFyZSxcbiAgYm9hcmQ6IEJvYXJkLFxuICBraW5nUG9zOiBTcXVhcmUsXG4gIHNxdWFyZUdpdmluZ0NoZWNrOiBTcXVhcmVcbikge1xuICBjb25zdCBzcXVhcmVzVGhhdERlYWxXaXRoQ2hlY2sgPSBnZXRTcXVhcmVzQmV0d2VlbktpbmdBbmRDaGVjayhcbiAgICBraW5nUG9zLFxuICAgIHNxdWFyZUdpdmluZ0NoZWNrLFxuICAgIEFycmF5LmZyb20oYm9hcmQua2V5cygpKVxuICApO1xuXG4gIGNvbnN0IG1vdmVzID0gZ2V0TGVnYWxNb3ZlcyhvcmlnaW4sIGJvYXJkKTtcblxuICByZXR1cm4gbW92ZXMuZmlsdGVyKChzKSA9PiBzcXVhcmVzVGhhdERlYWxXaXRoQ2hlY2suaW5jbHVkZXMocykpO1xufVxuXG5mdW5jdGlvbiBnZXRBdHRhY2tpbmdNb3ZlcyhvcmlnaW46IFNxdWFyZSwgYm9hcmQ6IEJvYXJkKSB7XG4gIGNvbnN0IHNxdWFyZSA9IGJvYXJkLmdldChvcmlnaW4pIGFzIFNxdWFyZU9iajtcblxuICBjb25zdCB7IHR5cGUsIGNvbG9yIH0gPSBzcXVhcmUucGllY2UgYXMgUGllY2VPYmo7XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAncGF3bic6IHtcbiAgICAgIGNvbnN0IHBpZWNlID0gUGllY2UoY29sb3IsICdwYXduJyk7XG4gICAgICByZXR1cm4gcGllY2UuZ2V0UGF3bkNhcHR1cmVzKG9yaWdpbikgYXMgTW92ZXM7XG4gICAgfVxuICAgIGNhc2UgJ2tpbmcnOiB7XG4gICAgICAvLyBuZWVkIHRvIGRvIHRoaXMgYmVjYXVzZSBnZXRMZWdhbE1vdmVzIHdpbGwgcmVjdXJzaXZlbHkgY2FsbCByZW1vdmVQcm90ZWN0ZWRTcXVhcmVzIG90aGVyd2lzZVxuICAgICAgY29uc3QgYXR0YWNraW5nTW92ZXMgPSByZW1vdmVNb3Zlc1dpdGhQaWVjZXMoXG4gICAgICAgIGdldFBvc3NpYmxlTW92ZXMob3JpZ2luLCBib2FyZCksXG4gICAgICAgIGJvYXJkLFxuICAgICAgICBjb2xvclxuICAgICAgKTtcbiAgICAgIHJldHVybiBhdHRhY2tpbmdNb3ZlcztcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBnZXRMZWdhbE1vdmVzKG9yaWdpbiwgYm9hcmQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEFsbE1vdmVzRm9yQ29sb3IoXG4gIGNvbG9yOiBDb2xvcixcbiAgYm9hcmQ6IEJvYXJkLFxuICBza2lwS2luZz86IGJvb2xlYW5cbik6IE1vdmVzIHtcbiAgY29uc3QgYWxsTW92ZXM6IE1vdmVzW10gPSBbXTtcbiAgZm9yIChjb25zdCBbc3F1YXJlLCB7IHBpZWNlIH1dIG9mIGJvYXJkLmVudHJpZXMoKSkge1xuICAgIGlmICghcGllY2UpIGNvbnRpbnVlO1xuICAgIGlmIChwaWVjZS5jb2xvciAhPT0gY29sb3IpIGNvbnRpbnVlO1xuICAgIGlmIChza2lwS2luZyAmJiBwaWVjZS50eXBlID09PSAna2luZycpIGNvbnRpbnVlO1xuXG4gICAgYWxsTW92ZXMucHVzaChnZXRMZWdhbE1vdmVzKHNxdWFyZSwgYm9hcmQpKTtcbiAgfVxuXG4gIHJldHVybiBhbGxNb3Zlcy5mbGF0KCk7XG59XG5cbmZ1bmN0aW9uIGdldEF0dGFja2luZ01vdmVzRm9yQ29sb3IoY29sb3I6IENvbG9yLCBib2FyZDogQm9hcmQpOiBNb3ZlcyB7XG4gIGNvbnN0IGFsbE1vdmVzOiBNb3Zlc1tdID0gW107XG4gIGZvciAoY29uc3QgW3NxdWFyZSwgeyBwaWVjZSB9XSBvZiBib2FyZC5lbnRyaWVzKCkpIHtcbiAgICBpZiAoIXBpZWNlKSBjb250aW51ZTtcbiAgICBpZiAocGllY2UuY29sb3IgIT09IGNvbG9yKSBjb250aW51ZTtcblxuICAgIGFsbE1vdmVzLnB1c2goZ2V0QXR0YWNraW5nTW92ZXMoc3F1YXJlLCBib2FyZCkpO1xuICB9XG5cbiAgcmV0dXJuIGFsbE1vdmVzLmZsYXQoKTtcbn1cblxuZnVuY3Rpb24gZ2V0UGF3bkNhcHR1cmVzKHBhd25TcXVhcmU6IFNxdWFyZSwgYm9hcmQ6IEJvYXJkKSB7XG4gIGNvbnN0IHsgY29sb3IgfSA9IGJvYXJkLmdldChwYXduU3F1YXJlKT8ucGllY2UgYXMgUGllY2VPYmo7XG4gIGNvbnN0IHBhd24gPSBQaWVjZShjb2xvciwgJ3Bhd24nKTtcblxuICBjb25zdCBjYXB0dXJlTW92ZXMgPSBwYXduLmdldFBhd25DYXB0dXJlcyhwYXduU3F1YXJlKTtcbiAgaWYgKCFjYXB0dXJlTW92ZXMpIHJldHVybiBbXTtcblxuICByZXR1cm4gY2FwdHVyZU1vdmVzLmZpbHRlcigocykgPT4ge1xuICAgIGNvbnN0IHNxdWFyZVZhbCA9IGJvYXJkLmdldChzKTtcbiAgICBpZiAoIXNxdWFyZVZhbCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgY29uc3QgcGllY2UgPSBzcXVhcmVWYWwucGllY2U7XG4gICAgY29uc3QgZW5QYXNzYW50OiBFblBhc3NhbnRPYmogfCB1bmRlZmluZWQgPSBzcXVhcmVWYWwuZW5QYXNzYW50O1xuXG4gICAgcmV0dXJuIChcbiAgICAgIChwaWVjZSAmJiBwaWVjZS5jb2xvciAhPT0gcGF3bi5jb2xvcikgfHxcbiAgICAgIChlblBhc3NhbnQgJiYgZW5QYXNzYW50LmNvbG9yICE9PSBwYXduLmNvbG9yKVxuICAgICk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRTcXVhcmVzQmV0d2VlbktpbmdBbmRDaGVjayhcbiAga2luZ1BvczogU3F1YXJlLFxuICBjaGVja1BvczogU3F1YXJlLFxuICBhbGxTcXVhcmVzOiBNb3Zlc1xuKSB7XG4gIC8vIGluY2x1ZGVzIGtpbmdQb3MgYW5kIGNoZWNrUG9zXG4gIGNvbnN0IHNxdWFyZXNBbG9uZ1ZlY3RvciA9IGdldE1vdmVzQWxvbmdWZWN0b3Ioa2luZ1BvcywgY2hlY2tQb3MsIGFsbFNxdWFyZXMpO1xuICBjb25zdCBzcXVhcmVzQmV0d2VlbktpbmdBbmRQaWVjZSA9IHJlbW92ZU1vdmVzQmVoaW5kVHdvU3F1YXJlcyhcbiAgICBraW5nUG9zLFxuICAgIGNoZWNrUG9zLFxuICAgIHNxdWFyZXNBbG9uZ1ZlY3RvclxuICApO1xuICByZXR1cm4gc3F1YXJlc0JldHdlZW5LaW5nQW5kUGllY2U7XG59XG5cbi8qIGZpbHRlciBtb3ZlcyAqL1xuXG5mdW5jdGlvbiByZW1vdmVNb3Zlc0JlaGluZFR3b1NxdWFyZXMoXG4gIHMxOiBTcXVhcmUsXG4gIHMyOiBTcXVhcmUsXG4gIHZlY3RvcjogTW92ZXNcbik6IE1vdmVzIHtcbiAgY29uc3Qgc29ydGVkID0gc29ydE1vdmVzQ2xvc2VzdFRvKGdldEJlZ2lubmluZ09mVmVjdG9yKHZlY3RvcikpKHZlY3Rvcik7XG4gIGxldCBmdXJ0aGVzdFNxdWFyZTtcbiAgbGV0IGNsb3Nlc3RTcXVhcmU7XG5cbiAgaWYgKHNvcnRlZC5pbmRleE9mKHMxKSA+IHNvcnRlZC5pbmRleE9mKHMyKSkge1xuICAgIGZ1cnRoZXN0U3F1YXJlID0gczE7XG4gICAgY2xvc2VzdFNxdWFyZSA9IHMyO1xuICB9IGVsc2Uge1xuICAgIGZ1cnRoZXN0U3F1YXJlID0gczI7XG4gICAgY2xvc2VzdFNxdWFyZSA9IHMxO1xuICB9XG4gIGNvbnN0IHJlbW92ZWRPbmVFbmQgPSByZW1vdmVNb3Zlc0JlaGluZFNxdWFyZShmdXJ0aGVzdFNxdWFyZSkoc29ydGVkKTtcbiAgY29uc3QgcmVtb3ZlZEJvdGhFbmRzID0gcmVtb3ZlTW92ZXNCZWhpbmRTcXVhcmUoY2xvc2VzdFNxdWFyZSkoXG4gICAgcmVtb3ZlZE9uZUVuZC5yZXZlcnNlKClcbiAgKTtcblxuICByZXR1cm4gcmVtb3ZlZEJvdGhFbmRzO1xufVxuXG5jb25zdCByZW1vdmVNb3Zlc0JlaGluZFNxdWFyZSA9XG4gIChzcXVhcmU6IFNxdWFyZSkgPT5cbiAgKG1vdmVzOiBNb3Zlcyk6IE1vdmVzID0+IHtcbiAgICBjb25zdCBjb3B5ID0gWy4uLm1vdmVzXTtcbiAgICBjb25zdCBpbmRleCA9IG1vdmVzLmluZGV4T2Yoc3F1YXJlKTtcblxuICAgIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiBbXTtcblxuICAgIGNvcHkuc3BsaWNlKGluZGV4ICsgMSk7XG5cbiAgICByZXR1cm4gY29weTtcbiAgfTtcblxuZnVuY3Rpb24gcmVtb3ZlT2JzdHJ1Y3RlZE1vdmVzKFxuICBzdGFydGluZ1NxdWFyZTogU3F1YXJlLFxuICBwb3NzaWJsZU1vdmVzOiBNb3ZlcyxcbiAgb2JzdHJ1Y3Rpb25zOiBNb3Zlc1xuKTogTW92ZXMge1xuICAvLyBhKSBzcGxpdCBwb3NzaWJsZSBtb3ZlcyBpbnRvIHZlY3RvcnMgKHVwLGRvd24sbGVmdCxyaWdodCwgYW5kL29yIGRpYWdvbmFscylcbiAgLy8gYikgc2VlIHdoaWNoIG9ic3RydWN0aW9ucyBiZWxvbmcgdG8gd2hpY2ggdmVjdG9yXG4gIC8vIGMpIGZpbmQgdGhlIGNsb3Nlc3Qgb2JzdHJ1Y3Rpb25cbiAgLy8gZCkgcmVtb3ZlIGFsbCB0aGUgbW92ZXMgYmVoaW5kIHRoYXQgb2JzdHJ1Y3Rpb25cblxuICBjb25zdCBmaWx0ZXJlZE1vdmVzOiBNb3Zlc1tdID0gW107XG5cbiAgY29uc3QgYWxsVmVjdG9ycyA9IHNwbGl0SW50b1ZlY3RvcnMocG9zc2libGVNb3Zlcywgc3RhcnRpbmdTcXVhcmUpO1xuICBjb25zdCBvYnN0cnVjdGlvblZlY3RvcnMgPSBzcGxpdEludG9WZWN0b3JzKG9ic3RydWN0aW9ucywgc3RhcnRpbmdTcXVhcmUpO1xuICBmb3IgKGNvbnN0IHZlY3RvciBpbiBhbGxWZWN0b3JzKSB7XG4gICAgaWYgKCFvYnN0cnVjdGlvblZlY3RvcnNbdmVjdG9yXSkge1xuICAgICAgLy8gbG9vayBmb3IgdmVjdG9yIG9ic3RydWN0aW9uIGlzIG9uXG4gICAgICBmaWx0ZXJlZE1vdmVzLnB1c2goYWxsVmVjdG9yc1t2ZWN0b3JdKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHNvcnRlZCA9IHNvcnRNb3Zlc0Nsb3Nlc3RUbyhzdGFydGluZ1NxdWFyZSkoYWxsVmVjdG9yc1t2ZWN0b3JdKTtcbiAgICBjb25zdCBjbG9zZXN0T2JzdHJ1Y3Rpb24gPSBzb3J0TW92ZXNDbG9zZXN0VG8oc3RhcnRpbmdTcXVhcmUpKFxuICAgICAgb2JzdHJ1Y3Rpb25WZWN0b3JzW3ZlY3Rvcl1cbiAgICApWzBdO1xuXG4gICAgZmlsdGVyZWRNb3Zlcy5wdXNoKHJlbW92ZU1vdmVzQmVoaW5kU3F1YXJlKGNsb3Nlc3RPYnN0cnVjdGlvbikoc29ydGVkKSk7XG4gIH1cblxuICByZXR1cm4gZmlsdGVyZWRNb3Zlcy5mbGF0KCk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVByb3RlY3RlZFNxdWFyZXMoXG4gIGtpbmdQb3M6IFNxdWFyZSxcbiAgcG9zc2libGVNb3ZlczogTW92ZXMsXG4gIGJvYXJkOiBCb2FyZFxuKTogTW92ZXMge1xuICBjb25zdCBraW5nID0gYm9hcmQuZ2V0KGtpbmdQb3MpPy5waWVjZSBhcyBQaWVjZU9iajtcbiAgY29uc3Qgb3BwQ29sb3IgPSBraW5nLmNvbG9yID09PSAnd2hpdGUnID8gJ2JsYWNrJyA6ICd3aGl0ZSc7XG5cbiAgLy8gYmMga2luZyBjYW50IG1vdmUgaWYgc3F1YXJlIGlzIHByb3RlY3RlZFxuICAvLyBzZXQga2luZyBwaWVjZSBvbiBlYWNoIHNxdWFyZSBpbiBwb3NzaWJsZSBtb3ZlcyB0byBmaW5kIHdoaWNoIHNxdWFyZXMgYXJlIHByb3RlY3RlZFxuICBjb25zdCBib2FyZENvcHkgPSBuZXcgTWFwKGJvYXJkKTtcbiAgcG9zc2libGVNb3Zlcy5mb3JFYWNoKChzKSA9PiBib2FyZENvcHkuc2V0KHMsIHsgcGllY2U6IGtpbmcgfSkpO1xuXG4gIGNvbnN0IGFsbEVuZW15TW92ZXMgPSBnZXRBdHRhY2tpbmdNb3Zlc0ZvckNvbG9yKG9wcENvbG9yLCBib2FyZENvcHkpO1xuICByZXR1cm4gcG9zc2libGVNb3Zlcy5maWx0ZXIoKHMpID0+IHtcbiAgICByZXR1cm4gIWFsbEVuZW15TW92ZXMuaW5jbHVkZXMocyk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZW1vdmVNb3Zlc1dpdGhQaWVjZXMoXG4gIG1vdmVzOiBNb3ZlcyxcbiAgYm9hcmQ6IEJvYXJkLFxuICBjb2xvcj86IENvbG9yXG4pOiBNb3ZlcyB7XG4gIHJldHVybiBtb3Zlcy5maWx0ZXIoKHMpID0+IHtcbiAgICBjb25zdCBzcXVhcmVWYWwgPSBib2FyZC5nZXQocyk7XG4gICAgaWYgKCFzcXVhcmVWYWwpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChjb2xvcikgcmV0dXJuICFzcXVhcmVWYWwucGllY2UgfHwgc3F1YXJlVmFsLnBpZWNlLmNvbG9yICE9PSBjb2xvcjtcbiAgICBlbHNlIHJldHVybiAhc3F1YXJlVmFsLnBpZWNlO1xuICB9KTtcbn1cblxuLyogZ2FtZWJvYXJkIGNoZWNrcyAqL1xuXG5mdW5jdGlvbiBnZXREaXNjb3ZlcmVkQ2hlY2soXG4gIGtpbmdQb3M6IFNxdWFyZSxcbiAga2luZ0NvbG9yOiBDb2xvcixcbiAgdmFjYXRlZDogU3F1YXJlLFxuICBib2FyZDogQm9hcmRcbik6IFNxdWFyZSB7XG4gIC8vIG9wZW5TcXVhcmUgaXMgYSBzcXVhcmUganVzdCB2YWNhdGVkXG4gIGxldCBzcXVhcmVzQWxvbmdWZWN0b3IgPSBnZXRNb3Zlc0Fsb25nVmVjdG9yKFxuICAgIGtpbmdQb3MsXG4gICAgdmFjYXRlZCxcbiAgICBBcnJheS5mcm9tKGJvYXJkLmtleXMoKSlcbiAgKTtcbiAgc3F1YXJlc0Fsb25nVmVjdG9yID0gc3F1YXJlc0Fsb25nVmVjdG9yLmZpbHRlcihcbiAgICAocykgPT4gcyAhPT0ga2luZ1BvcyAmJiBzICE9PSB2YWNhdGVkXG4gICk7XG4gIGlmICghc3F1YXJlc0Fsb25nVmVjdG9yLmxlbmd0aCkgcmV0dXJuICcnO1xuXG4gIGZvciAoY29uc3Qgc3F1YXJlIG9mIHNxdWFyZXNBbG9uZ1ZlY3Rvcikge1xuICAgIGNvbnN0IHBpZWNlID0gYm9hcmQuZ2V0KHNxdWFyZSk/LnBpZWNlO1xuICAgIGlmICghcGllY2UgfHwgcGllY2UuY29sb3IgPT09IGtpbmdDb2xvcikgY29udGludWU7XG5cbiAgICBjb25zdCBsZWdhbE1vdmVzID0gZ2V0TGVnYWxNb3ZlcyhzcXVhcmUsIGJvYXJkKTtcbiAgICBpZiAobGVnYWxNb3Zlcy5pbmNsdWRlcyhraW5nUG9zKSkgcmV0dXJuIHNxdWFyZTtcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gY2FuQmxvY2tPckNhcHR1cmVDaGVjayhcbiAga2luZ1BvczogU3F1YXJlLFxuICBzcXVhcmVHaXZpbmdDaGVjazogU3F1YXJlLFxuICBib2FyZDogQm9hcmRcbik6IGJvb2xlYW4ge1xuICBjb25zdCBraW5nID0gYm9hcmQuZ2V0KGtpbmdQb3MpPy5waWVjZSBhcyBQaWVjZU9iajtcblxuICBjb25zdCBibG9ja09yQ2FwdHVyZVNxdWFyZXMgPSBnZXRTcXVhcmVzQmV0d2VlbktpbmdBbmRDaGVjayhcbiAgICBraW5nUG9zLFxuICAgIHNxdWFyZUdpdmluZ0NoZWNrLFxuICAgIEFycmF5LmZyb20oYm9hcmQua2V5cygpKVxuICApOyAvLyBhbHNvIGluY2x1ZGVzIGNoZWNrIHNxdWFyZVxuXG4gIGNvbnN0IG93blBpZWNlTW92ZXMgPSBnZXRBbGxNb3Zlc0ZvckNvbG9yKGtpbmcuY29sb3IsIGJvYXJkLCB0cnVlKTtcbiAgcmV0dXJuIG93blBpZWNlTW92ZXMuc29tZSgobW92ZSkgPT4gYmxvY2tPckNhcHR1cmVTcXVhcmVzLmluY2x1ZGVzKG1vdmUpKTtcbn1cblxuZnVuY3Rpb24gZ2V0UGllY2VzV2l0aE1vdmUoXG4gIGJvYXJkOiBCb2FyZCxcbiAgbW92ZTogU3F1YXJlLFxuICBwaWVjZVR5cGU6IFBpZWNlVHlwZSxcbiAgY29sb3I6ICdibGFjaycgfCAnd2hpdGUnXG4pIHtcbiAgY29uc3QgcGllY2VTcXVhcmVzOiBNb3ZlcyA9IFtdO1xuICBmb3IgKGNvbnN0IFtzcXVhcmUsIHsgcGllY2UgfV0gb2YgYm9hcmQuZW50cmllcygpKSB7XG4gICAgaWYgKCFwaWVjZSkgY29udGludWU7XG4gICAgaWYgKHBpZWNlLmNvbG9yICE9PSBjb2xvcikgY29udGludWU7XG4gICAgaWYgKHBpZWNlLnR5cGUgIT09IHBpZWNlVHlwZSkgY29udGludWU7XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgZ2V0QXR0YWNraW5nTW92ZXNGb3JDb2xvcixcbiAgZ2V0TGVnYWxNb3ZlcyxcbiAgZ2V0TGVnYWxNb3Zlc0luQ2hlY2ssXG4gIGdldERpc2NvdmVyZWRDaGVjayxcbiAgY2FuQmxvY2tPckNhcHR1cmVDaGVja1xufTtcbiIsImNvbnN0IGZpbGVzID0gWydhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJywgJ2gnXTtcbmNvbnN0IHJhbmtzID0gWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDhdO1xuXG5leHBvcnQgeyBmaWxlcywgcmFua3MgfTtcbiIsImltcG9ydCB7IENhc3RsZU9iaiB9IGZyb20gJy4vdHlwZXMvaW50ZXJmYWNlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENhc3RsZShcbiAgd2hpdGVLaW5nc2lkZTogYm9vbGVhbixcbiAgd2hpdGVRdWVlbnNpZGU6IGJvb2xlYW4sXG4gIGJsYWNrS2luZ3NpZGU6IGJvb2xlYW4sXG4gIGJsYWNrUXVlZW5zaWRlOiBib29sZWFuXG4pOiBDYXN0bGVPYmoge1xuICByZXR1cm4ge1xuICAgIHdoaXRlOiB7XG4gICAgICBraW5nc2lkZTogd2hpdGVLaW5nc2lkZSxcbiAgICAgIHF1ZWVuc2lkZTogd2hpdGVRdWVlbnNpZGVcbiAgICB9LFxuICAgIGJsYWNrOiB7XG4gICAgICBraW5nc2lkZTogYmxhY2tLaW5nc2lkZSxcbiAgICAgIHF1ZWVuc2lkZTogYmxhY2tRdWVlbnNpZGVcbiAgICB9XG4gIH07XG59XG4iLCJpbXBvcnQgeyBNb3ZlRGV0YWlsc0ludGVyZmFjZSB9IGZyb20gJy4vdHlwZXMvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBQaWVjZVR5cGUgfSBmcm9tICcuL3R5cGVzL3R5cGVzJztcblxuY29uc3QgbW92ZU5vdGF0aW9uID0gKG5vdGF0aW9uOiBzdHJpbmcpID0+IHtcbiAgZnVuY3Rpb24gY2FzdGxlKHNpZGU6ICdraW5nc2lkZScgfCAncXVlZW5zaWRlJykge1xuICAgIG5vdGF0aW9uID0gc2lkZSA9PT0gJ2tpbmdzaWRlJyA/ICcwLTAnIDogJzAtMC0wJztcbiAgICByZXR1cm4gbm90YXRpb247XG4gIH1cblxuICBjb25zdCBhZmZpeCA9IHtcbiAgICBwaWVjZU5vdGF0aW9uOiAocGllY2VUeXBlOiBQaWVjZVR5cGUsIGRpZmZlcmVudGlhdGlvbj86IHN0cmluZykgPT4ge1xuICAgICAgZGlmZmVyZW50aWF0aW9uID0gZGlmZmVyZW50aWF0aW9uIHx8ICcnO1xuXG4gICAgICBzd2l0Y2ggKHBpZWNlVHlwZSkge1xuICAgICAgICBjYXNlICdwYXduJzoge1xuICAgICAgICAgIG5vdGF0aW9uID0gZGlmZmVyZW50aWF0aW9uICsgbm90YXRpb247XG4gICAgICAgICAgcmV0dXJuIG5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2tpbmcnOiB7XG4gICAgICAgICAgbm90YXRpb24gPSAnSycgKyBub3RhdGlvbjtcbiAgICAgICAgICByZXR1cm4gbm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAna25pZ2h0Jzoge1xuICAgICAgICAgIG5vdGF0aW9uID0gJ04nICsgZGlmZmVyZW50aWF0aW9uICsgbm90YXRpb247XG4gICAgICAgICAgcmV0dXJuIG5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBub3RhdGlvbiA9IHBpZWNlVHlwZVswXS50b1VwcGVyQ2FzZSgpICsgZGlmZmVyZW50aWF0aW9uICsgbm90YXRpb247XG4gICAgICAgICAgcmV0dXJuIG5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjYXB0dXJlOiAoKSA9PiB7XG4gICAgICBub3RhdGlvbiA9IGB4JHtub3RhdGlvbn1gO1xuICAgICAgcmV0dXJuIG5vdGF0aW9uO1xuICAgIH0sXG4gICAgcHJvbW90ZTogKHBpZWNlVHlwZTogUGllY2VUeXBlKSA9PiB7XG4gICAgICBjb25zdCBzdWZmaXggPVxuICAgICAgICAnPScgKyBwaWVjZVR5cGUgPT09ICdrbmlnaHQnID8gJ04nIDogcGllY2VUeXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgbm90YXRpb24gKz0gJz0nICsgc3VmZml4O1xuICAgICAgcmV0dXJuIG5vdGF0aW9uO1xuICAgIH0sXG4gICAgY2hlY2s6ICgpID0+IHtcbiAgICAgIG5vdGF0aW9uICs9ICcrJztcbiAgICAgIHJldHVybiBub3RhdGlvbjtcbiAgICB9LFxuICAgIGNoZWNrbWF0ZTogKCkgPT4ge1xuICAgICAgbm90YXRpb24gKz0gJyMnO1xuICAgICAgcmV0dXJuIG5vdGF0aW9uO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBnZXQobW92ZURldGFpbHM6IE1vdmVEZXRhaWxzSW50ZXJmYWNlKSB7XG4gICAgY29uc3Qge1xuICAgICAgY2FwdHVyZSxcbiAgICAgIGNhc3RsZTogY2FzdGxlU2lkZSxcbiAgICAgIHByb21vdGUsXG4gICAgICBjaGVjayxcbiAgICAgIGNoZWNrbWF0ZSxcbiAgICAgIHBpZWNlVHlwZSxcbiAgICAgIGRpZmZlcmVudGlhdGlvblxuICAgIH0gPSBtb3ZlRGV0YWlscztcblxuICAgIGlmIChjYXN0bGVTaWRlKSByZXR1cm4gY2FzdGxlKGNhc3RsZVNpZGUpO1xuXG4gICAgaWYgKGNhcHR1cmUpIGFmZml4LmNhcHR1cmUoKTtcbiAgICBhZmZpeC5waWVjZU5vdGF0aW9uKHBpZWNlVHlwZSBhcyBQaWVjZVR5cGUsIGRpZmZlcmVudGlhdGlvbik7XG4gICAgaWYgKHByb21vdGUpIGFmZml4LnByb21vdGUocHJvbW90ZSk7XG5cbiAgICBpZiAoY2hlY2ttYXRlKSBhZmZpeC5jaGVja21hdGUoKTtcbiAgICBlbHNlIGlmIChjaGVjaykgYWZmaXguY2hlY2soKTtcblxuICAgIHJldHVybiBub3RhdGlvbjtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldFxuICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgbW92ZU5vdGF0aW9uO1xuIiwiaW1wb3J0IHtcbiAgZ2V0TGVnYWxNb3ZlcyxcbiAgZ2V0RGlzY292ZXJlZENoZWNrLFxuICBjYW5CbG9ja09yQ2FwdHVyZUNoZWNrLFxuICBnZXRBdHRhY2tpbmdNb3Zlc0ZvckNvbG9yLFxuICBnZXRMZWdhbE1vdmVzSW5DaGVja1xufSBmcm9tICcuL3V0aWxzL21vdmVzJztcbmltcG9ydCB7IHRvWFksIGZyb21YWSwgZ2V0UGllY2VGcm9tQWJiciwgcGFyc2VOb3RhdGlvbiB9IGZyb20gJy4vdXRpbHMvaGVscGVycyc7XG5pbXBvcnQgeyByYW5rcywgZmlsZXMgfSBmcm9tICcuL3JhbmtzQW5kRmlsZXMnO1xuaW1wb3J0IHtcbiAgQ29sb3IsXG4gIFNxdWFyZSxcbiAgQm9hcmQsXG4gIFBpZWNlVHlwZSxcbiAgTW92ZXMsXG4gIENhc3RsZVNxdWFyZXNUeXBlLFxuICBIaXN0b3J5VHlwZSxcbiAgUGllY2VBYmJyZXZpYXRpb25cbn0gZnJvbSAnLi90eXBlcy90eXBlcyc7XG5pbXBvcnQge1xuICBBbGxQaWVjZU1hcCxcbiAgQ2FzdGxlT2JqLFxuICBFblBhc3NhbnRPYmosXG4gIEdhbWVib2FyZE9iaixcbiAgTW92ZURldGFpbHNJbnRlcmZhY2UsXG4gIFBpZWNlTWFwLFxuICBQaWVjZU9iaixcbiAgU3F1YXJlT2JqXG59IGZyb20gJy4vdHlwZXMvaW50ZXJmYWNlcyc7XG5pbXBvcnQgQ2FzdGxlIGZyb20gJy4vQ2FzdGxlJztcbmltcG9ydCB7IHN0YXJ0aW5nUG9zaXRpb25zIH0gZnJvbSAnLi9tYWluJztcbmltcG9ydCBIaXN0b3J5IGZyb20gJy4vSGlzdG9yeSc7XG5pbXBvcnQgbW92ZU5vdGF0aW9uIGZyb20gJy4vbW92ZU5vdGF0aW9uJztcbmltcG9ydCBQaWVjZSBmcm9tICcuL1BpZWNlJztcblxuZnVuY3Rpb24gY3JlYXRlQm9hcmQoKTogQm9hcmQge1xuICByZXR1cm4gZmlsZXMucmVkdWNlKChhY2MsIGZpbGUpID0+IHtcbiAgICByYW5rcy5mb3JFYWNoKChyYW5rKSA9PiB7XG4gICAgICBjb25zdCBzcXVhcmUgPSBmaWxlLmNvbmNhdChyYW5rLnRvU3RyaW5nKCkpO1xuICAgICAgYWNjLnNldChzcXVhcmUsIHsgcGllY2U6IG51bGwgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwgbmV3IE1hcCgpKTtcbn1cblxuY29uc3QgR2FtZWJvYXJkID0gKFxuICBib2FyZCA9IGNyZWF0ZUJvYXJkKCksXG4gIHNxdWFyZXNHaXZpbmdDaGVjaz86IE1vdmVzLFxuICBDYXN0bGVSaWdodHM/OiBDYXN0bGVPYmpcbik6IEdhbWVib2FyZE9iaiA9PiB7XG4gIGJvYXJkID0gbmV3IE1hcChib2FyZCk7XG5cbiAgZnVuY3Rpb24gcGxhY2VQaWVjZXMocGllY2VNYXA6IEFsbFBpZWNlTWFwLCBib2FyZE1hcCA9IGJvYXJkKSB7XG4gICAgbGV0IGNvbG9yOiBrZXlvZiB0eXBlb2YgcGllY2VNYXA7XG4gICAgZm9yIChjb2xvciBpbiBwaWVjZU1hcCkge1xuICAgICAgY29uc3QgbWFwID0gcGllY2VNYXBbY29sb3JdO1xuXG4gICAgICBsZXQgcGllY2VUeXBlOiBrZXlvZiB0eXBlb2YgbWFwO1xuICAgICAgZm9yIChwaWVjZVR5cGUgaW4gbWFwKSB7XG4gICAgICAgIGNvbnN0IHNxdWFyZXMgPSBtYXBbcGllY2VUeXBlXTtcbiAgICAgICAgc3F1YXJlcy5mb3JFYWNoKChzKSA9PlxuICAgICAgICAgIGF0KHMsIGJvYXJkTWFwKS5wbGFjZSh7IHR5cGU6IHBpZWNlVHlwZSwgY29sb3I6IGNvbG9yIH0pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFrZU1vdmUoXG4gICAgczE6IFNxdWFyZSxcbiAgICBzMjogU3F1YXJlLFxuICAgIHByb21vdGU/OiBQaWVjZVR5cGVcbiAgKTogQm9hcmQgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHBpZWNlID0gYXQoczEpLnBpZWNlO1xuXG4gICAgLy8gdmFsaWRhdGUgbW92ZVxuICAgIGlmICghcGllY2UpIHJldHVybjtcbiAgICBpZiAoIXZhbGlkYXRlLm1vdmUoczEsIHMyKSkgcmV0dXJuO1xuICAgIGlmIChwcm9tb3RlICYmICF2YWxpZGF0ZS5wcm9tb3Rpb24oczEsIHMyKSkgcmV0dXJuO1xuXG4gICAgc3dpdGNoIChwaWVjZS50eXBlKSB7XG4gICAgICBjYXNlICdwYXduJzoge1xuICAgICAgICBpZiAocHJvbW90ZSkge1xuICAgICAgICAgIGF0KHMxKS5wcm9tb3RlKHByb21vdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuUGFzc2FudC5pc0NhcHR1cmUoczEsIHMyKSkge1xuICAgICAgICAgIGVuUGFzc2FudC5jYXB0dXJlKHMyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVuUGFzc2FudC5yZW1vdmUoKTtcbiAgICAgICAgaWYgKGVuUGFzc2FudC5jaGVja1RvZ2dsZShzMSwgczIpKSB7XG4gICAgICAgICAgZW5QYXNzYW50LnRvZ2dsZShwaWVjZS5jb2xvciwgczIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnJvbShzMSkudG8oczIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY2FzZSAna2luZyc6IHtcbiAgICAgICAgLy8gY2hlY2sgaWYgbW92ZSBpcyBjYXN0bGVcbiAgICAgICAgY29uc3QgY2FzdGxlU2lkZSA9IGdldC5jYXN0bGVTaWRlKHBpZWNlLmNvbG9yLCBzMik7XG4gICAgICAgIGlmIChjYXN0bGVTaWRlKSBjYXN0bGUocGllY2UuY29sb3IsIGNhc3RsZVNpZGUpO1xuICAgICAgICBlbHNlIGZyb20oczEpLnRvKHMyKTtcblxuICAgICAgICBlblBhc3NhbnQucmVtb3ZlKCk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGZyb20oczEpLnRvKHMyKTtcbiAgICAgICAgZW5QYXNzYW50LnJlbW92ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBib2FyZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhc3RsZShcbiAgICBjb2xvcjogQ29sb3IsXG4gICAgc2lkZTogJ2tpbmdzaWRlJyB8ICdxdWVlbnNpZGUnLFxuICAgIGJvYXJkTWFwID0gYm9hcmRcbiAgKTogdm9pZCB7XG4gICAgY29uc3QgY2FzdGxlU3F1YXJlcyA9IGdldC5jYXN0bGVTcXVhcmVzKGNvbG9yKVtzaWRlXTtcblxuICAgIGNvbnN0IGtpbmdQb3MgPSBnZXQua2luZ1Bvc2l0aW9uKGNvbG9yLCBib2FyZE1hcCkgYXMgU3F1YXJlO1xuICAgIGNvbnN0IHJvb2tQb3MgPSBnZXRSb29rUG9zKCkgYXMgU3F1YXJlO1xuXG4gICAgZnJvbShyb29rUG9zLCBib2FyZE1hcCkudG8oY2FzdGxlU3F1YXJlc1swXSk7XG4gICAgZnJvbShraW5nUG9zLCBib2FyZE1hcCkudG8oY2FzdGxlU3F1YXJlc1sxXSk7XG5cbiAgICBmdW5jdGlvbiBnZXRSb29rUG9zKCkge1xuICAgICAgY29uc3QgcGllY2VNYXAgPSBnZXQucGllY2VNYXAoYm9hcmRNYXApO1xuICAgICAgY29uc3Qgcm9va1BvcyA9IHBpZWNlTWFwW2NvbG9yXS5yb29rLmZpbmQoKHNxdWFyZSkgPT4ge1xuICAgICAgICBjb25zdCBmaWxlID0gc3F1YXJlLnNwbGl0KCcnKVswXTtcbiAgICAgICAgcmV0dXJuIHNpZGUgPT09ICdraW5nc2lkZSdcbiAgICAgICAgICA/IGZpbGVzLmluZGV4T2YoZmlsZSkgPiAzXG4gICAgICAgICAgOiBmaWxlcy5pbmRleE9mKGZpbGUpIDwgMztcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcm9va1BvcztcbiAgICB9XG4gICAgLy8gbmVlZCB0byBnZXQga2luZyBwb3NpdGlvblxuICAgIC8vIG5lZWQgdG8gZ2V0IGNhc3RsZSBzcXVhcmVzXG4gICAgLy8gbmVlZCB0byBmaW5kIHJvb2tcbiAgfVxuXG4gIGNvbnN0IGVuUGFzc2FudCA9ICgoKSA9PiB7XG4gICAgZnVuY3Rpb24gZ2V0U3F1YXJlKGN1cnJlbnQ6IFNxdWFyZSwgY29sb3I6IENvbG9yKTogU3F1YXJlIHtcbiAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdG9YWShjdXJyZW50KTtcbiAgICAgIGNvbnN0IG5ld1kgPSBjb2xvciA9PT0gJ3doaXRlJyA/IHkgLSAxIDogeSArIDE7XG4gICAgICByZXR1cm4gZnJvbVhZKHsgeCwgeTogbmV3WSB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY2hlY2tUb2dnbGU6IChmcm9tOiBTcXVhcmUsIHRvOiBTcXVhcmUpOiBib29sZWFuID0+IHtcbiAgICAgICAgY29uc3QgeyB5OiB5MSB9ID0gdG9YWShmcm9tKTtcbiAgICAgICAgY29uc3QgeyB5OiB5MiB9ID0gdG9YWSh0byk7XG5cbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHkxIC0geTIpID09PSAyO1xuICAgICAgfSxcbiAgICAgIHRvZ2dsZTogKGNvbG9yOiBDb2xvciwgY3VycmVudDogU3F1YXJlLCBib2FyZE1hcCA9IGJvYXJkKTogdm9pZCA9PiB7XG4gICAgICAgIGNvbnN0IGVuUGFzc2FudFNxdWFyZSA9IGdldFNxdWFyZShjdXJyZW50LCBjb2xvcik7XG4gICAgICAgIGF0KGVuUGFzc2FudFNxdWFyZSwgYm9hcmRNYXApLnNldEVuUGFzc2FudChjb2xvciwgY3VycmVudCk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlOiAoYm9hcmRNYXAgPSBib2FyZCk6IHZvaWQgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IHNxdWFyZU9iaiBvZiBib2FyZE1hcC52YWx1ZXMoKSkge1xuICAgICAgICAgIGlmIChzcXVhcmVPYmouZW5QYXNzYW50KSByZXR1cm4gKHNxdWFyZU9iai5lblBhc3NhbnQgPSB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaXNDYXB0dXJlOiAoZnJvbTogU3F1YXJlLCB0bzogU3F1YXJlLCBib2FyZE1hcCA9IGJvYXJkKTogYm9vbGVhbiA9PiB7XG4gICAgICAgIGNvbnN0IHBpZWNlID0gYXQoZnJvbSwgYm9hcmRNYXApLnBpZWNlO1xuICAgICAgICBjb25zdCBlblBhc3NhbnQgPSBib2FyZE1hcC5nZXQodG8pPy5lblBhc3NhbnQ7XG4gICAgICAgIGlmICghcGllY2UgfHwgcGllY2UudHlwZSAhPT0gJ3Bhd24nKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghZW5QYXNzYW50KSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChlblBhc3NhbnQuY29sb3IgPT09IHBpZWNlLmNvbG9yKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSxcbiAgICAgIGNhcHR1cmU6ICh0bzogU3F1YXJlLCBib2FyZE1hcCA9IGJvYXJkKSA9PiB7XG4gICAgICAgIGNvbnN0IGVuUGFzc2FudCA9IGJvYXJkTWFwLmdldCh0byk/LmVuUGFzc2FudCBhcyBFblBhc3NhbnRPYmo7XG5cbiAgICAgICAgYXQoZW5QYXNzYW50LmN1cnJlbnQsIGJvYXJkTWFwKS5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KSgpO1xuXG4gIGNvbnN0IGF0ID0gKHNxdWFyZTogU3F1YXJlLCBib2FyZE1hcCA9IGJvYXJkKSA9PiAoe1xuICAgIHBsYWNlOiAocGllY2U6IFBpZWNlT2JqKTogdm9pZCA9PiB7XG4gICAgICBpZiAoIWJvYXJkTWFwLmdldChzcXVhcmUpKSByZXR1cm47XG5cbiAgICAgIGJvYXJkTWFwLnNldChzcXVhcmUsIHsgcGllY2UgfSk7XG4gICAgfSxcbiAgICByZW1vdmU6ICgpOiB2b2lkID0+IHtcbiAgICAgIGlmICghYm9hcmRNYXAuZ2V0KHNxdWFyZSkpIHJldHVybjtcblxuICAgICAgYm9hcmRNYXAuc2V0KHNxdWFyZSwgeyBwaWVjZTogbnVsbCB9KTtcbiAgICB9LFxuICAgIHByb21vdGU6IChwaWVjZVR5cGU6IFBpZWNlVHlwZSk6IHZvaWQgPT4ge1xuICAgICAgY29uc3Qgc3F1YXJlVmFsID0gYm9hcmRNYXAuZ2V0KHNxdWFyZSk7XG4gICAgICBjb25zdCBwaWVjZSA9IHNxdWFyZVZhbD8ucGllY2U7XG4gICAgICBpZiAoIXBpZWNlKSByZXR1cm47XG5cbiAgICAgIGJvYXJkTWFwLnNldChzcXVhcmUsIHtcbiAgICAgICAgLi4uc3F1YXJlVmFsLFxuICAgICAgICBwaWVjZTogeyAuLi5waWVjZSwgdHlwZTogcGllY2VUeXBlIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc2V0RW5QYXNzYW50OiAoY29sb3I6IENvbG9yLCBjdXJyZW50OiBTcXVhcmUpOiB2b2lkID0+IHtcbiAgICAgIGlmICghYm9hcmRNYXAuZ2V0KHNxdWFyZSkpIHJldHVybjtcblxuICAgICAgYm9hcmRNYXAuc2V0KHNxdWFyZSwge1xuICAgICAgICBwaWVjZTogbnVsbCxcbiAgICAgICAgZW5QYXNzYW50OiB7XG4gICAgICAgICAgY3VycmVudCAvKiBzcXVhcmUgcGF3biBpcyBvbiAqLyxcbiAgICAgICAgICBjb2xvclxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGdldCBwaWVjZSgpIHtcbiAgICAgIHJldHVybiBib2FyZE1hcC5nZXQoc3F1YXJlKT8ucGllY2U7XG4gICAgfSxcbiAgICBnZXRMZWdhbE1vdmVzOiAoY2hlY2tzID0gc3F1YXJlc0dpdmluZ0NoZWNrIHx8IFtdKTogTW92ZXMgPT4ge1xuICAgICAgY29uc3QgeyB0eXBlLCBjb2xvciB9ID0gYXQoc3F1YXJlLCBib2FyZE1hcCkucGllY2UgYXMgUGllY2VPYmo7XG5cbiAgICAgIHN3aXRjaCAoY2hlY2tzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICBpZiAodHlwZSAhPT0gJ2tpbmcnKSByZXR1cm4gW107XG4gICAgICAgICAgcmV0dXJuIGdldExlZ2FsTW92ZXMoc3F1YXJlLCBib2FyZE1hcCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgcmV0dXJuIGdldExlZ2FsTW92ZXNJbkNoZWNrKFxuICAgICAgICAgICAgb3JpZ2luLFxuICAgICAgICAgICAgYm9hcmRNYXAsXG4gICAgICAgICAgICBnZXQua2luZ1Bvc2l0aW9uKGNvbG9yKSBhcyBTcXVhcmUsXG4gICAgICAgICAgICBjaGVja3NbMF1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2tpbmcnKSB7XG4gICAgICAgICAgICBsZXQgbGVnYWxNb3ZlcyA9IGdldExlZ2FsTW92ZXMoc3F1YXJlLCBib2FyZE1hcCk7XG4gICAgICAgICAgICBpZiAoZ2V0LmNhbkNhc3RsZShjb2xvciwgJ2tpbmdzaWRlJykpXG4gICAgICAgICAgICAgIGxlZ2FsTW92ZXMgPSBbXG4gICAgICAgICAgICAgICAgLi4ubGVnYWxNb3ZlcyxcbiAgICAgICAgICAgICAgICAuLi5nZXQuY2FzdGxlU3F1YXJlcyhjb2xvcikua2luZ3NpZGVcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGlmIChnZXQuY2FuQ2FzdGxlKGNvbG9yLCAncXVlZW5zaWRlJykpXG4gICAgICAgICAgICAgIGxlZ2FsTW92ZXMgPSBbXG4gICAgICAgICAgICAgICAgLi4ubGVnYWxNb3ZlcyxcbiAgICAgICAgICAgICAgICAuLi5nZXQuY2FzdGxlU3F1YXJlcyhjb2xvcikucXVlZW5zaWRlXG4gICAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIHJldHVybiBsZWdhbE1vdmVzO1xuICAgICAgICAgIH0gZWxzZSByZXR1cm4gZ2V0TGVnYWxNb3ZlcyhzcXVhcmUsIGJvYXJkTWFwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgZnJvbSA9IChzMTogU3F1YXJlLCBib2FyZE1hcCA9IGJvYXJkKSA9PiAoe1xuICAgIHRvOiAoczI6IFNxdWFyZSk6IHZvaWQgPT4ge1xuICAgICAgY29uc3QgcGllY2UgPSBhdChzMSwgYm9hcmRNYXApLnBpZWNlO1xuICAgICAgaWYgKCFwaWVjZSkgcmV0dXJuO1xuXG4gICAgICAvLyBtb3ZlIHBpZWNlXG4gICAgICBhdChzMSwgYm9hcmRNYXApLnJlbW92ZSgpO1xuICAgICAgYXQoczIsIGJvYXJkTWFwKS5wbGFjZShwaWVjZSk7XG4gICAgfVxuICB9KTtcblxuICBjb25zdCBnZXQgPSB7XG4gICAga2luZ1Bvc2l0aW9uOiAoY29sb3I6IENvbG9yLCBib2FyZE1hcCA9IGJvYXJkKTogU3F1YXJlIHwgdW5kZWZpbmVkID0+IHtcbiAgICAgIGZvciAoY29uc3QgW3NxdWFyZSwgdmFsdWVdIG9mIGJvYXJkTWFwLmVudHJpZXMoKSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdmFsdWUucGllY2UgJiZcbiAgICAgICAgICB2YWx1ZS5waWVjZS50eXBlID09PSAna2luZycgJiZcbiAgICAgICAgICB2YWx1ZS5waWVjZS5jb2xvciA9PT0gY29sb3JcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiBzcXVhcmU7XG4gICAgICB9XG4gICAgfSxcbiAgICBwaWVjZU1hcDogKGJvYXJkTWFwID0gYm9hcmQpOiBBbGxQaWVjZU1hcCA9PiB7XG4gICAgICBjb25zdCBwaWVjZU1hcCA9IHsgd2hpdGU6IHt9IGFzIFBpZWNlTWFwLCBibGFjazoge30gYXMgUGllY2VNYXAgfTtcbiAgICAgIGZvciAoY29uc3QgW3NxdWFyZSwgdmFsdWVdIG9mIGJvYXJkTWFwLmVudHJpZXMoKSkge1xuICAgICAgICBjb25zdCB7IHBpZWNlIH0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKCFwaWVjZSkgY29udGludWU7XG5cbiAgICAgICAgY29uc3QgeyB0eXBlLCBjb2xvciB9ID0gcGllY2U7XG4gICAgICAgIHBpZWNlTWFwW2NvbG9yXVt0eXBlXSA9IHBpZWNlTWFwW2NvbG9yXVt0eXBlXVxuICAgICAgICAgID8gWy4uLnBpZWNlTWFwW2NvbG9yXVt0eXBlXSwgc3F1YXJlXVxuICAgICAgICAgIDogW3NxdWFyZV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcGllY2VNYXA7XG4gICAgfSxcbiAgICBwaWVjZXNUaGF0SGl0U3F1YXJlOiAoXG4gICAgICBjb2xvcjogQ29sb3IsXG4gICAgICBwaWVjZVR5cGU6IFBpZWNlVHlwZSxcbiAgICAgIHNxdWFyZTogU3F1YXJlLFxuICAgICAgYm9hcmRNYXAgPSBib2FyZFxuICAgICk6IFNxdWFyZVtdID0+IHtcbiAgICAgIGNvbnN0IHBpZWNlTWFwID0gZ2V0LnBpZWNlTWFwKGJvYXJkTWFwKTtcbiAgICAgIGlmIChwaWVjZU1hcFtjb2xvcl1bcGllY2VUeXBlXS5pbmNsdWRlcyhzcXVhcmUpKSByZXR1cm4gW107XG5cbiAgICAgIGNvbnN0IHBpZWNlczogU3F1YXJlW10gPSBbXTtcbiAgICAgIGlmIChwaWVjZU1hcFtjb2xvcl1bcGllY2VUeXBlXS5sZW5ndGggPD0gMSkgcmV0dXJuIFtdO1xuICAgICAgcGllY2VNYXBbY29sb3JdW3BpZWNlVHlwZV0uZm9yRWFjaCgocykgPT4ge1xuICAgICAgICBpZiAoYXQocywgYm9hcmRNYXApLmdldExlZ2FsTW92ZXMoKS5pbmNsdWRlcyhzcXVhcmUpKSBwaWVjZXMucHVzaChzKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHBpZWNlcztcbiAgICB9LFxuICAgIHNxdWFyZXNHaXZpbmdDaGVja0FmdGVyTW92ZTogKGZyb206IFNxdWFyZSwgZW5kOiBTcXVhcmUpOiBTcXVhcmVbXSA9PiB7XG4gICAgICBjb25zdCBzcXVhcmVzR2l2aW5nQ2hlY2s6IHN0cmluZ1tdID0gW107XG5cbiAgICAgIGNvbnN0IHBpZWNlID0gYm9hcmQuZ2V0KGVuZCk/LnBpZWNlIGFzIFBpZWNlT2JqO1xuICAgICAgY29uc3Qgb3BwQ29sb3IgPSBwaWVjZS5jb2xvciA9PT0gJ3doaXRlJyA/ICdibGFjaycgOiAnd2hpdGUnO1xuICAgICAgY29uc3Qga2luZ1Bvc2l0aW9uID0gZ2V0LmtpbmdQb3NpdGlvbihvcHBDb2xvcikgYXMgU3F1YXJlO1xuXG4gICAgICBjb25zdCBwaWVjZUhpdHNLaW5nID0gZ2V0TGVnYWxNb3ZlcyhlbmQsIGJvYXJkKS5pbmNsdWRlcyhraW5nUG9zaXRpb24pO1xuICAgICAgaWYgKHBpZWNlSGl0c0tpbmcpIHNxdWFyZXNHaXZpbmdDaGVjay5wdXNoKGVuZCk7XG5cbiAgICAgIGNvbnN0IGRpc2NvdmVyZWRDaGVjayA9IGdldERpc2NvdmVyZWRDaGVjayhcbiAgICAgICAga2luZ1Bvc2l0aW9uLFxuICAgICAgICBvcHBDb2xvcixcbiAgICAgICAgZnJvbSxcbiAgICAgICAgYm9hcmRcbiAgICAgICk7XG4gICAgICBpZiAoZGlzY292ZXJlZENoZWNrKSBzcXVhcmVzR2l2aW5nQ2hlY2sucHVzaChkaXNjb3ZlcmVkQ2hlY2spO1xuXG4gICAgICByZXR1cm4gc3F1YXJlc0dpdmluZ0NoZWNrO1xuICAgIH0sXG4gICAgaXNDaGVja21hdGU6IChcbiAgICAgIGNvbG9yT2ZLaW5nOiBDb2xvcixcbiAgICAgIHNxdWFyZXNHaXZpbmdDaGVjazogc3RyaW5nW10sXG4gICAgICBib2FyZE1hcCA9IGJvYXJkXG4gICAgKTogYm9vbGVhbiA9PiB7XG4gICAgICBjb25zdCBraW5nUG9zID0gZ2V0LmtpbmdQb3NpdGlvbihjb2xvck9mS2luZywgYm9hcmRNYXApIGFzIFNxdWFyZTtcbiAgICAgIGNvbnN0IGxlZ2FsTW92ZXMgPSBhdChraW5nUG9zLCBib2FyZE1hcCkuZ2V0TGVnYWxNb3ZlcygpO1xuICAgICAgLy8gY2hlY2sgaWYgY2hlY2sgY2FuIGJlIGJsb2NrZWRcbiAgICAgIGlmIChzcXVhcmVzR2l2aW5nQ2hlY2subGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmIChjYW5CbG9ja09yQ2FwdHVyZUNoZWNrKGtpbmdQb3MsIHNxdWFyZXNHaXZpbmdDaGVja1swXSwgYm9hcmRNYXApKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChsZWdhbE1vdmVzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBjYXN0bGVTcXVhcmVzKGNvbG9yOiBDb2xvcik6IENhc3RsZVNxdWFyZXNUeXBlIHtcbiAgICAgIGNvbnN0IHJhbmsgPSBjb2xvciA9PT0gJ3doaXRlJyA/IDEgOiA4O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2luZ3NpZGU6IFtgZiR7cmFua31gLCBgZyR7cmFua31gXSxcbiAgICAgICAgcXVlZW5zaWRlOiBbYGQke3Jhbmt9YCwgYGMke3Jhbmt9YF1cbiAgICAgIH07XG4gICAgfSxcbiAgICBjYXN0bGVTaWRlKGNvbG9yOiBDb2xvciwgdG86IFNxdWFyZSk6ICcnIHwgJ3F1ZWVuc2lkZScgfCAna2luZ3NpZGUnIHtcbiAgICAgIGxldCBjYXN0bGVTaWRlOiAnJyB8ICdxdWVlbnNpZGUnIHwgJ2tpbmdzaWRlJyA9ICcnO1xuICAgICAgY29uc3QgY2FzdGxlU3F1YXJlcyA9IGdldC5jYXN0bGVTcXVhcmVzKGNvbG9yKTtcblxuICAgICAgZm9yIChjb25zdCBbc2lkZSwgc3F1YXJlc10gb2YgT2JqZWN0LmVudHJpZXMoY2FzdGxlU3F1YXJlcykpIHtcbiAgICAgICAgaWYgKHNxdWFyZXNbMV0gPT09IHRvKSBjYXN0bGVTaWRlID0gc2lkZSBhcyAna2luZ3NpZGUnIHwgJ3F1ZWVuc2lkZSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FzdGxlU2lkZTtcbiAgICB9LFxuICAgIGNhc3RsZVJpZ2h0c0FmdGVyTW92ZTogKHNxdWFyZTogU3F1YXJlLCBib2FyZE1hcCA9IGJvYXJkKTogQ2FzdGxlT2JqID0+IHtcbiAgICAgIGNvbnN0IHBpZWNlID0gYXQoc3F1YXJlLCBib2FyZE1hcCkucGllY2UgYXMgUGllY2VPYmo7XG5cbiAgICAgIGNvbnN0IGNhc3RsZVJpZ2h0cyA9IENhc3RsZVJpZ2h0cyB8fCBDYXN0bGUodHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICAgIGlmIChcbiAgICAgICAgY2FzdGxlUmlnaHRzW3BpZWNlLmNvbG9yXS5raW5nc2lkZSB8fFxuICAgICAgICBjYXN0bGVSaWdodHNbcGllY2UuY29sb3JdLnF1ZWVuc2lkZVxuICAgICAgKSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIGkgbmVlZCB0byBjaGFuZ2UgY2FzdGxpbmcgcmlnaHRzXG4gICAgICAgIGlmIChwaWVjZS50eXBlID09PSAna2luZycpIHtcbiAgICAgICAgICBjYXN0bGVSaWdodHNbcGllY2UuY29sb3JdLmtpbmdzaWRlID0gZmFsc2U7XG4gICAgICAgICAgY2FzdGxlUmlnaHRzW3BpZWNlLmNvbG9yXS5xdWVlbnNpZGUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwaWVjZS50eXBlID09PSAncm9vaycpIHtcbiAgICAgICAgICAvLyBuZWVkIHRvIGZpbmQgaWYgaXQgaXMga2luZ3NpZGUgb3IgcXVlZW5zaWRlIHJvb2tcbiAgICAgICAgICBjb25zdCBbZmlsZV0gPSBzcXVhcmUuc3BsaXQoJycpO1xuICAgICAgICAgIGNvbnN0IGtpbmdzaWRlID0gZmlsZXMuaW5kZXhPZihmaWxlKSA+IDM7XG4gICAgICAgICAgaWYgKGtpbmdzaWRlKSBjYXN0bGVSaWdodHNbcGllY2UuY29sb3JdLmtpbmdzaWRlID0gZmFsc2U7XG4gICAgICAgICAgZWxzZSBjYXN0bGVSaWdodHNbcGllY2UuY29sb3JdLnF1ZWVuc2lkZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYXN0bGVSaWdodHM7XG4gICAgfSxcbiAgICBjYW5DYXN0bGU6IChcbiAgICAgIGNvbG9yOiBDb2xvcixcbiAgICAgIHNpZGU6ICdraW5nc2lkZScgfCAncXVlZW5zaWRlJyxcbiAgICAgIGJvYXJkTWFwID0gYm9hcmRcbiAgICApOiBib29sZWFuID0+IHtcbiAgICAgIGlmIChDYXN0bGVSaWdodHMgJiYgIUNhc3RsZVJpZ2h0c1tjb2xvcl1bc2lkZV0pIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gY2hlY2sgaWYgcm9vayBzdGlsbCBleGlzdHNcbiAgICAgIGlmICghY2hlY2tJZlJvb2tFeGlzdHMoKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBjb25zdCBvcHBDb2xvciA9IGNvbG9yID09PSAnd2hpdGUnID8gJ2JsYWNrJyA6ICd3aGl0ZSc7XG4gICAgICBjb25zdCBvcHBNb3ZlcyA9IGdldEF0dGFja2luZ01vdmVzRm9yQ29sb3Iob3BwQ29sb3IsIGJvYXJkTWFwKTtcblxuICAgICAgY29uc3QgY2FzdGxlU3F1YXJlcyA9IGdldC5jYXN0bGVTcXVhcmVzKGNvbG9yKVtzaWRlXTtcbiAgICAgIGZvciAoY29uc3Qgc3F1YXJlIG9mIGNhc3RsZVNxdWFyZXMpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgY2FzdGxlIHNxdWFyZSBpcyBjbGVhcmVkXG4gICAgICAgIGlmIChhdChzcXVhcmUsIGJvYXJkTWFwKS5waWVjZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBtYWtlIHN1cmUgY2FzdGxlIHNxdWFyZSBpc250IGF0dGFja2VkXG4gICAgICAgIGlmIChvcHBNb3Zlcy5pbmNsdWRlcyhzcXVhcmUpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICBmdW5jdGlvbiBjaGVja0lmUm9va0V4aXN0cygpOiBib29sZWFuIHtcbiAgICAgICAgbGV0IHJvb2tFeGlzdHMgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgcmFuayA9IGNvbG9yID09PSAnd2hpdGUnID8gMSA6IDg7XG4gICAgICAgIGNvbnN0IGxvb3BTdGFydCA9XG4gICAgICAgICAgc2lkZSA9PT0gJ3F1ZWVuc2lkZScgPyBmaWxlcy5pbmRleE9mKCdhJykgOiBmaWxlcy5pbmRleE9mKCdkJyk7XG4gICAgICAgIGNvbnN0IGxvb3BFbmQgPVxuICAgICAgICAgIHNpZGUgPT09ICdxdWVlbnNpZGUnID8gZmlsZXMuaW5kZXhPZignZScpIDogZmlsZXMuaW5kZXhPZignaCcpO1xuICAgICAgICBmb3IgKGxldCBpID0gbG9vcFN0YXJ0OyBpIDw9IGxvb3BFbmQ7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHNxdWFyZSA9IGZpbGVzW2ldICsgcmFuaztcblxuICAgICAgICAgIGNvbnN0IHBpZWNlID0gYXQoc3F1YXJlLCBib2FyZE1hcCkucGllY2U7XG4gICAgICAgICAgaWYgKCFwaWVjZSkgY29udGludWU7XG5cbiAgICAgICAgICBpZiAocGllY2UudHlwZSA9PT0gJ3Jvb2snKSByb29rRXhpc3RzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm9va0V4aXN0cztcbiAgICAgIH1cbiAgICB9LFxuICAgIGJvYXJkU3RhdGVGcm9tSGlzdG9yeTogKGhpc3Rvcnk6IEhpc3RvcnlUeXBlKTogQm9hcmRbXSA9PiB7XG4gICAgICBjb25zdCBib2FyZFN0YXRlczogQm9hcmRbXSA9IFtdO1xuXG4gICAgICBjb25zdCBib2FyZE1hcCA9IGNyZWF0ZUJvYXJkKCk7XG4gICAgICBwbGFjZVBpZWNlcyhzdGFydGluZ1Bvc2l0aW9ucy5zdGFuZGFyZCwgYm9hcmRNYXApO1xuICAgICAgbGV0IHBpZWNlTWFwID0gc3RhcnRpbmdQb3NpdGlvbnMuc3RhbmRhcmQ7XG5cbiAgICAgIC8vIGhpc3RvcnkgaXMgMmQgYXJyYXlcbiAgICAgIGNvbnN0IGZsYXQgPSBoaXN0b3J5LmZsYXQoKTtcblxuICAgICAgLyogaXRlcmF0ZSBvdmVyIGhpc3RvcnkgKi9cbiAgICAgIGZvciAoY29uc3QgW2ksIG1dIG9mIGZsYXQuZW50cmllcygpKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlTm90YXRpb24obSk7XG4gICAgICAgIGNvbnN0IGNvbG9yID0gaSAlIDIgPT09IDAgPyAnd2hpdGUnIDogJ2JsYWNrJztcblxuICAgICAgICBpZiAocGFyc2VkLmNhc3RsZSkge1xuICAgICAgICAgIGNhc3RsZShjb2xvciwgcGFyc2VkLmNhc3RsZSwgYm9hcmRNYXApO1xuICAgICAgICAgIHBpZWNlTWFwID0gZ2V0LnBpZWNlTWFwKGJvYXJkTWFwKTtcbiAgICAgICAgICBib2FyZFN0YXRlcy5wdXNoKG5ldyBNYXAoYm9hcmRNYXApKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBvc3NpYmxlUGllY2VzID0gcGllY2VNYXBbY29sb3JdW3BhcnNlZC5waWVjZVR5cGVdLmZpbHRlcigocykgPT5cbiAgICAgICAgICBnZXRMZWdhbE1vdmVzKHMsIGJvYXJkTWFwKS5pbmNsdWRlcyhwYXJzZWQudG8pXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gZ2V0ICdmcm9tJyBzcXVhcmVcbiAgICAgICAgbGV0IHMxOiBTcXVhcmU7XG4gICAgICAgIGlmIChwYXJzZWQuZnJvbSkge1xuICAgICAgICAgIGNvbnN0IG5vdGF0aW9uID0gcGFyc2VkLmZyb207XG4gICAgICAgICAgaWYgKG5vdGF0aW9uLmxlbmd0aCA9PT0gMikgczEgPSBub3RhdGlvbjtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHMxID1cbiAgICAgICAgICAgICAgcG9zc2libGVQaWVjZXMuZmluZCgocykgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGlmIG5vdGF0aW9uIGlzIGEgbnVtYmVyLCB0aGF0IG1lYW5zIHBpZWNlIGlzIG9uIHRoZSByYW5rID09PSBub3RhdGlvbiwgaWYgbm90LCBzYW1lIGZpbGVcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNOYU4oTnVtYmVyKG5vdGF0aW9uKSlcbiAgICAgICAgICAgICAgICAgID8gc1swXSA9PT0gbm90YXRpb25cbiAgICAgICAgICAgICAgICAgIDogc1sxXSA9PT0gbm90YXRpb247XG4gICAgICAgICAgICAgIH0pIHx8ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHMxID0gcG9zc2libGVQaWVjZXNbMF07XG5cbiAgICAgICAgY29uc3QgcGllY2UgPSBhdChzMSwgYm9hcmRNYXApLnBpZWNlO1xuICAgICAgICBpZiAoIXMxIHx8ICFwaWVjZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWFrZSBtb3ZlXG4gICAgICAgIGlmIChwaWVjZS50eXBlID09PSAncGF3bicpIHtcbiAgICAgICAgICBpZiAoZW5QYXNzYW50LmlzQ2FwdHVyZShzMSwgcGFyc2VkLnRvLCBib2FyZE1hcCkpIHtcbiAgICAgICAgICAgIGVuUGFzc2FudC5jYXB0dXJlKHBhcnNlZC50bywgYm9hcmRNYXApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVuUGFzc2FudC5yZW1vdmUoYm9hcmRNYXApO1xuXG4gICAgICAgICAgaWYgKGVuUGFzc2FudC5jaGVja1RvZ2dsZShzMSwgcGFyc2VkLnRvKSlcbiAgICAgICAgICAgIGVuUGFzc2FudC50b2dnbGUoY29sb3IsIHBhcnNlZC50bywgYm9hcmRNYXApO1xuXG4gICAgICAgICAgaWYgKHBhcnNlZC5wcm9tb3RlKSB7XG4gICAgICAgICAgICBhdChzMSwgYm9hcmRNYXApLnByb21vdGUocGFyc2VkLnByb21vdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGVuUGFzc2FudC5yZW1vdmUoYm9hcmRNYXApO1xuXG4gICAgICAgIGZyb20oczEsIGJvYXJkTWFwKS50byhwYXJzZWQudG8pO1xuICAgICAgICBwaWVjZU1hcCA9IGdldC5waWVjZU1hcChib2FyZE1hcCk7XG4gICAgICAgIGJvYXJkU3RhdGVzLnB1c2gobmV3IE1hcChib2FyZE1hcCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYm9hcmRTdGF0ZXM7XG4gICAgfSxcbiAgICBtb3ZlTm90YXRpb24oXG4gICAgICBmcm9tOiBTcXVhcmUsXG4gICAgICB0bzogU3F1YXJlLFxuICAgICAgcHJvbW90ZT86IFBpZWNlVHlwZSxcbiAgICAgIGNoZWNrPzogYm9vbGVhbixcbiAgICAgIGNoZWNrbWF0ZT86IGJvb2xlYW4sXG4gICAgICBib2FyZE1hcCA9IGJvYXJkXG4gICAgKTogc3RyaW5nIHtcbiAgICAgIGNvbnN0IG1vdmVEZXRhaWxzOiBNb3ZlRGV0YWlsc0ludGVyZmFjZSA9IHt9O1xuXG4gICAgICBjb25zdCB7IHR5cGUsIGNvbG9yIH0gPSBhdChmcm9tLCBib2FyZE1hcCkucGllY2UgYXMgUGllY2VPYmo7XG4gICAgICBtb3ZlRGV0YWlscy5waWVjZVR5cGUgPSB0eXBlO1xuXG4gICAgICBpZiAoY2hlY2ttYXRlKSBtb3ZlRGV0YWlscy5jaGVja21hdGUgPSBjaGVja21hdGU7XG4gICAgICBlbHNlIGlmIChjaGVjaykgbW92ZURldGFpbHMuY2hlY2sgPSBjaGVjaztcblxuICAgICAgbGV0IGNhcHR1cmUgPSBmYWxzZTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdwYXduJzoge1xuICAgICAgICAgIGNhcHR1cmUgPSBQaWVjZShjb2xvciwgdHlwZSlcbiAgICAgICAgICAgIC5nZXRQYXduQ2FwdHVyZXMoZnJvbSlcbiAgICAgICAgICAgID8uaW5jbHVkZXModG8pIGFzIGJvb2xlYW47XG4gICAgICAgICAgbW92ZURldGFpbHMuY2FwdHVyZSA9IGNhcHR1cmU7XG4gICAgICAgICAgaWYgKGNhcHR1cmUpIG1vdmVEZXRhaWxzLmRpZmZlcmVudGlhdGlvbiA9IGZyb21bMF07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGNhcHR1cmUgPSAhIWF0KHRvLCBib2FyZE1hcCkucGllY2U7XG4gICAgICAgICAgbW92ZURldGFpbHMuY2FwdHVyZSA9IGNhcHR1cmU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHByb21vdGUpIG1vdmVEZXRhaWxzLnByb21vdGUgPSBwcm9tb3RlO1xuXG4gICAgICAvLyBnZXQgZGlmZmVyZW50aWF0aW9uIGllLiB3aGVuIG11bHRpcGxlIHBpZWNlcyBoaXQgdGhlIHNhbWUgc3F1YXJlXG4gICAgICBjb25zdCBwaWVjZXNUaGF0SGl0U3F1YXJlID0gZ2V0LnBpZWNlc1RoYXRIaXRTcXVhcmUoXG4gICAgICAgIGNvbG9yLFxuICAgICAgICB0eXBlLFxuICAgICAgICB0byxcbiAgICAgICAgYm9hcmRNYXBcbiAgICAgICk7XG4gICAgICBzd2l0Y2ggKHBpZWNlc1RoYXRIaXRTcXVhcmUubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBtb3ZlRGV0YWlscy5kaWZmZXJlbnRpYXRpb24gPSBmcm9tO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAvLyBuZWVkIHRvIGZpbmQgaWYgb24gc2FtZSBmaWxlIG9yIHJhbmtcbiAgICAgICAgICBjb25zdCBvdGhlclBpZWNlID0gcGllY2VzVGhhdEhpdFNxdWFyZS5maW5kKFxuICAgICAgICAgICAgKHMpID0+IHMgIT09IGZyb21cbiAgICAgICAgICApIGFzIFNxdWFyZTtcbiAgICAgICAgICBtb3ZlRGV0YWlscy5kaWZmZXJlbnRpYXRpb24gPVxuICAgICAgICAgICAgb3RoZXJQaWVjZVswXSA9PT0gZnJvbVswXSA/IGZyb21bMV0gOiBmcm9tWzBdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtb3ZlTm90YXRpb24odG8pLmdldChtb3ZlRGV0YWlscyk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHZhbGlkYXRlID0ge1xuICAgIG1vdmU6IChmcm9tOiBTcXVhcmUsIHRvOiBTcXVhcmUsIGJvYXJkTWFwID0gYm9hcmQpOiBib29sZWFuID0+IHtcbiAgICAgIGNvbnN0IHBpZWNlID0gYXQoZnJvbSwgYm9hcmRNYXApLnBpZWNlO1xuICAgICAgaWYgKCFwaWVjZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBpZiAoIWF0KGZyb20sIGJvYXJkTWFwKS5nZXRMZWdhbE1vdmVzKCkuaW5jbHVkZXModG8pKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgcHJvbW90aW9uOiAoZnJvbTogU3F1YXJlLCB0bzogU3F1YXJlLCBib2FyZE1hcCA9IGJvYXJkKTogYm9vbGVhbiA9PiB7XG4gICAgICBjb25zdCBwaWVjZSA9IGF0KGZyb20sIGJvYXJkTWFwKS5waWVjZTtcblxuICAgICAgaWYgKHBpZWNlPy50eXBlICE9PSAncGF3bicpIHJldHVybiBmYWxzZTtcblxuICAgICAgY29uc3QgZW5kT2ZCb2FyZCA9IHBpZWNlLmNvbG9yID09PSAnd2hpdGUnID8gOCA6IDE7XG4gICAgICBjb25zdCBbLCByYW5rXSA9IHRvLnNwbGl0KCcnKTtcbiAgICAgIGlmICgrcmFuayAhPT0gZW5kT2ZCb2FyZCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBjcmVhdGVCb2FyZCxcbiAgICBwbGFjZVBpZWNlcyxcbiAgICBjYXN0bGUsXG4gICAgZW5QYXNzYW50LFxuICAgIGF0LFxuICAgIGZyb20sXG4gICAgZ2V0LFxuICAgIHZhbGlkYXRlLFxuICAgIG1ha2VNb3ZlLFxuICAgIGdldCBib2FyZCgpIHtcbiAgICAgIHJldHVybiBib2FyZDtcbiAgICB9XG4gIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBHYW1lYm9hcmQ7XG4iLCIvLyBzaG91bGQgb3V0cHV0IGhpc3Rvcnkgb2JqZWN0IHRoYXQgaG9sZHMgbW92ZSBoaXN0b3J5IGluIDJkIGFycmF5XG4vLyBmb3IgZWFjaCBtb3ZlIG5lZWRzIHRvIGF0dGFjaCBwaWVjZSBUeXBlIHRvIGJlZ2lubmluZyBvZiBtb3ZlIGlmIG5vdCBwYXduXG4vLyBzaG91bGQgZnVydGhlciBzcGVjaWZ5IHNxdWFyZSBvZiBwaWVjZSBpZiwgc2F5IGJvdGggcm9va3MsIGNhbiBtb3ZlIHRvIHNhbWUgc3F1YXJlXG5cbmltcG9ydCB7IEhpc3RvcnlPYmogfSBmcm9tICcuL3R5cGVzL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgSGlzdG9yeVR5cGUgfSBmcm9tICcuL3R5cGVzL3R5cGVzJztcbmltcG9ydCB7IGRlZXBDb3B5MmRBcnJheSB9IGZyb20gJy4vdXRpbHMvaGVscGVycyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhpc3RvcnkocHJldkhpc3Rvcnk6IEhpc3RvcnlUeXBlKTogSGlzdG9yeU9iaiB7XG4gIGNvbnN0IGhpc3Rvcnk6IEhpc3RvcnlUeXBlID0gZGVlcENvcHkyZEFycmF5KHByZXZIaXN0b3J5KSB8fCBbXTtcblxuICByZXR1cm4ge1xuICAgIGluc2VydE1vdmU6IChub3RhdGlvbjogc3RyaW5nKSA9PiB7XG4gICAgICBjb25zdCBsYXN0UGFpciA9IGhpc3RvcnlbaGlzdG9yeS5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChsYXN0UGFpciAmJiBsYXN0UGFpci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgbGFzdFBhaXIucHVzaChub3RhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBuZXdQYWlyID0gW25vdGF0aW9uXTtcbiAgICAgICAgaGlzdG9yeS5wdXNoKG5ld1BhaXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGlzdG9yeTtcbiAgICB9XG4gIH07XG59XG4iLCJpbXBvcnQgeyBBbGxQaWVjZU1hcCB9IGZyb20gJy4vdHlwZXMvaW50ZXJmYWNlcyc7XG5cbmNvbnN0IHN0YW5kYXJkOiBBbGxQaWVjZU1hcCA9IHtcbiAgd2hpdGU6IHtcbiAgICByb29rOiBbJ2ExJywgJ2gxJ10sXG4gICAga25pZ2h0OiBbJ2cxJywgJ2IxJ10sXG4gICAgYmlzaG9wOiBbJ2YxJywgJ2MxJ10sXG4gICAga2luZzogWydlMSddLFxuICAgIHF1ZWVuOiBbJ2QxJ10sXG4gICAgcGF3bjogWydhMicsICdiMicsICdjMicsICdkMicsICdlMicsICdmMicsICdnMicsICdoMiddXG4gIH0sXG4gIGJsYWNrOiB7XG4gICAgcm9vazogWydhOCcsICdoOCddLFxuICAgIGtuaWdodDogWydnOCcsICdiOCddLFxuICAgIGJpc2hvcDogWydmOCcsICdjOCddLFxuICAgIGtpbmc6IFsnZTgnXSxcbiAgICBxdWVlbjogWydkOCddLFxuICAgIHBhd246IFsnYTcnLCAnYjcnLCAnYzcnLCAnZDcnLCAnZTcnLCAnZjcnLCAnZzcnLCAnaDcnXVxuICB9XG59O1xuXG5leHBvcnQgeyBzdGFuZGFyZCB9O1xuIiwiaW1wb3J0IEdhbWVib2FyZCBmcm9tICcuL0dhbWVib2FyZCc7XG5pbXBvcnQgSGlzdG9yeSBmcm9tICcuL0hpc3RvcnknO1xuaW1wb3J0IENhc3RsZSBmcm9tICcuL0Nhc3RsZSc7XG5pbXBvcnQgKiBhcyBzdGFydGluZ1Bvc2l0aW9ucyBmcm9tICcuL3N0YXJ0aW5nUG9zaXRpb25zJztcbmltcG9ydCB7IHJhbmtzLCBmaWxlcyB9IGZyb20gJy4vcmFua3NBbmRGaWxlcyc7XG5cbmV4cG9ydCB7IEdhbWVib2FyZCwgSGlzdG9yeSwgQ2FzdGxlLCBzdGFydGluZ1Bvc2l0aW9ucywgcmFua3MsIGZpbGVzIH07XG4iXSwibmFtZXMiOlsidG9YWSIsInNxdWFyZSIsIngiLCJ5Iiwic3BsaXQiLCJpbmRleE9mIiwidG9Mb3dlckNhc2UiLCJOdW1iZXIiLCJmcm9tWFkiLCJjb29yZCIsImNvbCIsImNvbmNhdCIsInRvU3RyaW5nIiwiY2FsY0Rpc3RhbmNlIiwic3F1YXJlT25lIiwic3F1YXJlVHdvIiwieDEiLCJ5MSIsIngyIiwieTIiLCJ4RGlmZiIsInlEaWZmIiwiZ2V0UGllY2VGcm9tQWJiciIsImFiYnIiLCJwYXJzZU5vdGF0aW9uIiwibm90YXRpb24iLCJtb3ZlIiwicmVwbGFjZWQiLCJyZXBsYWNlIiwiY2FzdGxlIiwibGVuZ3RoIiwidG9VcHBlckNhc2UiLCJwaWVjZVR5cGUiLCJ0byIsInNsaWNlIiwiZnJvbSIsImluY2x1ZGVzIiwicHJvbW90ZSIsInByb21vdGVOb3RlSW5kZXgiLCJub1Byb21vdGVOb3RhdGlvbiIsImRlZXBDb3B5MmRBcnJheSIsImFyciIsIm1hcCIsIm4iLCJtb3ZlcyIsIlBpZWNlIiwiY29sb3IiLCJ0eXBlIiwiaGFzTW92ZSIsIm9uZVNxdWFyZVZlcnQiLCJ5QnlOIiwieEJ5TiIsIm9uZVNxdWFyZUxhdGVyYWwiLCJvbmVTcXVhcmVEaWFnb25hbGx5IiwiZGlhZ29uYWwiLCJ2ZXJ0QW5kTGF0ZXJhbCIsIm9ubHlNb3Zlc0luRnJvbnQiLCJyZWd1bGFyTW92ZSIsImZpcnN0TW92ZSIsImp1bXBUd28iLCJnZXRQYXduQ2FwdHVyZXMiLCJvcmlnaW4iLCJuZXdZIiwiY2FwdHVyZU9uZSIsImNhcHR1cmVUd28iLCJNYXRoIiwiYWJzIiwibnVtIiwic3BsaXRJbnRvVmVjdG9ycyIsImFycmF5T2ZNb3ZlcyIsInN0YXJ0IiwicmVkdWNlIiwiYWNjIiwiY3VyciIsInZlY3RvciIsImNoYXJBdCIsInB1c2giLCJnZXRCZWdpbm5pbmdPZlZlY3RvciIsImFjY0lzQmVnaW5uaW5nIiwiZ2V0TW92ZXNBbG9uZ1ZlY3RvciIsInMxIiwiczIiLCJhbGxTcXVhcmVzIiwibGllc1NhbWVWZXJ0T3JMYXQiLCJsaWVzU2FtZURpYWdvbmFsbHkiLCJsaWVzT25TYW1lTGluZSIsIm1hdGNoaW5nVmVjdG9yIiwic3F1YXJlc0Fsb25nVmVjdG9yIiwiZmlsdGVyIiwicyIsInNvcnRNb3Zlc0Nsb3Nlc3RUbyIsInNvcnQiLCJhIiwiYiIsIngxRGlmZiIsInkxRGlmZiIsImFEaWZmIiwieDJEaWZmIiwieTJEaWZmIiwiYkRpZmYiLCJnZXRQb3NzaWJsZU1vdmVzIiwiYm9hcmQiLCJBcnJheSIsImtleXMiLCJnZXQiLCJwaWVjZSIsImdldExlZ2FsTW92ZXMiLCJwb3NzaWJsZU1vdmVzIiwib2JzdHJ1Y3Rpb25zIiwiX2EiLCJsZWdhbE1vdmVzIiwiY2FwdHVyZXNBdmFpbGFibGUiLCJ1bm9ic3RydWN0ZWRNb3ZlcyIsInJlbW92ZU1vdmVzV2l0aFBpZWNlcyIsInJlbW92ZU9ic3RydWN0ZWRNb3ZlcyIsInJlbW92ZVByb3RlY3RlZFNxdWFyZXMiLCJnZXRMZWdhbE1vdmVzSW5DaGVjayIsImtpbmdQb3MiLCJzcXVhcmVHaXZpbmdDaGVjayIsInNxdWFyZXNUaGF0RGVhbFdpdGhDaGVjayIsImdldFNxdWFyZXNCZXR3ZWVuS2luZ0FuZENoZWNrIiwiZ2V0QXR0YWNraW5nTW92ZXMiLCJhdHRhY2tpbmdNb3ZlcyIsImdldEFsbE1vdmVzRm9yQ29sb3IiLCJza2lwS2luZyIsImFsbE1vdmVzIiwiZW50cmllcyIsImZsYXQiLCJnZXRBdHRhY2tpbmdNb3Zlc0ZvckNvbG9yIiwicGF3blNxdWFyZSIsInBhd24iLCJjYXB0dXJlTW92ZXMiLCJzcXVhcmVWYWwiLCJlblBhc3NhbnQiLCJjaGVja1BvcyIsInNxdWFyZXNCZXR3ZWVuS2luZ0FuZFBpZWNlIiwicmVtb3ZlTW92ZXNCZWhpbmRUd29TcXVhcmVzIiwic29ydGVkIiwiZnVydGhlc3RTcXVhcmUiLCJjbG9zZXN0U3F1YXJlIiwicmVtb3ZlZE9uZUVuZCIsInJlbW92ZU1vdmVzQmVoaW5kU3F1YXJlIiwicmVtb3ZlZEJvdGhFbmRzIiwicmV2ZXJzZSIsImNvcHkiLCJpbmRleCIsInNwbGljZSIsInN0YXJ0aW5nU3F1YXJlIiwiZmlsdGVyZWRNb3ZlcyIsImFsbFZlY3RvcnMiLCJvYnN0cnVjdGlvblZlY3RvcnMiLCJjbG9zZXN0T2JzdHJ1Y3Rpb24iLCJraW5nIiwib3BwQ29sb3IiLCJib2FyZENvcHkiLCJNYXAiLCJmb3JFYWNoIiwic2V0IiwiYWxsRW5lbXlNb3ZlcyIsImdldERpc2NvdmVyZWRDaGVjayIsImtpbmdDb2xvciIsInZhY2F0ZWQiLCJjYW5CbG9ja09yQ2FwdHVyZUNoZWNrIiwiYmxvY2tPckNhcHR1cmVTcXVhcmVzIiwib3duUGllY2VNb3ZlcyIsInNvbWUiLCJnZXRQaWVjZXNXaXRoTW92ZSIsInBpZWNlU3F1YXJlcyIsImZpbGVzIiwicmFua3MiLCJDYXN0bGUiLCJ3aGl0ZUtpbmdzaWRlIiwid2hpdGVRdWVlbnNpZGUiLCJibGFja0tpbmdzaWRlIiwiYmxhY2tRdWVlbnNpZGUiLCJ3aGl0ZSIsImtpbmdzaWRlIiwicXVlZW5zaWRlIiwiYmxhY2siLCJtb3ZlTm90YXRpb24iLCJzaWRlIiwiYWZmaXgiLCJwaWVjZU5vdGF0aW9uIiwiZGlmZmVyZW50aWF0aW9uIiwiY2FwdHVyZSIsInN1ZmZpeCIsImNoZWNrIiwiY2hlY2ttYXRlIiwibW92ZURldGFpbHMiLCJjYXN0bGVTaWRlIiwic3RhcnRpbmdQb3NpdGlvbnMiLCJjcmVhdGVCb2FyZCIsImZpbGUiLCJyYW5rIiwiR2FtZWJvYXJkIiwic3F1YXJlc0dpdmluZ0NoZWNrIiwiQ2FzdGxlUmlnaHRzIiwicGxhY2VQaWVjZXMiLCJwaWVjZU1hcCIsImJvYXJkTWFwIiwic3F1YXJlcyIsImF0IiwicGxhY2UiLCJtYWtlTW92ZSIsInZhbGlkYXRlIiwicHJvbW90aW9uIiwiaXNDYXB0dXJlIiwicmVtb3ZlIiwiY2hlY2tUb2dnbGUiLCJ0b2dnbGUiLCJjYXN0bGVTcXVhcmVzIiwia2luZ1Bvc2l0aW9uIiwicm9va1BvcyIsImdldFJvb2tQb3MiLCJyb29rIiwiZmluZCIsImdldFNxdWFyZSIsImN1cnJlbnQiLCJlblBhc3NhbnRTcXVhcmUiLCJzZXRFblBhc3NhbnQiLCJzcXVhcmVPYmoiLCJ2YWx1ZXMiLCJ1bmRlZmluZWQiLCJPYmplY3QiLCJjaGVja3MiLCJjYW5DYXN0bGUiLCJ2YWx1ZSIsInBpZWNlc1RoYXRIaXRTcXVhcmUiLCJwaWVjZXMiLCJzcXVhcmVzR2l2aW5nQ2hlY2tBZnRlck1vdmUiLCJlbmQiLCJwaWVjZUhpdHNLaW5nIiwiZGlzY292ZXJlZENoZWNrIiwiaXNDaGVja21hdGUiLCJjb2xvck9mS2luZyIsImNhc3RsZVJpZ2h0c0FmdGVyTW92ZSIsImNhc3RsZVJpZ2h0cyIsImNoZWNrSWZSb29rRXhpc3RzIiwib3BwTW92ZXMiLCJyb29rRXhpc3RzIiwibG9vcFN0YXJ0IiwibG9vcEVuZCIsImkiLCJib2FyZFN0YXRlRnJvbUhpc3RvcnkiLCJoaXN0b3J5IiwiYm9hcmRTdGF0ZXMiLCJzdGFuZGFyZCIsIm0iLCJwYXJzZWQiLCJwb3NzaWJsZVBpZWNlcyIsImlzTmFOIiwib3RoZXJQaWVjZSIsImVuZE9mQm9hcmQiLCJIaXN0b3J5IiwicHJldkhpc3RvcnkiLCJpbnNlcnRNb3ZlIiwibGFzdFBhaXIiLCJuZXdQYWlyIiwia25pZ2h0IiwiYmlzaG9wIiwicXVlZW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///327\n")}},__webpack_require__={d:(Q,F)=>{for(var B in F)__webpack_require__.o(F,B)&&!__webpack_require__.o(Q,B)&&Object.defineProperty(Q,B,{enumerable:!0,get:F[B]})},o:(Q,F)=>Object.prototype.hasOwnProperty.call(Q,F),r:Q=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})}},__webpack_exports__={};return __webpack_modules__[327](0,__webpack_exports__,__webpack_require__),__webpack_exports__})()));