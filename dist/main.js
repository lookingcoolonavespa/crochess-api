!function(Q,F){"object"==typeof exports&&"object"==typeof module?module.exports=F():"function"==typeof define&&define.amd?define([],F):"object"==typeof exports?exports.croChess=F():Q.croChess=F()}(this,(function(){return(()=>{"use strict";var __webpack_modules__={708:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"Castle\": () => (/* reexport */ Castle),\n  \"Gameboard\": () => (/* reexport */ src_Gameboard),\n  \"History\": () => (/* reexport */ History),\n  \"files\": () => (/* reexport */ files),\n  \"ranks\": () => (/* reexport */ ranks),\n  \"startingPositions\": () => (/* reexport */ startingPositions_namespaceObject)\n});\n\n// NAMESPACE OBJECT: ./src/startingPositions.ts\nvar startingPositions_namespaceObject = {};\n__webpack_require__.r(startingPositions_namespaceObject);\n__webpack_require__.d(startingPositions_namespaceObject, {\n  \"standard\": () => (standard)\n});\n\n;// CONCATENATED MODULE: ./src/utils/helpers.ts\nfunction toXY(square) {\n  const [x, y] = square.split('');\n  return {\n    x: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'].indexOf(x.toLowerCase()),\n    y: Number(y)\n  };\n}\n\nfunction fromXY(coord) {\n  const {\n    x,\n    y\n  } = coord;\n  const col = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'][x];\n  if (!col) return '';\n  return col.concat(y.toString());\n}\n\nconst calcDistance = squareOne => squareTwo => {\n  const {\n    x: x1,\n    y: y1\n  } = toXY(squareOne);\n  const {\n    x: x2,\n    y: y2\n  } = toXY(squareTwo);\n  const xDiff = x1 - x2;\n  const yDiff = y1 - y2;\n  return {\n    xDiff,\n    yDiff\n  };\n};\n\n\n;// CONCATENATED MODULE: ./src/Piece.ts\n\n\n\nconst Piece = (color, type) => {\n  function hasMove(from, to) {\n    switch (type) {\n      case 'king':\n        {\n          const oneSquareVert = utils_moves.yByN(1)(from)(to) && utils_moves.xByN(0)(from)(to);\n          const oneSquareLateral = utils_moves.xByN(1)(from)(to) && utils_moves.yByN(0)(from)(to);\n          const oneSquareDiagonally = utils_moves.yByN(1)(from)(to) && utils_moves.xByN(1)(from)(to);\n          return from !== to && (oneSquareDiagonally || oneSquareVert || oneSquareLateral);\n        }\n\n      case 'queen':\n        {\n          return from !== to && (utils_moves.diagonal(from)(to) || utils_moves.vertAndLateral(from)(to));\n        }\n\n      case 'bishop':\n        {\n          return from !== to && utils_moves.diagonal(from)(to);\n        }\n\n      case 'knight':\n        {\n          return from !== to && (utils_moves.xByN(1)(from)(to) && utils_moves.yByN(2)(from)(to) || utils_moves.xByN(2)(from)(to) && utils_moves.yByN(1)(from)(to));\n        }\n\n      case 'rook':\n        {\n          return from !== to && utils_moves.vertAndLateral(to)(from);\n        }\n\n      case 'pawn':\n        {\n          const {\n            x: x1,\n            y: y1\n          } = toXY(from);\n          const {\n            x: x2,\n            y: y2\n          } = toXY(to);\n          const onlyMovesInFront = color === 'white' ? y1 < y2 : y1 > y2;\n          const regularMove = utils_moves.yByN(1)(from)(to) && x1 === x2;\n          const firstMove = color === 'white' ? y1 === 2 : y1 === 7;\n          const jumpTwo = utils_moves.yByN(2)(from)(to) && x1 === x2;\n          return from !== to && onlyMovesInFront && (regularMove || firstMove && jumpTwo);\n        }\n    }\n  }\n\n  function getPawnCaptures(origin) {\n    if (type !== 'pawn') return;\n    const {\n      x,\n      y\n    } = toXY(origin);\n    const newY = color === 'white' ? y + 1 : y - 1;\n    const captureOne = {\n      x: x + 1,\n      y: newY\n    };\n    const captureTwo = {\n      x: x - 1,\n      y: newY\n    };\n    return [fromXY(captureOne), fromXY(captureTwo)];\n  }\n\n  return {\n    hasMove,\n    getPawnCaptures,\n\n    get type() {\n      return type;\n    },\n\n    get color() {\n      return color;\n    }\n\n  };\n};\n\n/* harmony default export */ const src_Piece = (Piece);\n;// CONCATENATED MODULE: ./src/utils/moves.ts\n\n\nconst moves = {\n  vertAndLateral: from => to => {\n    const [x1, y1] = from.split('');\n    const [x2, y2] = to.split('');\n    return x1 === x2 || y1 === y2;\n  },\n  diagonal: from => to => {\n    const {\n      x: x1,\n      y: y1\n    } = toXY(from);\n    const {\n      x: x2,\n      y: y2\n    } = toXY(to);\n    return Math.abs(x2 - x1) === Math.abs(y2 - y1);\n  },\n  xByN: num => from => to => {\n    const {\n      x: x1\n    } = toXY(from);\n    const {\n      x: x2\n    } = toXY(to);\n    return Math.abs(x1 - x2) === num;\n  },\n  yByN: num => from => to => {\n    const {\n      y: y1\n    } = toXY(from);\n    const {\n      y: y2\n    } = toXY(to);\n    return Math.abs(y1 - y2) === num;\n  }\n};\n/* harmony default export */ const utils_moves = (moves);\n/* dealing with move vectors */\n\nfunction splitIntoVectors(arrayOfMoves, start) {\n  return arrayOfMoves.reduce((acc, curr) => {\n    const {\n      xDiff,\n      yDiff\n    } = calcDistance(start)(curr);\n    let vector = '';\n    if (yDiff !== 0) vector = yDiff < 0 ? 'up' : 'down';\n    if (xDiff !== 0) vector += xDiff < 0 ? 'Right' : 'Left'; // normalize vector name\n\n    vector = vector.charAt(0).toLowerCase() + vector.slice(1);\n    acc[vector] = acc[vector] || [];\n    acc[vector].push(curr);\n    return acc;\n  }, {});\n}\n\nfunction getBeginningOfVector(vector) {\n  if (vector.length === 0) return '';\n  return vector.reduce((acc, curr) => {\n    const {\n      x: x1,\n      y: y1\n    } = toXY(acc);\n    const {\n      x: x2,\n      y: y2\n    } = toXY(curr);\n    const accIsBeginning = x1 === x2 ? y1 < y2 : x1 < x2;\n    return accIsBeginning ? acc : curr;\n  });\n}\n\nconst getMovesAlongVector = (s1, s2, allSquares) => {\n  const liesSameVertOrLat = moves.vertAndLateral(s1)(s2);\n  const liesSameDiagonally = moves.diagonal(s1)(s2);\n  const liesOnSameLine = liesSameVertOrLat || liesSameDiagonally;\n  if (!liesOnSameLine) return [];\n  const matchingVector = liesSameDiagonally ? 'diagonal' : 'vertAndLateral';\n  const squaresAlongVector = allSquares.filter(s => moves[matchingVector](s1)(s) && moves[matchingVector](s2)(s));\n  return squaresAlongVector;\n};\n/* sort moves */\n\n\nconst sortMovesClosestTo = square => moves => {\n  return [...moves].sort((a, b) => {\n    const {\n      xDiff: x1Diff,\n      yDiff: y1Diff\n    } = calcDistance(square)(a);\n    const aDiff = Math.abs(x1Diff) + Math.abs(y1Diff);\n    const {\n      xDiff: x2Diff,\n      yDiff: y2Diff\n    } = calcDistance(square)(b);\n    const bDiff = Math.abs(x2Diff) + Math.abs(y2Diff);\n    return aDiff - bDiff;\n  });\n};\n/* get moves */\n\n\nfunction getPossibleMoves(origin, board) {\n  // get all moves that can happen if no other pieces were on the board\n  const allSquares = Array.from(board.keys());\n  const square = board.get(origin);\n  const {\n    type,\n    color\n  } = square.piece;\n  const piece = src_Piece(color, type);\n  return allSquares.filter(s => piece.hasMove(origin, s));\n}\n\nfunction getLegalMoves(origin, board) {\n  // get moves regardless of whether or not there is check\n  const square = board.get(origin);\n  const piece = square.piece;\n  const possibleMoves = getPossibleMoves(origin, board);\n  const obstructions = possibleMoves.filter(s => {\n    var _a;\n\n    return (_a = board.get(s)) === null || _a === void 0 ? void 0 : _a.piece;\n  });\n\n  if (!obstructions.length) {\n    if (piece.type === 'pawn') return [...getPawnCaptures(origin, board), ...possibleMoves];\n    return possibleMoves;\n  }\n\n  let legalMoves = [];\n\n  switch (piece.type) {\n    case 'knight':\n      {\n        legalMoves = possibleMoves;\n        break;\n      }\n\n    case 'pawn':\n      {\n        const capturesAvailable = getPawnCaptures(origin, board);\n        const unobstructedMoves = removeMovesWithPieces(removeObstructedMoves(origin, possibleMoves, obstructions), board);\n        legalMoves = [...capturesAvailable, ...unobstructedMoves];\n        break;\n      }\n\n    case 'king':\n      {\n        legalMoves = removeProtectedSquares(origin, possibleMoves, board);\n        break;\n      }\n\n    default:\n      {\n        legalMoves = removeObstructedMoves(origin, possibleMoves, obstructions);\n      }\n  }\n\n  return removeMovesWithPieces(legalMoves, board, piece.color);\n}\n\nfunction getLegalMovesInCheck(origin, board, kingPos, squareGivingCheck) {\n  const squaresThatDealWithCheck = getSquaresBetweenKingAndCheck(kingPos, squareGivingCheck, Array.from(board.keys()));\n  const moves = getLegalMoves(origin, board);\n  return moves.filter(s => squaresThatDealWithCheck.includes(s));\n}\n\nfunction getAttackingMoves(origin, board) {\n  const square = board.get(origin);\n  const {\n    type,\n    color\n  } = square.piece;\n\n  switch (type) {\n    case 'pawn':\n      {\n        const piece = src_Piece(color, 'pawn');\n        return piece.getPawnCaptures(origin);\n      }\n\n    case 'king':\n      {\n        // need to do this because getLegalMoves will recursively call removeProtectedSquares otherwise\n        const attackingMoves = removeMovesWithPieces(getPossibleMoves(origin, board), board, color);\n        return attackingMoves;\n      }\n\n    default:\n      return getLegalMoves(origin, board);\n  }\n}\n\nfunction getAllMovesForColor(color, board, skipKing) {\n  const allMoves = [];\n\n  for (const [square, {\n    piece\n  }] of board.entries()) {\n    if (!piece) continue;\n    if (piece.color !== color) continue;\n    if (skipKing && piece.type === 'king') continue;\n    allMoves.push(getLegalMoves(square, board));\n  }\n\n  return allMoves.flat();\n}\n\nfunction getAttackingMovesForColor(color, board) {\n  const allMoves = [];\n\n  for (const [square, {\n    piece\n  }] of board.entries()) {\n    if (!piece) continue;\n    if (piece.color !== color) continue;\n    allMoves.push(getAttackingMoves(square, board));\n  }\n\n  return allMoves.flat();\n}\n\nfunction getPawnCaptures(pawnSquare, board) {\n  var _a;\n\n  const {\n    color\n  } = (_a = board.get(pawnSquare)) === null || _a === void 0 ? void 0 : _a.piece;\n  const pawn = src_Piece(color, 'pawn');\n  const captureMoves = pawn.getPawnCaptures(pawnSquare);\n  if (!captureMoves) return [];\n  return captureMoves.filter(s => {\n    const squareVal = board.get(s);\n    if (!squareVal) return false;\n    const piece = squareVal.piece;\n    const enPassant = squareVal.enPassant;\n    return piece && piece.color !== pawn.color || enPassant && enPassant.color !== pawn.color;\n  });\n}\n\nfunction getSquaresBetweenKingAndCheck(kingPos, checkPos, allSquares) {\n  // includes kingPos and checkPos\n  const squaresAlongVector = getMovesAlongVector(kingPos, checkPos, allSquares);\n  const squaresBetweenKingAndPiece = removeMovesBehindTwoSquares(kingPos, checkPos, squaresAlongVector);\n  return squaresBetweenKingAndPiece;\n}\n/* filter moves */\n\n\nfunction removeMovesBehindTwoSquares(s1, s2, vector) {\n  const sorted = sortMovesClosestTo(getBeginningOfVector(vector))(vector);\n  let furthestSquare;\n  let closestSquare;\n\n  if (sorted.indexOf(s1) > sorted.indexOf(s2)) {\n    furthestSquare = s1;\n    closestSquare = s2;\n  } else {\n    furthestSquare = s2;\n    closestSquare = s1;\n  }\n\n  const removedOneEnd = removeMovesBehindSquare(furthestSquare)(sorted);\n  const removedBothEnds = removeMovesBehindSquare(closestSquare)(removedOneEnd.reverse());\n  return removedBothEnds;\n}\n\nconst removeMovesBehindSquare = square => moves => {\n  const copy = [...moves];\n  const index = moves.indexOf(square);\n  if (index === -1) return [];\n  copy.splice(index + 1);\n  return copy;\n};\n\nfunction removeObstructedMoves(startingSquare, possibleMoves, obstructions) {\n  // a) split possible moves into vectors (up,down,left,right, and/or diagonals)\n  // b) see which obstructions belong to which vector\n  // c) find the closest obstruction\n  // d) remove all the moves behind that obstruction\n  const filteredMoves = [];\n  const allVectors = splitIntoVectors(possibleMoves, startingSquare);\n  const obstructionVectors = splitIntoVectors(obstructions, startingSquare);\n\n  for (const vector in allVectors) {\n    if (!obstructionVectors[vector]) {\n      // look for vector obstruction is on\n      filteredMoves.push(allVectors[vector]);\n      continue;\n    }\n\n    const sorted = sortMovesClosestTo(startingSquare)(allVectors[vector]);\n    const closestObstruction = sortMovesClosestTo(startingSquare)(obstructionVectors[vector])[0];\n    filteredMoves.push(removeMovesBehindSquare(closestObstruction)(sorted));\n  }\n\n  return filteredMoves.flat();\n}\n\nfunction removeProtectedSquares(kingPos, possibleMoves, board) {\n  var _a;\n\n  const king = (_a = board.get(kingPos)) === null || _a === void 0 ? void 0 : _a.piece; // bc king cant move if square is protected\n\n  const oppColor = king.color === 'white' ? 'black' : 'white';\n  const boardCopy = new Map(board);\n  possibleMoves.forEach(s => boardCopy.set(s, {\n    piece: king\n  }));\n  const allEnemyMoves = getAttackingMovesForColor(oppColor, boardCopy);\n  return possibleMoves.filter(s => {\n    return !allEnemyMoves.includes(s);\n  });\n}\n\nfunction removeMovesWithPieces(moves, board, color) {\n  return moves.filter(s => {\n    const squareVal = board.get(s);\n    if (!squareVal) return false;\n    if (color) return !squareVal.piece || squareVal.piece.color !== color;else return !squareVal.piece;\n  });\n}\n/* gameboard checks */\n\n\nfunction getDiscoveredCheck(kingPos, kingColor, vacated, board) {\n  var _a; // openSquare is a square just vacated\n\n\n  let squaresAlongVector = getMovesAlongVector(kingPos, vacated, Array.from(board.keys()));\n  squaresAlongVector = squaresAlongVector.filter(s => s !== kingPos && s !== vacated);\n  if (!squaresAlongVector.length) return '';\n\n  for (const square of squaresAlongVector) {\n    const piece = (_a = board.get(square)) === null || _a === void 0 ? void 0 : _a.piece;\n    if (!piece || piece.color === kingColor) continue;\n    const legalMoves = getLegalMoves(square, board);\n    if (legalMoves.includes(kingPos)) return square;\n  }\n\n  return '';\n}\n\nfunction canBlockOrCaptureCheck(kingPos, squareGivingCheck, board) {\n  var _a;\n\n  const king = (_a = board.get(kingPos)) === null || _a === void 0 ? void 0 : _a.piece;\n  const blockOrCaptureSquares = getSquaresBetweenKingAndCheck(kingPos, squareGivingCheck, Array.from(board.keys())); // also includes check square\n\n  const ownPieceMoves = getAllMovesForColor(king.color, board, true);\n  return ownPieceMoves.some(move => blockOrCaptureSquares.includes(move));\n}\n\n\n;// CONCATENATED MODULE: ./src/ranksAndFiles.ts\nconst files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];\nconst ranks = [1, 2, 3, 4, 5, 6, 7, 8];\n\n;// CONCATENATED MODULE: ./src/Castle.ts\nfunction Castle(whiteKingside, whiteQueenside, blackKingside, blackQueenside) {\n  return {\n    white: {\n      kingside: whiteKingside,\n      queenside: whiteQueenside\n    },\n    black: {\n      kingside: blackKingside,\n      queenside: blackQueenside\n    }\n  };\n}\n;// CONCATENATED MODULE: ./src/Gameboard.ts\n\n\n\n\n\nfunction createBoard() {\n  return files.reduce((acc, file) => {\n    ranks.forEach(rank => {\n      const square = file.concat(rank.toString());\n      acc.set(square, {\n        piece: null\n      });\n    });\n    return acc;\n  }, new Map());\n}\n\nconst Gameboard = (board = createBoard(), squaresGivingCheck, CastleRights) => {\n  function makeMove(s1, s2, promote) {\n    const piece = at(s1).piece; // validate move\n\n    if (!piece) return;\n    if (!validate.move(s1, s2)) return;\n    if (promote && !validate.promotion(s1, s2)) return;\n    enPassant.remove();\n\n    switch (piece.type) {\n      case 'pawn':\n        {\n          if (promote) {\n            at(s1).promote(promote);\n          }\n\n          if (enPassant.checkToggle(s1, s2)) {\n            enPassant.toggle(piece.color, s2);\n          }\n\n          from(s1).to(s2);\n          break;\n        }\n\n      case 'king':\n        {\n          // check if move is castle\n          let castleSide = '';\n          const castleSquares = get.castleSquares(piece.color);\n\n          for (const [side, squares] of Object.entries(castleSquares)) {\n            if (squares[1] === s2) castleSide = side;\n          }\n\n          if (castleSide) castling.castle(piece.color, castleSide);else from(s1).to(s2);\n          break;\n        }\n\n      default:\n        from(s1).to(s2);\n    }\n\n    return board;\n  }\n\n  const castling = {\n    canCastle: (color, side) => {\n      if (CastleRights && !CastleRights[color][side]) return false; // check if rook still exists\n\n      if (!checkIfRookExists()) return false;\n      const oppColor = color === 'white' ? 'black' : 'white';\n      const oppMoves = getAttackingMovesForColor(oppColor, board);\n      const castleSquares = get.castleSquares(color)[side];\n\n      for (const square of castleSquares) {\n        // check if castle square is cleared\n        if (at(square).piece) return false; // make sure castle square isnt attacked\n\n        if (oppMoves.includes(square)) return false;\n      }\n\n      return true;\n\n      function checkIfRookExists() {\n        let rookExists = false;\n        const rank = color === 'white' ? 1 : 8;\n        const loopStart = side === 'queenside' ? files.indexOf('a') : files.indexOf('d');\n        const loopEnd = side === 'queenside' ? files.indexOf('e') : files.indexOf('h');\n\n        for (let i = loopStart; i <= loopEnd; i++) {\n          const square = files[i] + rank;\n          const piece = at(square).piece;\n          if (!piece) continue;\n          if (piece.type === 'rook') rookExists = true;\n        }\n\n        return rookExists;\n      }\n    },\n    castle: (color, side) => {\n      const castleSquares = get.castleSquares(color)[side];\n      const kingPos = get.kingPosition(color);\n      const rookPos = getRookPos();\n      from(rookPos).to(castleSquares[0]);\n      from(kingPos).to(castleSquares[1]);\n\n      function getRookPos() {\n        const pieceMap = get.pieceMap();\n        const rookPos = pieceMap[color].rook.find(square => {\n          const file = square.split('')[0];\n          return side === 'kingside' ? files.indexOf(file) > 3 : files.indexOf(file) < 3;\n        });\n        return rookPos;\n      } // need to get king position\n      // need to get castle squares\n      // need to find rook\n\n    },\n    getRightsAfterMove: square => {\n      const piece = at(square).piece;\n      const castleRights = CastleRights || Castle(true, true, true, true);\n\n      if (castleRights[piece.color].kingside || castleRights[piece.color].queenside) {\n        // check if i need to change castling rights\n        if (piece.type === 'king') {\n          castleRights[piece.color].kingside = false;\n          castleRights[piece.color].queenside = false;\n        }\n\n        if (piece.type === 'rook') {\n          // need to find if it is kingside or queenside rook\n          const [file] = square.split('');\n          const kingside = files.indexOf(file) > 3;\n          if (kingside) castleRights[piece.color].kingside = false;else castleRights[piece.color].queenside = false;\n        }\n      }\n\n      return castleRights;\n    }\n  };\n\n  const enPassant = (() => {\n    function getSquare(current, color) {\n      const {\n        x,\n        y\n      } = toXY(current);\n      const newY = color === 'white' ? y - 1 : y + 1;\n      return fromXY({\n        x,\n        y: newY\n      });\n    }\n\n    return {\n      checkToggle: (from, to) => {\n        const {\n          y: y1\n        } = toXY(from);\n        const {\n          y: y2\n        } = toXY(to);\n        return Math.abs(y1 - y2) === 2;\n      },\n      toggle: (color, current) => {\n        const enPassantSquare = getSquare(current, color);\n        at(enPassantSquare).setEnPassant(color, current);\n      },\n      remove: () => {\n        for (const squareObj of board.values()) {\n          if (squareObj.enPassant) return squareObj.enPassant = undefined;\n        }\n      }\n    };\n  })();\n\n  const at = square => ({\n    place: piece => {\n      if (!board.get(square)) return;\n      board.set(square, {\n        piece\n      });\n    },\n    remove: () => {\n      if (!board.get(square)) return;\n      board.set(square, {\n        piece: null\n      });\n    },\n    promote: pieceType => {\n      const squareVal = board.get(square);\n      const piece = squareVal === null || squareVal === void 0 ? void 0 : squareVal.piece;\n      if (!piece) return;\n      board.set(square, Object.assign(Object.assign({}, squareVal), {\n        piece: Object.assign(Object.assign({}, piece), {\n          type: pieceType\n        })\n      }));\n    },\n    setEnPassant: (color, current) => {\n      if (!board.get(square)) return;\n      board.set(square, {\n        piece: null,\n        enPassant: {\n          current\n          /* square pawn is on */\n          ,\n          color\n        }\n      });\n    },\n\n    get piece() {\n      var _a;\n\n      return (_a = board.get(square)) === null || _a === void 0 ? void 0 : _a.piece;\n    },\n\n    getLegalMoves: () => {\n      squaresGivingCheck = squaresGivingCheck || [];\n      const {\n        type,\n        color\n      } = at(square).piece;\n\n      switch (squaresGivingCheck.length) {\n        case 2:\n          {\n            if (type !== 'king') return [];\n            return getLegalMoves(square, board);\n          }\n\n        case 1:\n          {\n            return getLegalMovesInCheck(origin, board, get.kingPosition(color), squaresGivingCheck[0]);\n          }\n\n        default:\n          {\n            if (type === 'king') {\n              let legalMoves = getLegalMoves(square, board);\n              if (castling.canCastle(color, 'kingside')) legalMoves = [...legalMoves, ...get.castleSquares(color).kingside];\n              if (castling.canCastle(color, 'queenside')) legalMoves = [...legalMoves, ...get.castleSquares(color).queenside];\n              return legalMoves;\n            } else return getLegalMoves(square, board);\n          }\n      }\n    }\n  });\n\n  const from = s1 => ({\n    to: s2 => {\n      const piece = at(s1).piece;\n      if (!piece) return; // move piece\n\n      at(s1).remove();\n      at(s2).place(piece);\n    }\n  });\n\n  const get = {\n    kingPosition: color => {\n      for (const [square, value] of board.entries()) {\n        if (value.piece && value.piece.type === 'king' && value.piece.color === color) return square;\n      }\n    },\n    pieceMap: () => {\n      const pieceMap = {\n        white: {},\n        black: {}\n      };\n\n      for (const [square, value] of board.entries()) {\n        const {\n          piece\n        } = value;\n        if (!piece) continue;\n        const {\n          type,\n          color\n        } = piece;\n        pieceMap[color][type] = pieceMap[color][type] ? [...pieceMap[color][type], square] : [square];\n      }\n\n      return pieceMap;\n    },\n    squaresGivingCheckAfterMove: (from, end) => {\n      var _a;\n\n      const squaresGivingCheck = [];\n      const piece = (_a = board.get(end)) === null || _a === void 0 ? void 0 : _a.piece;\n      const oppColor = piece.color === 'white' ? 'black' : 'white';\n      const kingPosition = get.kingPosition(oppColor);\n      const pieceHitsKing = getLegalMoves(end, board).includes(kingPosition);\n      if (pieceHitsKing) squaresGivingCheck.push(end);\n      const discoveredCheck = getDiscoveredCheck(kingPosition, oppColor, from, board);\n      if (discoveredCheck) squaresGivingCheck.push(discoveredCheck);\n      return squaresGivingCheck;\n    },\n    isCheckmate: (color, squaresGivingCheck) => {\n      const kingPos = get.kingPosition(color);\n      const legalMoves = at(kingPos).getLegalMoves(); // check if check can be blocked\n\n      if (squaresGivingCheck.length === 1) {\n        if (canBlockOrCaptureCheck(kingPos, squaresGivingCheck[0], board)) return false;\n      }\n\n      if (legalMoves.length) return false;\n      return true;\n    },\n\n    castleSquares(color) {\n      const rank = color === 'white' ? 1 : 8;\n      return {\n        kingside: [`f${rank}`, `g${rank}`],\n        queenside: [`d${rank}`, `c${rank}`]\n      };\n    }\n\n  };\n  const validate = {\n    move: (from, to) => {\n      const piece = at(from).piece;\n      if (!piece) return false;\n      if (!at(from).getLegalMoves().includes(to)) return false;\n      return true;\n    },\n    promotion: (from, to) => {\n      const piece = at(from).piece;\n      if ((piece === null || piece === void 0 ? void 0 : piece.type) !== 'pawn') return false;\n      const endOfBoard = piece.color === 'white' ? 8 : 1;\n      const [, rank] = to.split('');\n      if (+rank !== endOfBoard) return false;\n      return true;\n    }\n  };\n  return {\n    createBoard,\n    castling,\n    enPassant,\n    at,\n    from,\n    get,\n    validate,\n    makeMove,\n\n    get board() {\n      return board;\n    }\n\n  };\n};\n\n/* harmony default export */ const src_Gameboard = (Gameboard);\n;// CONCATENATED MODULE: ./src/History.ts\n// should output history object that holds move history in 2d array\n// for each move needs to attach piece Type to beginning of move if not pawn\n// should further specify square of piece if, say both rooks, can move to same square\n\nfunction History(prevHistory, board, pieceMap) {\n  const history = prevHistory || [];\n  const get = {\n    piecePrefix: (from, to) => {\n      var _a;\n\n      const {\n        type,\n        color\n      } = (_a = board.get(to)) === null || _a === void 0 ? void 0 : _a.piece;\n\n      switch (type) {\n        case 'pawn':\n          return '';\n\n        case 'knight':\n        case 'rook':\n          {\n            let prefix = type === 'rook' ? 'R' : 'N';\n\n            if (pieceMap[color][type].length !== 1) {\n              // look for piece of same type that couldve also went to the square\n              pieceMap[color][type].forEach(s => {\n                if (s === to) return;\n                const boardCopy = new Map(board);\n                boardCopy.set(to, {\n                  piece: null\n                });\n\n                if (getLegalMoves(s, boardCopy).includes(to)) {\n                  const [x1, y1] = from.split('');\n                  const [x2] = s.split('');\n                  const sameFile = x1 === x2;\n                  prefix = sameFile ? prefix + y1 : prefix + x1;\n                }\n              });\n            }\n\n            return prefix;\n          }\n\n        default:\n          {\n            const prefix = type.charAt(0).toUpperCase();\n            return prefix;\n          }\n      }\n    },\n    castleNotation: side => {\n      return side === 'kingside' ? 'O-O' : 'O-O-O';\n    }\n  };\n  const affix = {\n    capture: (move, prefix) => {\n      return `${prefix}x${move}`;\n    },\n    promote: (move, pieceType) => {\n      const suffix = pieceType === 'knight' ? 'N' : pieceType.charAt(0).toUpperCase();\n      return `${move}=${suffix}`;\n    },\n    check: notation => {\n      return `${notation}+`;\n    },\n    checkmate: notation => {\n      return `${notation}#`;\n    }\n  };\n  return {\n    get,\n    affix,\n    insertMove: notation => {\n      const lastMovePair = history[history.length - 1];\n\n      if (lastMovePair.length === 1) {\n        lastMovePair.push(notation);\n      } else {\n        const newMovePair = [notation];\n        history.push(newMovePair);\n      }\n    }\n  };\n}\n;// CONCATENATED MODULE: ./src/startingPositions.ts\nconst standard = {\n  white: {\n    rook: ['a1', 'h1'],\n    knight: ['g1', 'b1'],\n    bishop: ['f1', 'c1'],\n    king: ['e1'],\n    queen: ['d1'],\n    pawn: ['a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2']\n  },\n  black: {\n    rook: ['a8', 'h8'],\n    knight: ['g8', 'b8'],\n    bishop: ['f8', 'c8'],\n    king: ['e8'],\n    queen: ['d8'],\n    pawn: ['a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7']\n  }\n};\n\n;// CONCATENATED MODULE: ./src/main.ts\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SCxRQUFJLEVBQUUsQ0FBQyxJQUFELEVBQU8sSUFBUCxFQUFhLElBQWIsRUFBbUIsSUFBbkIsRUFBeUIsSUFBekIsRUFBK0IsSUFBL0IsRUFBcUMsSUFBckMsRUFBMkMsSUFBM0M7QUFORDtBQVRxQixDQUE5Qjs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Nyb0NoZXNzLy4vc3JjL3V0aWxzL2hlbHBlcnMudHM/MjhmMyIsIndlYnBhY2s6Ly9jcm9DaGVzcy8uL3NyYy9QaWVjZS50cz8yZWI4Iiwid2VicGFjazovL2Nyb0NoZXNzLy4vc3JjL3V0aWxzL21vdmVzLnRzPzUwZmIiLCJ3ZWJwYWNrOi8vY3JvQ2hlc3MvLi9zcmMvcmFua3NBbmRGaWxlcy50cz9lNjIxIiwid2VicGFjazovL2Nyb0NoZXNzLy4vc3JjL0Nhc3RsZS50cz8xY2VhIiwid2VicGFjazovL2Nyb0NoZXNzLy4vc3JjL0dhbWVib2FyZC50cz81N2UzIiwid2VicGFjazovL2Nyb0NoZXNzLy4vc3JjL0hpc3RvcnkudHM/NGMyMSIsIndlYnBhY2s6Ly9jcm9DaGVzcy8uL3NyYy9zdGFydGluZ1Bvc2l0aW9ucy50cz8zYmJjIiwid2VicGFjazovL2Nyb0NoZXNzLy4vc3JjL21haW4udHM/Y2Q0OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb29yZCB9IGZyb20gJy4uL3R5cGVzL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgU3F1YXJlIH0gZnJvbSAnLi4vdHlwZXMvdHlwZXMnO1xuXG5mdW5jdGlvbiB0b1hZKHNxdWFyZTogU3F1YXJlKTogQ29vcmQge1xuICBjb25zdCBbeCwgeV0gPSBzcXVhcmUuc3BsaXQoJycpO1xuICByZXR1cm4ge1xuICAgIHg6IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJywgJ2YnLCAnZycsICdoJ10uaW5kZXhPZih4LnRvTG93ZXJDYXNlKCkpLFxuICAgIHk6IE51bWJlcih5KVxuICB9O1xufVxuXG5mdW5jdGlvbiBmcm9tWFkoY29vcmQ6IENvb3JkKTogU3F1YXJlIHtcbiAgY29uc3QgeyB4LCB5IH0gPSBjb29yZDtcbiAgY29uc3QgY29sID0gWydhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJywgJ2gnXVt4XTtcbiAgaWYgKCFjb2wpIHJldHVybiAnJztcbiAgcmV0dXJuIGNvbC5jb25jYXQoeS50b1N0cmluZygpKTtcbn1cblxuY29uc3QgY2FsY0Rpc3RhbmNlID0gKHNxdWFyZU9uZTogc3RyaW5nKSA9PiAoc3F1YXJlVHdvOiBzdHJpbmcpID0+IHtcbiAgY29uc3QgeyB4OiB4MSwgeTogeTEgfSA9IHRvWFkoc3F1YXJlT25lKTtcbiAgY29uc3QgeyB4OiB4MiwgeTogeTIgfSA9IHRvWFkoc3F1YXJlVHdvKTtcblxuICBjb25zdCB4RGlmZiA9IHgxIC0geDI7XG4gIGNvbnN0IHlEaWZmID0geTEgLSB5MjtcbiAgcmV0dXJuIHtcbiAgICB4RGlmZixcbiAgICB5RGlmZlxuICB9O1xufTtcblxuZXhwb3J0IHsgdG9YWSwgZnJvbVhZLCBjYWxjRGlzdGFuY2UgfTtcbiIsImltcG9ydCBtb3ZlcyBmcm9tICcuL3V0aWxzL21vdmVzJztcbmltcG9ydCB7IHRvWFksIGZyb21YWSB9IGZyb20gJy4vdXRpbHMvaGVscGVycyc7XG5cbmltcG9ydCB7IENvbG9yLCBTcXVhcmUsIFBpZWNlVHlwZSB9IGZyb20gJy4vdHlwZXMvdHlwZXMnO1xuXG5jb25zdCBQaWVjZSA9IChjb2xvcjogQ29sb3IsIHR5cGU6IFBpZWNlVHlwZSkgPT4ge1xuICBmdW5jdGlvbiBoYXNNb3ZlKGZyb206IFNxdWFyZSwgdG86IFNxdWFyZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAna2luZyc6IHtcbiAgICAgICAgY29uc3Qgb25lU3F1YXJlVmVydCA9XG4gICAgICAgICAgbW92ZXMueUJ5TigxKShmcm9tKSh0bykgJiYgbW92ZXMueEJ5TigwKShmcm9tKSh0byk7XG4gICAgICAgIGNvbnN0IG9uZVNxdWFyZUxhdGVyYWwgPVxuICAgICAgICAgIG1vdmVzLnhCeU4oMSkoZnJvbSkodG8pICYmIG1vdmVzLnlCeU4oMCkoZnJvbSkodG8pO1xuICAgICAgICBjb25zdCBvbmVTcXVhcmVEaWFnb25hbGx5ID1cbiAgICAgICAgICBtb3Zlcy55QnlOKDEpKGZyb20pKHRvKSAmJiBtb3Zlcy54QnlOKDEpKGZyb20pKHRvKTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGZyb20gIT09IHRvICYmXG4gICAgICAgICAgKG9uZVNxdWFyZURpYWdvbmFsbHkgfHwgb25lU3F1YXJlVmVydCB8fCBvbmVTcXVhcmVMYXRlcmFsKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2FzZSAncXVlZW4nOiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgZnJvbSAhPT0gdG8gJiZcbiAgICAgICAgICAobW92ZXMuZGlhZ29uYWwoZnJvbSkodG8pIHx8IG1vdmVzLnZlcnRBbmRMYXRlcmFsKGZyb20pKHRvKSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2Jpc2hvcCc6IHtcbiAgICAgICAgcmV0dXJuIGZyb20gIT09IHRvICYmIG1vdmVzLmRpYWdvbmFsKGZyb20pKHRvKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2tuaWdodCc6IHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBmcm9tICE9PSB0byAmJlxuICAgICAgICAgICgobW92ZXMueEJ5TigxKShmcm9tKSh0bykgJiYgbW92ZXMueUJ5TigyKShmcm9tKSh0bykpIHx8XG4gICAgICAgICAgICAobW92ZXMueEJ5TigyKShmcm9tKSh0bykgJiYgbW92ZXMueUJ5TigxKShmcm9tKSh0bykpKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2FzZSAncm9vayc6IHtcbiAgICAgICAgcmV0dXJuIGZyb20gIT09IHRvICYmIG1vdmVzLnZlcnRBbmRMYXRlcmFsKHRvKShmcm9tKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ3Bhd24nOiB7XG4gICAgICAgIGNvbnN0IHsgeDogeDEsIHk6IHkxIH0gPSB0b1hZKGZyb20pO1xuICAgICAgICBjb25zdCB7IHg6IHgyLCB5OiB5MiB9ID0gdG9YWSh0byk7XG5cbiAgICAgICAgY29uc3Qgb25seU1vdmVzSW5Gcm9udCA9IGNvbG9yID09PSAnd2hpdGUnID8geTEgPCB5MiA6IHkxID4geTI7XG4gICAgICAgIGNvbnN0IHJlZ3VsYXJNb3ZlID0gbW92ZXMueUJ5TigxKShmcm9tKSh0bykgJiYgeDEgPT09IHgyO1xuXG4gICAgICAgIGNvbnN0IGZpcnN0TW92ZSA9IGNvbG9yID09PSAnd2hpdGUnID8geTEgPT09IDIgOiB5MSA9PT0gNztcbiAgICAgICAgY29uc3QganVtcFR3byA9IG1vdmVzLnlCeU4oMikoZnJvbSkodG8pICYmIHgxID09PSB4MjtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGZyb20gIT09IHRvICYmXG4gICAgICAgICAgb25seU1vdmVzSW5Gcm9udCAmJlxuICAgICAgICAgIChyZWd1bGFyTW92ZSB8fCAoZmlyc3RNb3ZlICYmIGp1bXBUd28pKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFBhd25DYXB0dXJlcyhvcmlnaW46IFNxdWFyZSkge1xuICAgIGlmICh0eXBlICE9PSAncGF3bicpIHJldHVybjtcblxuICAgIGNvbnN0IHsgeCwgeSB9ID0gdG9YWShvcmlnaW4pO1xuXG4gICAgY29uc3QgbmV3WSA9IGNvbG9yID09PSAnd2hpdGUnID8geSArIDEgOiB5IC0gMTtcblxuICAgIGNvbnN0IGNhcHR1cmVPbmUgPSB7IHg6IHggKyAxLCB5OiBuZXdZIH07XG4gICAgY29uc3QgY2FwdHVyZVR3byA9IHsgeDogeCAtIDEsIHk6IG5ld1kgfTtcblxuICAgIHJldHVybiBbZnJvbVhZKGNhcHR1cmVPbmUpLCBmcm9tWFkoY2FwdHVyZVR3byldO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBoYXNNb3ZlLFxuICAgIGdldFBhd25DYXB0dXJlcyxcbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH0sXG4gICAgZ2V0IGNvbG9yKCkge1xuICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFBpZWNlO1xuIiwiaW1wb3J0IHsgY2FsY0Rpc3RhbmNlLCB0b1hZIH0gZnJvbSAnLi9oZWxwZXJzJztcbmltcG9ydCB7XG4gIFBpZWNlSW50ZXJmYWNlLFxuICBTcXVhcmVPYmosXG4gIFBpZWNlT2JqLFxuICBFblBhc3NhbnRPYmpcbn0gZnJvbSAnLi4vdHlwZXMvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBNb3ZlcywgQm9hcmQsIFNxdWFyZSwgQ29sb3IgfSBmcm9tICcuLi90eXBlcy90eXBlcyc7XG5pbXBvcnQgUGllY2UgZnJvbSAnLi4vUGllY2UnO1xuXG5jb25zdCBtb3ZlcyA9IHtcbiAgdmVydEFuZExhdGVyYWw6IChmcm9tOiBTcXVhcmUpID0+ICh0bzogU3F1YXJlKSA9PiB7XG4gICAgY29uc3QgW3gxLCB5MV0gPSBmcm9tLnNwbGl0KCcnKTtcbiAgICBjb25zdCBbeDIsIHkyXSA9IHRvLnNwbGl0KCcnKTtcbiAgICByZXR1cm4geDEgPT09IHgyIHx8IHkxID09PSB5MjtcbiAgfSxcbiAgZGlhZ29uYWw6IChmcm9tOiBTcXVhcmUpID0+ICh0bzogU3F1YXJlKSA9PiB7XG4gICAgY29uc3QgeyB4OiB4MSwgeTogeTEgfSA9IHRvWFkoZnJvbSk7XG4gICAgY29uc3QgeyB4OiB4MiwgeTogeTIgfSA9IHRvWFkodG8pO1xuICAgIHJldHVybiBNYXRoLmFicyh4MiAtIHgxKSA9PT0gTWF0aC5hYnMoeTIgLSB5MSk7XG4gIH0sXG4gIHhCeU46IChudW06IG51bWJlcikgPT4gKGZyb206IFNxdWFyZSkgPT4gKHRvOiBTcXVhcmUpID0+IHtcbiAgICBjb25zdCB7IHg6IHgxIH0gPSB0b1hZKGZyb20pO1xuICAgIGNvbnN0IHsgeDogeDIgfSA9IHRvWFkodG8pO1xuICAgIHJldHVybiBNYXRoLmFicyh4MSAtIHgyKSA9PT0gbnVtO1xuICB9LFxuICB5QnlOOiAobnVtOiBudW1iZXIpID0+IChmcm9tOiBTcXVhcmUpID0+ICh0bzogU3F1YXJlKSA9PiB7XG4gICAgY29uc3QgeyB5OiB5MSB9ID0gdG9YWShmcm9tKTtcbiAgICBjb25zdCB7IHk6IHkyIH0gPSB0b1hZKHRvKTtcbiAgICByZXR1cm4gTWF0aC5hYnMoeTEgLSB5MikgPT09IG51bTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgbW92ZXM7XG5cbi8qIGRlYWxpbmcgd2l0aCBtb3ZlIHZlY3RvcnMgKi9cblxuZnVuY3Rpb24gc3BsaXRJbnRvVmVjdG9ycyhhcnJheU9mTW92ZXM6IE1vdmVzLCBzdGFydDogU3F1YXJlKSB7XG4gIGludGVyZmFjZSBWZWN0b3JzIHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmdbXTtcbiAgfVxuICByZXR1cm4gYXJyYXlPZk1vdmVzLnJlZHVjZSgoYWNjOiBWZWN0b3JzLCBjdXJyOiBTcXVhcmUpID0+IHtcbiAgICBjb25zdCB7IHhEaWZmLCB5RGlmZiB9ID0gY2FsY0Rpc3RhbmNlKHN0YXJ0KShjdXJyKTtcblxuICAgIGxldCB2ZWN0b3IgPSAnJztcbiAgICBpZiAoeURpZmYgIT09IDApIHZlY3RvciA9IHlEaWZmIDwgMCA/ICd1cCcgOiAnZG93bic7XG4gICAgaWYgKHhEaWZmICE9PSAwKSB2ZWN0b3IgKz0geERpZmYgPCAwID8gJ1JpZ2h0JyA6ICdMZWZ0JztcblxuICAgIC8vIG5vcm1hbGl6ZSB2ZWN0b3IgbmFtZVxuICAgIHZlY3RvciA9IHZlY3Rvci5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIHZlY3Rvci5zbGljZSgxKTtcblxuICAgIGFjY1t2ZWN0b3JdID0gYWNjW3ZlY3Rvcl0gfHwgW107XG4gICAgYWNjW3ZlY3Rvcl0ucHVzaChjdXJyKTtcblxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gZ2V0QmVnaW5uaW5nT2ZWZWN0b3IodmVjdG9yOiBNb3Zlcykge1xuICBpZiAodmVjdG9yLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuXG4gIHJldHVybiB2ZWN0b3IucmVkdWNlKChhY2MsIGN1cnIpID0+IHtcbiAgICBjb25zdCB7IHg6IHgxLCB5OiB5MSB9ID0gdG9YWShhY2MpO1xuICAgIGNvbnN0IHsgeDogeDIsIHk6IHkyIH0gPSB0b1hZKGN1cnIpO1xuXG4gICAgY29uc3QgYWNjSXNCZWdpbm5pbmcgPSB4MSA9PT0geDIgPyB5MSA8IHkyIDogeDEgPCB4MjtcbiAgICByZXR1cm4gYWNjSXNCZWdpbm5pbmcgPyBhY2MgOiBjdXJyO1xuICB9KTtcbn1cblxuY29uc3QgZ2V0TW92ZXNBbG9uZ1ZlY3RvciA9IChcbiAgczE6IFNxdWFyZSxcbiAgczI6IFNxdWFyZSxcbiAgYWxsU3F1YXJlczogTW92ZXNcbik6IE1vdmVzID0+IHtcbiAgY29uc3QgbGllc1NhbWVWZXJ0T3JMYXQgPSBtb3Zlcy52ZXJ0QW5kTGF0ZXJhbChzMSkoczIpO1xuICBjb25zdCBsaWVzU2FtZURpYWdvbmFsbHkgPSBtb3Zlcy5kaWFnb25hbChzMSkoczIpO1xuXG4gIGNvbnN0IGxpZXNPblNhbWVMaW5lID0gbGllc1NhbWVWZXJ0T3JMYXQgfHwgbGllc1NhbWVEaWFnb25hbGx5O1xuICBpZiAoIWxpZXNPblNhbWVMaW5lKSByZXR1cm4gW107XG5cbiAgY29uc3QgbWF0Y2hpbmdWZWN0b3IgPSBsaWVzU2FtZURpYWdvbmFsbHkgPyAnZGlhZ29uYWwnIDogJ3ZlcnRBbmRMYXRlcmFsJztcblxuICBjb25zdCBzcXVhcmVzQWxvbmdWZWN0b3IgPSBhbGxTcXVhcmVzLmZpbHRlcihcbiAgICAocykgPT4gbW92ZXNbbWF0Y2hpbmdWZWN0b3JdKHMxKShzKSAmJiBtb3Zlc1ttYXRjaGluZ1ZlY3Rvcl0oczIpKHMpXG4gICk7XG4gIHJldHVybiBzcXVhcmVzQWxvbmdWZWN0b3I7XG59O1xuXG4vKiBzb3J0IG1vdmVzICovXG5cbmNvbnN0IHNvcnRNb3Zlc0Nsb3Nlc3RUbyA9XG4gIChzcXVhcmU6IFNxdWFyZSkgPT5cbiAgKG1vdmVzOiBNb3Zlcyk6IE1vdmVzID0+IHtcbiAgICByZXR1cm4gWy4uLm1vdmVzXS5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBjb25zdCB7IHhEaWZmOiB4MURpZmYsIHlEaWZmOiB5MURpZmYgfSA9IGNhbGNEaXN0YW5jZShzcXVhcmUpKGEpO1xuICAgICAgY29uc3QgYURpZmYgPSBNYXRoLmFicyh4MURpZmYpICsgTWF0aC5hYnMoeTFEaWZmKTtcblxuICAgICAgY29uc3QgeyB4RGlmZjogeDJEaWZmLCB5RGlmZjogeTJEaWZmIH0gPSBjYWxjRGlzdGFuY2Uoc3F1YXJlKShiKTtcbiAgICAgIGNvbnN0IGJEaWZmID0gTWF0aC5hYnMoeDJEaWZmKSArIE1hdGguYWJzKHkyRGlmZik7XG5cbiAgICAgIHJldHVybiBhRGlmZiAtIGJEaWZmO1xuICAgIH0pO1xuICB9O1xuXG4vKiBnZXQgbW92ZXMgKi9cblxuZnVuY3Rpb24gZ2V0UG9zc2libGVNb3ZlcyhvcmlnaW46IFNxdWFyZSwgYm9hcmQ6IEJvYXJkKSB7XG4gIC8vIGdldCBhbGwgbW92ZXMgdGhhdCBjYW4gaGFwcGVuIGlmIG5vIG90aGVyIHBpZWNlcyB3ZXJlIG9uIHRoZSBib2FyZFxuICBjb25zdCBhbGxTcXVhcmVzID0gQXJyYXkuZnJvbShib2FyZC5rZXlzKCkpO1xuXG4gIGNvbnN0IHNxdWFyZSA9IGJvYXJkLmdldChvcmlnaW4pIGFzIFNxdWFyZU9iajtcblxuICBjb25zdCB7IHR5cGUsIGNvbG9yIH0gPSBzcXVhcmUucGllY2UgYXMgUGllY2VPYmo7XG4gIGNvbnN0IHBpZWNlID0gUGllY2UoY29sb3IsIHR5cGUpO1xuXG4gIHJldHVybiBhbGxTcXVhcmVzLmZpbHRlcigocykgPT4gcGllY2UuaGFzTW92ZShvcmlnaW4sIHMpKTtcbn1cblxuZnVuY3Rpb24gZ2V0TGVnYWxNb3ZlcyhvcmlnaW46IFNxdWFyZSwgYm9hcmQ6IEJvYXJkKSB7XG4gIC8vIGdldCBtb3ZlcyByZWdhcmRsZXNzIG9mIHdoZXRoZXIgb3Igbm90IHRoZXJlIGlzIGNoZWNrXG5cbiAgY29uc3Qgc3F1YXJlID0gYm9hcmQuZ2V0KG9yaWdpbikgYXMgU3F1YXJlT2JqO1xuXG4gIGNvbnN0IHBpZWNlID0gc3F1YXJlLnBpZWNlIGFzIFBpZWNlT2JqO1xuXG4gIGNvbnN0IHBvc3NpYmxlTW92ZXMgPSBnZXRQb3NzaWJsZU1vdmVzKG9yaWdpbiwgYm9hcmQpO1xuXG4gIGNvbnN0IG9ic3RydWN0aW9ucyA9IHBvc3NpYmxlTW92ZXMuZmlsdGVyKChzKSA9PiBib2FyZC5nZXQocyk/LnBpZWNlKTtcbiAgaWYgKCFvYnN0cnVjdGlvbnMubGVuZ3RoKSB7XG4gICAgaWYgKHBpZWNlLnR5cGUgPT09ICdwYXduJylcbiAgICAgIHJldHVybiBbLi4uZ2V0UGF3bkNhcHR1cmVzKG9yaWdpbiwgYm9hcmQpLCAuLi5wb3NzaWJsZU1vdmVzXTtcbiAgICByZXR1cm4gcG9zc2libGVNb3ZlcztcbiAgfVxuXG4gIGxldCBsZWdhbE1vdmVzOiBNb3ZlcyA9IFtdO1xuICBzd2l0Y2ggKHBpZWNlLnR5cGUpIHtcbiAgICBjYXNlICdrbmlnaHQnOiB7XG4gICAgICBsZWdhbE1vdmVzID0gcG9zc2libGVNb3ZlcztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlICdwYXduJzoge1xuICAgICAgY29uc3QgY2FwdHVyZXNBdmFpbGFibGUgPSBnZXRQYXduQ2FwdHVyZXMob3JpZ2luLCBib2FyZCk7XG4gICAgICBjb25zdCB1bm9ic3RydWN0ZWRNb3ZlcyA9IHJlbW92ZU1vdmVzV2l0aFBpZWNlcyhcbiAgICAgICAgcmVtb3ZlT2JzdHJ1Y3RlZE1vdmVzKG9yaWdpbiwgcG9zc2libGVNb3Zlcywgb2JzdHJ1Y3Rpb25zKSxcbiAgICAgICAgYm9hcmRcbiAgICAgICk7XG4gICAgICBsZWdhbE1vdmVzID0gWy4uLmNhcHR1cmVzQXZhaWxhYmxlLCAuLi51bm9ic3RydWN0ZWRNb3Zlc107XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAna2luZyc6IHtcbiAgICAgIGxlZ2FsTW92ZXMgPSByZW1vdmVQcm90ZWN0ZWRTcXVhcmVzKG9yaWdpbiwgcG9zc2libGVNb3ZlcywgYm9hcmQpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGxlZ2FsTW92ZXMgPSByZW1vdmVPYnN0cnVjdGVkTW92ZXMob3JpZ2luLCBwb3NzaWJsZU1vdmVzLCBvYnN0cnVjdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZW1vdmVNb3Zlc1dpdGhQaWVjZXMobGVnYWxNb3ZlcywgYm9hcmQsIHBpZWNlLmNvbG9yKTtcbn1cblxuZnVuY3Rpb24gZ2V0TGVnYWxNb3Zlc0luQ2hlY2soXG4gIG9yaWdpbjogU3F1YXJlLFxuICBib2FyZDogQm9hcmQsXG4gIGtpbmdQb3M6IFNxdWFyZSxcbiAgc3F1YXJlR2l2aW5nQ2hlY2s6IFNxdWFyZVxuKSB7XG4gIGNvbnN0IHNxdWFyZXNUaGF0RGVhbFdpdGhDaGVjayA9IGdldFNxdWFyZXNCZXR3ZWVuS2luZ0FuZENoZWNrKFxuICAgIGtpbmdQb3MsXG4gICAgc3F1YXJlR2l2aW5nQ2hlY2ssXG4gICAgQXJyYXkuZnJvbShib2FyZC5rZXlzKCkpXG4gICk7XG5cbiAgY29uc3QgbW92ZXMgPSBnZXRMZWdhbE1vdmVzKG9yaWdpbiwgYm9hcmQpO1xuXG4gIHJldHVybiBtb3Zlcy5maWx0ZXIoKHMpID0+IHNxdWFyZXNUaGF0RGVhbFdpdGhDaGVjay5pbmNsdWRlcyhzKSk7XG59XG5cbmZ1bmN0aW9uIGdldEF0dGFja2luZ01vdmVzKG9yaWdpbjogU3F1YXJlLCBib2FyZDogQm9hcmQpIHtcbiAgY29uc3Qgc3F1YXJlID0gYm9hcmQuZ2V0KG9yaWdpbikgYXMgU3F1YXJlT2JqO1xuXG4gIGNvbnN0IHsgdHlwZSwgY29sb3IgfSA9IHNxdWFyZS5waWVjZSBhcyBQaWVjZU9iajtcblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdwYXduJzoge1xuICAgICAgY29uc3QgcGllY2UgPSBQaWVjZShjb2xvciwgJ3Bhd24nKTtcbiAgICAgIHJldHVybiBwaWVjZS5nZXRQYXduQ2FwdHVyZXMob3JpZ2luKSBhcyBNb3ZlcztcbiAgICB9XG4gICAgY2FzZSAna2luZyc6IHtcbiAgICAgIC8vIG5lZWQgdG8gZG8gdGhpcyBiZWNhdXNlIGdldExlZ2FsTW92ZXMgd2lsbCByZWN1cnNpdmVseSBjYWxsIHJlbW92ZVByb3RlY3RlZFNxdWFyZXMgb3RoZXJ3aXNlXG4gICAgICBjb25zdCBhdHRhY2tpbmdNb3ZlcyA9IHJlbW92ZU1vdmVzV2l0aFBpZWNlcyhcbiAgICAgICAgZ2V0UG9zc2libGVNb3ZlcyhvcmlnaW4sIGJvYXJkKSxcbiAgICAgICAgYm9hcmQsXG4gICAgICAgIGNvbG9yXG4gICAgICApO1xuICAgICAgcmV0dXJuIGF0dGFja2luZ01vdmVzO1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGdldExlZ2FsTW92ZXMob3JpZ2luLCBib2FyZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QWxsTW92ZXNGb3JDb2xvcihcbiAgY29sb3I6IENvbG9yLFxuICBib2FyZDogQm9hcmQsXG4gIHNraXBLaW5nPzogYm9vbGVhblxuKTogTW92ZXMge1xuICBjb25zdCBhbGxNb3ZlczogTW92ZXNbXSA9IFtdO1xuICBmb3IgKGNvbnN0IFtzcXVhcmUsIHsgcGllY2UgfV0gb2YgYm9hcmQuZW50cmllcygpKSB7XG4gICAgaWYgKCFwaWVjZSkgY29udGludWU7XG4gICAgaWYgKHBpZWNlLmNvbG9yICE9PSBjb2xvcikgY29udGludWU7XG4gICAgaWYgKHNraXBLaW5nICYmIHBpZWNlLnR5cGUgPT09ICdraW5nJykgY29udGludWU7XG5cbiAgICBhbGxNb3Zlcy5wdXNoKGdldExlZ2FsTW92ZXMoc3F1YXJlLCBib2FyZCkpO1xuICB9XG5cbiAgcmV0dXJuIGFsbE1vdmVzLmZsYXQoKTtcbn1cblxuZnVuY3Rpb24gZ2V0QXR0YWNraW5nTW92ZXNGb3JDb2xvcihjb2xvcjogQ29sb3IsIGJvYXJkOiBCb2FyZCk6IE1vdmVzIHtcbiAgY29uc3QgYWxsTW92ZXM6IE1vdmVzW10gPSBbXTtcbiAgZm9yIChjb25zdCBbc3F1YXJlLCB7IHBpZWNlIH1dIG9mIGJvYXJkLmVudHJpZXMoKSkge1xuICAgIGlmICghcGllY2UpIGNvbnRpbnVlO1xuICAgIGlmIChwaWVjZS5jb2xvciAhPT0gY29sb3IpIGNvbnRpbnVlO1xuXG4gICAgYWxsTW92ZXMucHVzaChnZXRBdHRhY2tpbmdNb3ZlcyhzcXVhcmUsIGJvYXJkKSk7XG4gIH1cblxuICByZXR1cm4gYWxsTW92ZXMuZmxhdCgpO1xufVxuXG5mdW5jdGlvbiBnZXRQYXduQ2FwdHVyZXMocGF3blNxdWFyZTogU3F1YXJlLCBib2FyZDogQm9hcmQpIHtcbiAgY29uc3QgeyBjb2xvciB9ID0gYm9hcmQuZ2V0KHBhd25TcXVhcmUpPy5waWVjZSBhcyBQaWVjZU9iajtcbiAgY29uc3QgcGF3biA9IFBpZWNlKGNvbG9yLCAncGF3bicpO1xuXG4gIGNvbnN0IGNhcHR1cmVNb3ZlcyA9IHBhd24uZ2V0UGF3bkNhcHR1cmVzKHBhd25TcXVhcmUpO1xuICBpZiAoIWNhcHR1cmVNb3ZlcykgcmV0dXJuIFtdO1xuXG4gIHJldHVybiBjYXB0dXJlTW92ZXMuZmlsdGVyKChzKSA9PiB7XG4gICAgY29uc3Qgc3F1YXJlVmFsID0gYm9hcmQuZ2V0KHMpO1xuICAgIGlmICghc3F1YXJlVmFsKSByZXR1cm4gZmFsc2U7XG5cbiAgICBjb25zdCBwaWVjZSA9IHNxdWFyZVZhbC5waWVjZTtcbiAgICBjb25zdCBlblBhc3NhbnQ6IEVuUGFzc2FudE9iaiB8IHVuZGVmaW5lZCA9IHNxdWFyZVZhbC5lblBhc3NhbnQ7XG5cbiAgICByZXR1cm4gKFxuICAgICAgKHBpZWNlICYmIHBpZWNlLmNvbG9yICE9PSBwYXduLmNvbG9yKSB8fFxuICAgICAgKGVuUGFzc2FudCAmJiBlblBhc3NhbnQuY29sb3IgIT09IHBhd24uY29sb3IpXG4gICAgKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFNxdWFyZXNCZXR3ZWVuS2luZ0FuZENoZWNrKFxuICBraW5nUG9zOiBTcXVhcmUsXG4gIGNoZWNrUG9zOiBTcXVhcmUsXG4gIGFsbFNxdWFyZXM6IE1vdmVzXG4pIHtcbiAgLy8gaW5jbHVkZXMga2luZ1BvcyBhbmQgY2hlY2tQb3NcbiAgY29uc3Qgc3F1YXJlc0Fsb25nVmVjdG9yID0gZ2V0TW92ZXNBbG9uZ1ZlY3RvcihraW5nUG9zLCBjaGVja1BvcywgYWxsU3F1YXJlcyk7XG4gIGNvbnN0IHNxdWFyZXNCZXR3ZWVuS2luZ0FuZFBpZWNlID0gcmVtb3ZlTW92ZXNCZWhpbmRUd29TcXVhcmVzKFxuICAgIGtpbmdQb3MsXG4gICAgY2hlY2tQb3MsXG4gICAgc3F1YXJlc0Fsb25nVmVjdG9yXG4gICk7XG4gIHJldHVybiBzcXVhcmVzQmV0d2VlbktpbmdBbmRQaWVjZTtcbn1cblxuLyogZmlsdGVyIG1vdmVzICovXG5cbmZ1bmN0aW9uIHJlbW92ZU1vdmVzQmVoaW5kVHdvU3F1YXJlcyhcbiAgczE6IFNxdWFyZSxcbiAgczI6IFNxdWFyZSxcbiAgdmVjdG9yOiBNb3Zlc1xuKTogTW92ZXMge1xuICBjb25zdCBzb3J0ZWQgPSBzb3J0TW92ZXNDbG9zZXN0VG8oZ2V0QmVnaW5uaW5nT2ZWZWN0b3IodmVjdG9yKSkodmVjdG9yKTtcbiAgbGV0IGZ1cnRoZXN0U3F1YXJlO1xuICBsZXQgY2xvc2VzdFNxdWFyZTtcblxuICBpZiAoc29ydGVkLmluZGV4T2YoczEpID4gc29ydGVkLmluZGV4T2YoczIpKSB7XG4gICAgZnVydGhlc3RTcXVhcmUgPSBzMTtcbiAgICBjbG9zZXN0U3F1YXJlID0gczI7XG4gIH0gZWxzZSB7XG4gICAgZnVydGhlc3RTcXVhcmUgPSBzMjtcbiAgICBjbG9zZXN0U3F1YXJlID0gczE7XG4gIH1cbiAgY29uc3QgcmVtb3ZlZE9uZUVuZCA9IHJlbW92ZU1vdmVzQmVoaW5kU3F1YXJlKGZ1cnRoZXN0U3F1YXJlKShzb3J0ZWQpO1xuICBjb25zdCByZW1vdmVkQm90aEVuZHMgPSByZW1vdmVNb3Zlc0JlaGluZFNxdWFyZShjbG9zZXN0U3F1YXJlKShcbiAgICByZW1vdmVkT25lRW5kLnJldmVyc2UoKVxuICApO1xuXG4gIHJldHVybiByZW1vdmVkQm90aEVuZHM7XG59XG5cbmNvbnN0IHJlbW92ZU1vdmVzQmVoaW5kU3F1YXJlID1cbiAgKHNxdWFyZTogU3F1YXJlKSA9PlxuICAobW92ZXM6IE1vdmVzKTogTW92ZXMgPT4ge1xuICAgIGNvbnN0IGNvcHkgPSBbLi4ubW92ZXNdO1xuICAgIGNvbnN0IGluZGV4ID0gbW92ZXMuaW5kZXhPZihzcXVhcmUpO1xuXG4gICAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIFtdO1xuXG4gICAgY29weS5zcGxpY2UoaW5kZXggKyAxKTtcblxuICAgIHJldHVybiBjb3B5O1xuICB9O1xuXG5mdW5jdGlvbiByZW1vdmVPYnN0cnVjdGVkTW92ZXMoXG4gIHN0YXJ0aW5nU3F1YXJlOiBTcXVhcmUsXG4gIHBvc3NpYmxlTW92ZXM6IE1vdmVzLFxuICBvYnN0cnVjdGlvbnM6IE1vdmVzXG4pOiBNb3ZlcyB7XG4gIC8vIGEpIHNwbGl0IHBvc3NpYmxlIG1vdmVzIGludG8gdmVjdG9ycyAodXAsZG93bixsZWZ0LHJpZ2h0LCBhbmQvb3IgZGlhZ29uYWxzKVxuICAvLyBiKSBzZWUgd2hpY2ggb2JzdHJ1Y3Rpb25zIGJlbG9uZyB0byB3aGljaCB2ZWN0b3JcbiAgLy8gYykgZmluZCB0aGUgY2xvc2VzdCBvYnN0cnVjdGlvblxuICAvLyBkKSByZW1vdmUgYWxsIHRoZSBtb3ZlcyBiZWhpbmQgdGhhdCBvYnN0cnVjdGlvblxuXG4gIGNvbnN0IGZpbHRlcmVkTW92ZXM6IE1vdmVzW10gPSBbXTtcblxuICBjb25zdCBhbGxWZWN0b3JzID0gc3BsaXRJbnRvVmVjdG9ycyhwb3NzaWJsZU1vdmVzLCBzdGFydGluZ1NxdWFyZSk7XG4gIGNvbnN0IG9ic3RydWN0aW9uVmVjdG9ycyA9IHNwbGl0SW50b1ZlY3RvcnMob2JzdHJ1Y3Rpb25zLCBzdGFydGluZ1NxdWFyZSk7XG4gIGZvciAoY29uc3QgdmVjdG9yIGluIGFsbFZlY3RvcnMpIHtcbiAgICBpZiAoIW9ic3RydWN0aW9uVmVjdG9yc1t2ZWN0b3JdKSB7XG4gICAgICAvLyBsb29rIGZvciB2ZWN0b3Igb2JzdHJ1Y3Rpb24gaXMgb25cbiAgICAgIGZpbHRlcmVkTW92ZXMucHVzaChhbGxWZWN0b3JzW3ZlY3Rvcl0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3Qgc29ydGVkID0gc29ydE1vdmVzQ2xvc2VzdFRvKHN0YXJ0aW5nU3F1YXJlKShhbGxWZWN0b3JzW3ZlY3Rvcl0pO1xuICAgIGNvbnN0IGNsb3Nlc3RPYnN0cnVjdGlvbiA9IHNvcnRNb3Zlc0Nsb3Nlc3RUbyhzdGFydGluZ1NxdWFyZSkoXG4gICAgICBvYnN0cnVjdGlvblZlY3RvcnNbdmVjdG9yXVxuICAgIClbMF07XG5cbiAgICBmaWx0ZXJlZE1vdmVzLnB1c2gocmVtb3ZlTW92ZXNCZWhpbmRTcXVhcmUoY2xvc2VzdE9ic3RydWN0aW9uKShzb3J0ZWQpKTtcbiAgfVxuXG4gIHJldHVybiBmaWx0ZXJlZE1vdmVzLmZsYXQoKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlUHJvdGVjdGVkU3F1YXJlcyhcbiAga2luZ1BvczogU3F1YXJlLFxuICBwb3NzaWJsZU1vdmVzOiBNb3ZlcyxcbiAgYm9hcmQ6IEJvYXJkXG4pOiBNb3ZlcyB7XG4gIGNvbnN0IGtpbmcgPSBib2FyZC5nZXQoa2luZ1Bvcyk/LnBpZWNlIGFzIFBpZWNlT2JqO1xuICAvLyBiYyBraW5nIGNhbnQgbW92ZSBpZiBzcXVhcmUgaXMgcHJvdGVjdGVkXG4gIGNvbnN0IG9wcENvbG9yID0ga2luZy5jb2xvciA9PT0gJ3doaXRlJyA/ICdibGFjaycgOiAnd2hpdGUnO1xuXG4gIGNvbnN0IGJvYXJkQ29weSA9IG5ldyBNYXAoYm9hcmQpO1xuICBwb3NzaWJsZU1vdmVzLmZvckVhY2goKHMpID0+IGJvYXJkQ29weS5zZXQocywgeyBwaWVjZToga2luZyB9KSk7XG5cbiAgY29uc3QgYWxsRW5lbXlNb3ZlcyA9IGdldEF0dGFja2luZ01vdmVzRm9yQ29sb3Iob3BwQ29sb3IsIGJvYXJkQ29weSk7XG4gIHJldHVybiBwb3NzaWJsZU1vdmVzLmZpbHRlcigocykgPT4ge1xuICAgIHJldHVybiAhYWxsRW5lbXlNb3Zlcy5pbmNsdWRlcyhzKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU1vdmVzV2l0aFBpZWNlcyhcbiAgbW92ZXM6IE1vdmVzLFxuICBib2FyZDogQm9hcmQsXG4gIGNvbG9yPzogQ29sb3Jcbik6IE1vdmVzIHtcbiAgcmV0dXJuIG1vdmVzLmZpbHRlcigocykgPT4ge1xuICAgIGNvbnN0IHNxdWFyZVZhbCA9IGJvYXJkLmdldChzKTtcbiAgICBpZiAoIXNxdWFyZVZhbCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKGNvbG9yKSByZXR1cm4gIXNxdWFyZVZhbC5waWVjZSB8fCBzcXVhcmVWYWwucGllY2UuY29sb3IgIT09IGNvbG9yO1xuICAgIGVsc2UgcmV0dXJuICFzcXVhcmVWYWwucGllY2U7XG4gIH0pO1xufVxuXG4vKiBnYW1lYm9hcmQgY2hlY2tzICovXG5cbmZ1bmN0aW9uIGdldERpc2NvdmVyZWRDaGVjayhcbiAga2luZ1BvczogU3F1YXJlLFxuICBraW5nQ29sb3I6IENvbG9yLFxuICB2YWNhdGVkOiBTcXVhcmUsXG4gIGJvYXJkOiBCb2FyZFxuKTogU3F1YXJlIHtcbiAgLy8gb3BlblNxdWFyZSBpcyBhIHNxdWFyZSBqdXN0IHZhY2F0ZWRcbiAgbGV0IHNxdWFyZXNBbG9uZ1ZlY3RvciA9IGdldE1vdmVzQWxvbmdWZWN0b3IoXG4gICAga2luZ1BvcyxcbiAgICB2YWNhdGVkLFxuICAgIEFycmF5LmZyb20oYm9hcmQua2V5cygpKVxuICApO1xuICBzcXVhcmVzQWxvbmdWZWN0b3IgPSBzcXVhcmVzQWxvbmdWZWN0b3IuZmlsdGVyKFxuICAgIChzKSA9PiBzICE9PSBraW5nUG9zICYmIHMgIT09IHZhY2F0ZWRcbiAgKTtcbiAgaWYgKCFzcXVhcmVzQWxvbmdWZWN0b3IubGVuZ3RoKSByZXR1cm4gJyc7XG5cbiAgZm9yIChjb25zdCBzcXVhcmUgb2Ygc3F1YXJlc0Fsb25nVmVjdG9yKSB7XG4gICAgY29uc3QgcGllY2UgPSBib2FyZC5nZXQoc3F1YXJlKT8ucGllY2U7XG4gICAgaWYgKCFwaWVjZSB8fCBwaWVjZS5jb2xvciA9PT0ga2luZ0NvbG9yKSBjb250aW51ZTtcblxuICAgIGNvbnN0IGxlZ2FsTW92ZXMgPSBnZXRMZWdhbE1vdmVzKHNxdWFyZSwgYm9hcmQpO1xuICAgIGlmIChsZWdhbE1vdmVzLmluY2x1ZGVzKGtpbmdQb3MpKSByZXR1cm4gc3F1YXJlO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBjYW5CbG9ja09yQ2FwdHVyZUNoZWNrKFxuICBraW5nUG9zOiBTcXVhcmUsXG4gIHNxdWFyZUdpdmluZ0NoZWNrOiBTcXVhcmUsXG4gIGJvYXJkOiBCb2FyZFxuKTogYm9vbGVhbiB7XG4gIGNvbnN0IGtpbmcgPSBib2FyZC5nZXQoa2luZ1Bvcyk/LnBpZWNlIGFzIFBpZWNlT2JqO1xuXG4gIGNvbnN0IGJsb2NrT3JDYXB0dXJlU3F1YXJlcyA9IGdldFNxdWFyZXNCZXR3ZWVuS2luZ0FuZENoZWNrKFxuICAgIGtpbmdQb3MsXG4gICAgc3F1YXJlR2l2aW5nQ2hlY2ssXG4gICAgQXJyYXkuZnJvbShib2FyZC5rZXlzKCkpXG4gICk7IC8vIGFsc28gaW5jbHVkZXMgY2hlY2sgc3F1YXJlXG5cbiAgY29uc3Qgb3duUGllY2VNb3ZlcyA9IGdldEFsbE1vdmVzRm9yQ29sb3Ioa2luZy5jb2xvciwgYm9hcmQsIHRydWUpO1xuICByZXR1cm4gb3duUGllY2VNb3Zlcy5zb21lKChtb3ZlKSA9PiBibG9ja09yQ2FwdHVyZVNxdWFyZXMuaW5jbHVkZXMobW92ZSkpO1xufVxuXG5leHBvcnQge1xuICBnZXRBdHRhY2tpbmdNb3Zlc0ZvckNvbG9yLFxuICBnZXRMZWdhbE1vdmVzLFxuICBnZXRMZWdhbE1vdmVzSW5DaGVjayxcbiAgZ2V0RGlzY292ZXJlZENoZWNrLFxuICBjYW5CbG9ja09yQ2FwdHVyZUNoZWNrXG59O1xuIiwiY29uc3QgZmlsZXMgPSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJywgJ2cnLCAnaCddO1xuY29uc3QgcmFua3MgPSBbMSwgMiwgMywgNCwgNSwgNiwgNywgOF07XG5cbmV4cG9ydCB7IGZpbGVzLCByYW5rcyB9O1xuIiwiaW1wb3J0IHsgQ2FzdGxlT2JqIH0gZnJvbSAnLi90eXBlcy9pbnRlcmZhY2VzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ2FzdGxlKFxuICB3aGl0ZUtpbmdzaWRlOiBib29sZWFuLFxuICB3aGl0ZVF1ZWVuc2lkZTogYm9vbGVhbixcbiAgYmxhY2tLaW5nc2lkZTogYm9vbGVhbixcbiAgYmxhY2tRdWVlbnNpZGU6IGJvb2xlYW5cbik6IENhc3RsZU9iaiB7XG4gIHJldHVybiB7XG4gICAgd2hpdGU6IHtcbiAgICAgIGtpbmdzaWRlOiB3aGl0ZUtpbmdzaWRlLFxuICAgICAgcXVlZW5zaWRlOiB3aGl0ZVF1ZWVuc2lkZVxuICAgIH0sXG4gICAgYmxhY2s6IHtcbiAgICAgIGtpbmdzaWRlOiBibGFja0tpbmdzaWRlLFxuICAgICAgcXVlZW5zaWRlOiBibGFja1F1ZWVuc2lkZVxuICAgIH1cbiAgfTtcbn1cbiIsImltcG9ydCB7XG4gIGdldExlZ2FsTW92ZXMsXG4gIGdldERpc2NvdmVyZWRDaGVjayxcbiAgY2FuQmxvY2tPckNhcHR1cmVDaGVjayxcbiAgZ2V0QXR0YWNraW5nTW92ZXNGb3JDb2xvcixcbiAgZ2V0TGVnYWxNb3Zlc0luQ2hlY2tcbn0gZnJvbSAnLi91dGlscy9tb3Zlcyc7XG5pbXBvcnQgeyB0b1hZLCBmcm9tWFkgfSBmcm9tICcuL3V0aWxzL2hlbHBlcnMnO1xuaW1wb3J0IHsgcmFua3MsIGZpbGVzIH0gZnJvbSAnLi9yYW5rc0FuZEZpbGVzJztcbmltcG9ydCB7XG4gIENvbG9yLFxuICBTcXVhcmUsXG4gIEJvYXJkLFxuICBQaWVjZVR5cGUsXG4gIE1vdmVzLFxuICBDYXN0bGVTcXVhcmVzVHlwZVxufSBmcm9tICcuL3R5cGVzL3R5cGVzJztcbmltcG9ydCB7XG4gIEFsbFBpZWNlTWFwLFxuICBDYXN0bGVPYmosXG4gIEdhbWVib2FyZE9iaixcbiAgUGllY2VNYXAsXG4gIFBpZWNlT2JqXG59IGZyb20gJy4vdHlwZXMvaW50ZXJmYWNlcyc7XG5pbXBvcnQgQ2FzdGxlIGZyb20gJy4vQ2FzdGxlJztcblxuZnVuY3Rpb24gY3JlYXRlQm9hcmQoKTogQm9hcmQge1xuICByZXR1cm4gZmlsZXMucmVkdWNlKChhY2MsIGZpbGUpID0+IHtcbiAgICByYW5rcy5mb3JFYWNoKChyYW5rKSA9PiB7XG4gICAgICBjb25zdCBzcXVhcmUgPSBmaWxlLmNvbmNhdChyYW5rLnRvU3RyaW5nKCkpO1xuICAgICAgYWNjLnNldChzcXVhcmUsIHsgcGllY2U6IG51bGwgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwgbmV3IE1hcCgpKTtcbn1cblxuY29uc3QgR2FtZWJvYXJkID0gKFxuICBib2FyZCA9IGNyZWF0ZUJvYXJkKCksXG4gIHNxdWFyZXNHaXZpbmdDaGVjaz86IE1vdmVzLFxuICBDYXN0bGVSaWdodHM/OiBDYXN0bGVPYmpcbik6IEdhbWVib2FyZE9iaiA9PiB7XG4gIGZ1bmN0aW9uIG1ha2VNb3ZlKFxuICAgIHMxOiBTcXVhcmUsXG4gICAgczI6IFNxdWFyZSxcbiAgICBwcm9tb3RlPzogUGllY2VUeXBlXG4gICk6IEJvYXJkIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBwaWVjZSA9IGF0KHMxKS5waWVjZTtcblxuICAgIC8vIHZhbGlkYXRlIG1vdmVcbiAgICBpZiAoIXBpZWNlKSByZXR1cm47XG4gICAgaWYgKCF2YWxpZGF0ZS5tb3ZlKHMxLCBzMikpIHJldHVybjtcbiAgICBpZiAocHJvbW90ZSAmJiAhdmFsaWRhdGUucHJvbW90aW9uKHMxLCBzMikpIHJldHVybjtcblxuICAgIGVuUGFzc2FudC5yZW1vdmUoKTtcblxuICAgIHN3aXRjaCAocGllY2UudHlwZSkge1xuICAgICAgY2FzZSAncGF3bic6IHtcbiAgICAgICAgaWYgKHByb21vdGUpIHtcbiAgICAgICAgICBhdChzMSkucHJvbW90ZShwcm9tb3RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlblBhc3NhbnQuY2hlY2tUb2dnbGUoczEsIHMyKSkge1xuICAgICAgICAgIGVuUGFzc2FudC50b2dnbGUocGllY2UuY29sb3IsIHMyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZyb20oczEpLnRvKHMyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgJ2tpbmcnOiB7XG4gICAgICAgIC8vIGNoZWNrIGlmIG1vdmUgaXMgY2FzdGxlXG4gICAgICAgIGxldCBjYXN0bGVTaWRlOiAnJyB8ICdxdWVlbnNpZGUnIHwgJ2tpbmdzaWRlJyA9ICcnO1xuICAgICAgICBjb25zdCBjYXN0bGVTcXVhcmVzID0gZ2V0LmNhc3RsZVNxdWFyZXMocGllY2UuY29sb3IpO1xuXG4gICAgICAgIGZvciAoY29uc3QgW3NpZGUsIHNxdWFyZXNdIG9mIE9iamVjdC5lbnRyaWVzKGNhc3RsZVNxdWFyZXMpKSB7XG4gICAgICAgICAgaWYgKHNxdWFyZXNbMV0gPT09IHMyKSBjYXN0bGVTaWRlID0gc2lkZSBhcyAna2luZ3NpZGUnIHwgJ3F1ZWVuc2lkZSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2FzdGxlU2lkZSkgY2FzdGxpbmcuY2FzdGxlKHBpZWNlLmNvbG9yLCBjYXN0bGVTaWRlKTtcbiAgICAgICAgZWxzZSBmcm9tKHMxKS50byhzMik7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGZyb20oczEpLnRvKHMyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYm9hcmQ7XG4gIH1cblxuICBjb25zdCBjYXN0bGluZyA9IHtcbiAgICBjYW5DYXN0bGU6IChjb2xvcjogQ29sb3IsIHNpZGU6ICdraW5nc2lkZScgfCAncXVlZW5zaWRlJyk6IGJvb2xlYW4gPT4ge1xuICAgICAgaWYgKENhc3RsZVJpZ2h0cyAmJiAhQ2FzdGxlUmlnaHRzW2NvbG9yXVtzaWRlXSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBjaGVjayBpZiByb29rIHN0aWxsIGV4aXN0c1xuICAgICAgaWYgKCFjaGVja0lmUm9va0V4aXN0cygpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGNvbnN0IG9wcENvbG9yID0gY29sb3IgPT09ICd3aGl0ZScgPyAnYmxhY2snIDogJ3doaXRlJztcbiAgICAgIGNvbnN0IG9wcE1vdmVzID0gZ2V0QXR0YWNraW5nTW92ZXNGb3JDb2xvcihvcHBDb2xvciwgYm9hcmQpO1xuXG4gICAgICBjb25zdCBjYXN0bGVTcXVhcmVzID0gZ2V0LmNhc3RsZVNxdWFyZXMoY29sb3IpW3NpZGVdO1xuICAgICAgZm9yIChjb25zdCBzcXVhcmUgb2YgY2FzdGxlU3F1YXJlcykge1xuICAgICAgICAvLyBjaGVjayBpZiBjYXN0bGUgc3F1YXJlIGlzIGNsZWFyZWRcbiAgICAgICAgaWYgKGF0KHNxdWFyZSkucGllY2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gbWFrZSBzdXJlIGNhc3RsZSBzcXVhcmUgaXNudCBhdHRhY2tlZFxuICAgICAgICBpZiAob3BwTW92ZXMuaW5jbHVkZXMoc3F1YXJlKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgZnVuY3Rpb24gY2hlY2tJZlJvb2tFeGlzdHMoKTogYm9vbGVhbiB7XG4gICAgICAgIGxldCByb29rRXhpc3RzID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHJhbmsgPSBjb2xvciA9PT0gJ3doaXRlJyA/IDEgOiA4O1xuICAgICAgICBjb25zdCBsb29wU3RhcnQgPVxuICAgICAgICAgIHNpZGUgPT09ICdxdWVlbnNpZGUnID8gZmlsZXMuaW5kZXhPZignYScpIDogZmlsZXMuaW5kZXhPZignZCcpO1xuICAgICAgICBjb25zdCBsb29wRW5kID1cbiAgICAgICAgICBzaWRlID09PSAncXVlZW5zaWRlJyA/IGZpbGVzLmluZGV4T2YoJ2UnKSA6IGZpbGVzLmluZGV4T2YoJ2gnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGxvb3BTdGFydDsgaSA8PSBsb29wRW5kOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBzcXVhcmUgPSBmaWxlc1tpXSArIHJhbms7XG5cbiAgICAgICAgICBjb25zdCBwaWVjZSA9IGF0KHNxdWFyZSkucGllY2U7XG4gICAgICAgICAgaWYgKCFwaWVjZSkgY29udGludWU7XG5cbiAgICAgICAgICBpZiAocGllY2UudHlwZSA9PT0gJ3Jvb2snKSByb29rRXhpc3RzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm9va0V4aXN0cztcbiAgICAgIH1cbiAgICB9LFxuICAgIGNhc3RsZTogKGNvbG9yOiBDb2xvciwgc2lkZTogJ2tpbmdzaWRlJyB8ICdxdWVlbnNpZGUnKTogdm9pZCA9PiB7XG4gICAgICBjb25zdCBjYXN0bGVTcXVhcmVzID0gZ2V0LmNhc3RsZVNxdWFyZXMoY29sb3IpW3NpZGVdO1xuXG4gICAgICBjb25zdCBraW5nUG9zID0gZ2V0LmtpbmdQb3NpdGlvbihjb2xvcikgYXMgU3F1YXJlO1xuICAgICAgY29uc3Qgcm9va1BvcyA9IGdldFJvb2tQb3MoKSBhcyBTcXVhcmU7XG5cbiAgICAgIGZyb20ocm9va1BvcykudG8oY2FzdGxlU3F1YXJlc1swXSk7XG4gICAgICBmcm9tKGtpbmdQb3MpLnRvKGNhc3RsZVNxdWFyZXNbMV0pO1xuXG4gICAgICBmdW5jdGlvbiBnZXRSb29rUG9zKCkge1xuICAgICAgICBjb25zdCBwaWVjZU1hcCA9IGdldC5waWVjZU1hcCgpO1xuICAgICAgICBjb25zdCByb29rUG9zID0gcGllY2VNYXBbY29sb3JdLnJvb2suZmluZCgoc3F1YXJlKSA9PiB7XG4gICAgICAgICAgY29uc3QgZmlsZSA9IHNxdWFyZS5zcGxpdCgnJylbMF07XG4gICAgICAgICAgcmV0dXJuIHNpZGUgPT09ICdraW5nc2lkZSdcbiAgICAgICAgICAgID8gZmlsZXMuaW5kZXhPZihmaWxlKSA+IDNcbiAgICAgICAgICAgIDogZmlsZXMuaW5kZXhPZihmaWxlKSA8IDM7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByb29rUG9zO1xuICAgICAgfVxuICAgICAgLy8gbmVlZCB0byBnZXQga2luZyBwb3NpdGlvblxuICAgICAgLy8gbmVlZCB0byBnZXQgY2FzdGxlIHNxdWFyZXNcbiAgICAgIC8vIG5lZWQgdG8gZmluZCByb29rXG4gICAgfSxcbiAgICBnZXRSaWdodHNBZnRlck1vdmU6IChzcXVhcmU6IFNxdWFyZSk6IENhc3RsZU9iaiA9PiB7XG4gICAgICBjb25zdCBwaWVjZSA9IGF0KHNxdWFyZSkucGllY2UgYXMgUGllY2VPYmo7XG5cbiAgICAgIGNvbnN0IGNhc3RsZVJpZ2h0cyA9IENhc3RsZVJpZ2h0cyB8fCBDYXN0bGUodHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICAgIGlmIChcbiAgICAgICAgY2FzdGxlUmlnaHRzW3BpZWNlLmNvbG9yXS5raW5nc2lkZSB8fFxuICAgICAgICBjYXN0bGVSaWdodHNbcGllY2UuY29sb3JdLnF1ZWVuc2lkZVxuICAgICAgKSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIGkgbmVlZCB0byBjaGFuZ2UgY2FzdGxpbmcgcmlnaHRzXG4gICAgICAgIGlmIChwaWVjZS50eXBlID09PSAna2luZycpIHtcbiAgICAgICAgICBjYXN0bGVSaWdodHNbcGllY2UuY29sb3JdLmtpbmdzaWRlID0gZmFsc2U7XG4gICAgICAgICAgY2FzdGxlUmlnaHRzW3BpZWNlLmNvbG9yXS5xdWVlbnNpZGUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwaWVjZS50eXBlID09PSAncm9vaycpIHtcbiAgICAgICAgICAvLyBuZWVkIHRvIGZpbmQgaWYgaXQgaXMga2luZ3NpZGUgb3IgcXVlZW5zaWRlIHJvb2tcbiAgICAgICAgICBjb25zdCBbZmlsZV0gPSBzcXVhcmUuc3BsaXQoJycpO1xuICAgICAgICAgIGNvbnN0IGtpbmdzaWRlID0gZmlsZXMuaW5kZXhPZihmaWxlKSA+IDM7XG4gICAgICAgICAgaWYgKGtpbmdzaWRlKSBjYXN0bGVSaWdodHNbcGllY2UuY29sb3JdLmtpbmdzaWRlID0gZmFsc2U7XG4gICAgICAgICAgZWxzZSBjYXN0bGVSaWdodHNbcGllY2UuY29sb3JdLnF1ZWVuc2lkZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYXN0bGVSaWdodHM7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGVuUGFzc2FudCA9ICgoKSA9PiB7XG4gICAgZnVuY3Rpb24gZ2V0U3F1YXJlKGN1cnJlbnQ6IFNxdWFyZSwgY29sb3I6IENvbG9yKTogU3F1YXJlIHtcbiAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdG9YWShjdXJyZW50KTtcbiAgICAgIGNvbnN0IG5ld1kgPSBjb2xvciA9PT0gJ3doaXRlJyA/IHkgLSAxIDogeSArIDE7XG4gICAgICByZXR1cm4gZnJvbVhZKHsgeCwgeTogbmV3WSB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY2hlY2tUb2dnbGU6IChmcm9tOiBTcXVhcmUsIHRvOiBTcXVhcmUpOiBib29sZWFuID0+IHtcbiAgICAgICAgY29uc3QgeyB5OiB5MSB9ID0gdG9YWShmcm9tKTtcbiAgICAgICAgY29uc3QgeyB5OiB5MiB9ID0gdG9YWSh0byk7XG5cbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHkxIC0geTIpID09PSAyO1xuICAgICAgfSxcbiAgICAgIHRvZ2dsZTogKGNvbG9yOiBDb2xvciwgY3VycmVudDogU3F1YXJlKTogdm9pZCA9PiB7XG4gICAgICAgIGNvbnN0IGVuUGFzc2FudFNxdWFyZSA9IGdldFNxdWFyZShjdXJyZW50LCBjb2xvcik7XG4gICAgICAgIGF0KGVuUGFzc2FudFNxdWFyZSkuc2V0RW5QYXNzYW50KGNvbG9yLCBjdXJyZW50KTtcbiAgICAgIH0sXG4gICAgICByZW1vdmU6ICgpOiB2b2lkID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBzcXVhcmVPYmogb2YgYm9hcmQudmFsdWVzKCkpIHtcbiAgICAgICAgICBpZiAoc3F1YXJlT2JqLmVuUGFzc2FudCkgcmV0dXJuIChzcXVhcmVPYmouZW5QYXNzYW50ID0gdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0pKCk7XG5cbiAgY29uc3QgYXQgPSAoc3F1YXJlOiBTcXVhcmUpID0+ICh7XG4gICAgcGxhY2U6IChwaWVjZTogUGllY2VPYmopOiB2b2lkID0+IHtcbiAgICAgIGlmICghYm9hcmQuZ2V0KHNxdWFyZSkpIHJldHVybjtcblxuICAgICAgYm9hcmQuc2V0KHNxdWFyZSwgeyBwaWVjZSB9KTtcbiAgICB9LFxuICAgIHJlbW92ZTogKCk6IHZvaWQgPT4ge1xuICAgICAgaWYgKCFib2FyZC5nZXQoc3F1YXJlKSkgcmV0dXJuO1xuXG4gICAgICBib2FyZC5zZXQoc3F1YXJlLCB7IHBpZWNlOiBudWxsIH0pO1xuICAgIH0sXG4gICAgcHJvbW90ZTogKHBpZWNlVHlwZTogUGllY2VUeXBlKTogdm9pZCA9PiB7XG4gICAgICBjb25zdCBzcXVhcmVWYWwgPSBib2FyZC5nZXQoc3F1YXJlKTtcbiAgICAgIGNvbnN0IHBpZWNlID0gc3F1YXJlVmFsPy5waWVjZTtcbiAgICAgIGlmICghcGllY2UpIHJldHVybjtcblxuICAgICAgYm9hcmQuc2V0KHNxdWFyZSwgeyAuLi5zcXVhcmVWYWwsIHBpZWNlOiB7IC4uLnBpZWNlLCB0eXBlOiBwaWVjZVR5cGUgfSB9KTtcbiAgICB9LFxuICAgIHNldEVuUGFzc2FudDogKGNvbG9yOiBDb2xvciwgY3VycmVudDogU3F1YXJlKTogdm9pZCA9PiB7XG4gICAgICBpZiAoIWJvYXJkLmdldChzcXVhcmUpKSByZXR1cm47XG5cbiAgICAgIGJvYXJkLnNldChzcXVhcmUsIHtcbiAgICAgICAgcGllY2U6IG51bGwsXG4gICAgICAgIGVuUGFzc2FudDoge1xuICAgICAgICAgIGN1cnJlbnQgLyogc3F1YXJlIHBhd24gaXMgb24gKi8sXG4gICAgICAgICAgY29sb3JcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXQgcGllY2UoKSB7XG4gICAgICByZXR1cm4gYm9hcmQuZ2V0KHNxdWFyZSk/LnBpZWNlO1xuICAgIH0sXG4gICAgZ2V0TGVnYWxNb3ZlczogKCk6IE1vdmVzID0+IHtcbiAgICAgIHNxdWFyZXNHaXZpbmdDaGVjayA9IHNxdWFyZXNHaXZpbmdDaGVjayB8fCBbXTtcbiAgICAgIGNvbnN0IHsgdHlwZSwgY29sb3IgfSA9IGF0KHNxdWFyZSkucGllY2UgYXMgUGllY2VPYmo7XG5cbiAgICAgIHN3aXRjaCAoc3F1YXJlc0dpdmluZ0NoZWNrLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICBpZiAodHlwZSAhPT0gJ2tpbmcnKSByZXR1cm4gW107XG4gICAgICAgICAgcmV0dXJuIGdldExlZ2FsTW92ZXMoc3F1YXJlLCBib2FyZCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgcmV0dXJuIGdldExlZ2FsTW92ZXNJbkNoZWNrKFxuICAgICAgICAgICAgb3JpZ2luLFxuICAgICAgICAgICAgYm9hcmQsXG4gICAgICAgICAgICBnZXQua2luZ1Bvc2l0aW9uKGNvbG9yKSBhcyBTcXVhcmUsXG4gICAgICAgICAgICBzcXVhcmVzR2l2aW5nQ2hlY2tbMF1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2tpbmcnKSB7XG4gICAgICAgICAgICBsZXQgbGVnYWxNb3ZlcyA9IGdldExlZ2FsTW92ZXMoc3F1YXJlLCBib2FyZCk7XG4gICAgICAgICAgICBpZiAoY2FzdGxpbmcuY2FuQ2FzdGxlKGNvbG9yLCAna2luZ3NpZGUnKSlcbiAgICAgICAgICAgICAgbGVnYWxNb3ZlcyA9IFtcbiAgICAgICAgICAgICAgICAuLi5sZWdhbE1vdmVzLFxuICAgICAgICAgICAgICAgIC4uLmdldC5jYXN0bGVTcXVhcmVzKGNvbG9yKS5raW5nc2lkZVxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgaWYgKGNhc3RsaW5nLmNhbkNhc3RsZShjb2xvciwgJ3F1ZWVuc2lkZScpKVxuICAgICAgICAgICAgICBsZWdhbE1vdmVzID0gW1xuICAgICAgICAgICAgICAgIC4uLmxlZ2FsTW92ZXMsXG4gICAgICAgICAgICAgICAgLi4uZ2V0LmNhc3RsZVNxdWFyZXMoY29sb3IpLnF1ZWVuc2lkZVxuICAgICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICByZXR1cm4gbGVnYWxNb3ZlcztcbiAgICAgICAgICB9IGVsc2UgcmV0dXJuIGdldExlZ2FsTW92ZXMoc3F1YXJlLCBib2FyZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IGZyb20gPSAoczE6IFNxdWFyZSkgPT4gKHtcbiAgICB0bzogKHMyOiBTcXVhcmUpOiB2b2lkID0+IHtcbiAgICAgIGNvbnN0IHBpZWNlID0gYXQoczEpLnBpZWNlO1xuICAgICAgaWYgKCFwaWVjZSkgcmV0dXJuO1xuXG4gICAgICAvLyBtb3ZlIHBpZWNlXG4gICAgICBhdChzMSkucmVtb3ZlKCk7XG4gICAgICBhdChzMikucGxhY2UocGllY2UpO1xuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgZ2V0ID0ge1xuICAgIGtpbmdQb3NpdGlvbjogKGNvbG9yOiBDb2xvcik6IFNxdWFyZSB8IHVuZGVmaW5lZCA9PiB7XG4gICAgICBmb3IgKGNvbnN0IFtzcXVhcmUsIHZhbHVlXSBvZiBib2FyZC5lbnRyaWVzKCkpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHZhbHVlLnBpZWNlICYmXG4gICAgICAgICAgdmFsdWUucGllY2UudHlwZSA9PT0gJ2tpbmcnICYmXG4gICAgICAgICAgdmFsdWUucGllY2UuY29sb3IgPT09IGNvbG9yXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gc3F1YXJlO1xuICAgICAgfVxuICAgIH0sXG4gICAgcGllY2VNYXA6ICgpOiBBbGxQaWVjZU1hcCA9PiB7XG4gICAgICBjb25zdCBwaWVjZU1hcCA9IHsgd2hpdGU6IHt9IGFzIFBpZWNlTWFwLCBibGFjazoge30gYXMgUGllY2VNYXAgfTtcbiAgICAgIGZvciAoY29uc3QgW3NxdWFyZSwgdmFsdWVdIG9mIGJvYXJkLmVudHJpZXMoKSkge1xuICAgICAgICBjb25zdCB7IHBpZWNlIH0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKCFwaWVjZSkgY29udGludWU7XG5cbiAgICAgICAgY29uc3QgeyB0eXBlLCBjb2xvciB9ID0gcGllY2U7XG4gICAgICAgIHBpZWNlTWFwW2NvbG9yXVt0eXBlXSA9IHBpZWNlTWFwW2NvbG9yXVt0eXBlXVxuICAgICAgICAgID8gWy4uLnBpZWNlTWFwW2NvbG9yXVt0eXBlXSwgc3F1YXJlXVxuICAgICAgICAgIDogW3NxdWFyZV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcGllY2VNYXA7XG4gICAgfSxcbiAgICBzcXVhcmVzR2l2aW5nQ2hlY2tBZnRlck1vdmU6IChmcm9tOiBTcXVhcmUsIGVuZDogU3F1YXJlKTogU3F1YXJlW10gPT4ge1xuICAgICAgY29uc3Qgc3F1YXJlc0dpdmluZ0NoZWNrOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgICBjb25zdCBwaWVjZSA9IGJvYXJkLmdldChlbmQpPy5waWVjZSBhcyBQaWVjZU9iajtcbiAgICAgIGNvbnN0IG9wcENvbG9yID0gcGllY2UuY29sb3IgPT09ICd3aGl0ZScgPyAnYmxhY2snIDogJ3doaXRlJztcbiAgICAgIGNvbnN0IGtpbmdQb3NpdGlvbiA9IGdldC5raW5nUG9zaXRpb24ob3BwQ29sb3IpIGFzIFNxdWFyZTtcblxuICAgICAgY29uc3QgcGllY2VIaXRzS2luZyA9IGdldExlZ2FsTW92ZXMoZW5kLCBib2FyZCkuaW5jbHVkZXMoa2luZ1Bvc2l0aW9uKTtcbiAgICAgIGlmIChwaWVjZUhpdHNLaW5nKSBzcXVhcmVzR2l2aW5nQ2hlY2sucHVzaChlbmQpO1xuXG4gICAgICBjb25zdCBkaXNjb3ZlcmVkQ2hlY2sgPSBnZXREaXNjb3ZlcmVkQ2hlY2soXG4gICAgICAgIGtpbmdQb3NpdGlvbixcbiAgICAgICAgb3BwQ29sb3IsXG4gICAgICAgIGZyb20sXG4gICAgICAgIGJvYXJkXG4gICAgICApO1xuICAgICAgaWYgKGRpc2NvdmVyZWRDaGVjaykgc3F1YXJlc0dpdmluZ0NoZWNrLnB1c2goZGlzY292ZXJlZENoZWNrKTtcblxuICAgICAgcmV0dXJuIHNxdWFyZXNHaXZpbmdDaGVjaztcbiAgICB9LFxuICAgIGlzQ2hlY2ttYXRlOiAoY29sb3I6IENvbG9yLCBzcXVhcmVzR2l2aW5nQ2hlY2s6IHN0cmluZ1tdKTogYm9vbGVhbiA9PiB7XG4gICAgICBjb25zdCBraW5nUG9zID0gZ2V0LmtpbmdQb3NpdGlvbihjb2xvcikgYXMgU3F1YXJlO1xuICAgICAgY29uc3QgbGVnYWxNb3ZlcyA9IGF0KGtpbmdQb3MpLmdldExlZ2FsTW92ZXMoKTtcbiAgICAgIC8vIGNoZWNrIGlmIGNoZWNrIGNhbiBiZSBibG9ja2VkXG4gICAgICBpZiAoc3F1YXJlc0dpdmluZ0NoZWNrLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAoY2FuQmxvY2tPckNhcHR1cmVDaGVjayhraW5nUG9zLCBzcXVhcmVzR2l2aW5nQ2hlY2tbMF0sIGJvYXJkKSlcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAobGVnYWxNb3Zlcy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgY2FzdGxlU3F1YXJlcyhjb2xvcjogQ29sb3IpOiBDYXN0bGVTcXVhcmVzVHlwZSB7XG4gICAgICBjb25zdCByYW5rID0gY29sb3IgPT09ICd3aGl0ZScgPyAxIDogODtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtpbmdzaWRlOiBbYGYke3Jhbmt9YCwgYGcke3Jhbmt9YF0sXG4gICAgICAgIHF1ZWVuc2lkZTogW2BkJHtyYW5rfWAsIGBjJHtyYW5rfWBdXG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICBjb25zdCB2YWxpZGF0ZSA9IHtcbiAgICBtb3ZlOiAoZnJvbTogU3F1YXJlLCB0bzogU3F1YXJlKTogYm9vbGVhbiA9PiB7XG4gICAgICBjb25zdCBwaWVjZSA9IGF0KGZyb20pLnBpZWNlO1xuICAgICAgaWYgKCFwaWVjZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBpZiAoIWF0KGZyb20pLmdldExlZ2FsTW92ZXMoKS5pbmNsdWRlcyh0bykpIHJldHVybiBmYWxzZTtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBwcm9tb3Rpb246IChmcm9tOiBTcXVhcmUsIHRvOiBTcXVhcmUpOiBib29sZWFuID0+IHtcbiAgICAgIGNvbnN0IHBpZWNlID0gYXQoZnJvbSkucGllY2U7XG5cbiAgICAgIGlmIChwaWVjZT8udHlwZSAhPT0gJ3Bhd24nKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGNvbnN0IGVuZE9mQm9hcmQgPSBwaWVjZS5jb2xvciA9PT0gJ3doaXRlJyA/IDggOiAxO1xuICAgICAgY29uc3QgWywgcmFua10gPSB0by5zcGxpdCgnJyk7XG4gICAgICBpZiAoK3JhbmsgIT09IGVuZE9mQm9hcmQpIHJldHVybiBmYWxzZTtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgY3JlYXRlQm9hcmQsXG4gICAgY2FzdGxpbmcsXG4gICAgZW5QYXNzYW50LFxuICAgIGF0LFxuICAgIGZyb20sXG4gICAgZ2V0LFxuICAgIHZhbGlkYXRlLFxuICAgIG1ha2VNb3ZlLFxuICAgIGdldCBib2FyZCgpIHtcbiAgICAgIHJldHVybiBib2FyZDtcbiAgICB9XG4gIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBHYW1lYm9hcmQ7XG4iLCIvLyBzaG91bGQgb3V0cHV0IGhpc3Rvcnkgb2JqZWN0IHRoYXQgaG9sZHMgbW92ZSBoaXN0b3J5IGluIDJkIGFycmF5XG4vLyBmb3IgZWFjaCBtb3ZlIG5lZWRzIHRvIGF0dGFjaCBwaWVjZSBUeXBlIHRvIGJlZ2lubmluZyBvZiBtb3ZlIGlmIG5vdCBwYXduXG4vLyBzaG91bGQgZnVydGhlciBzcGVjaWZ5IHNxdWFyZSBvZiBwaWVjZSBpZiwgc2F5IGJvdGggcm9va3MsIGNhbiBtb3ZlIHRvIHNhbWUgc3F1YXJlXG5cbmltcG9ydCB7IEFsbFBpZWNlTWFwLCBIaXN0b3J5T2JqLCBQaWVjZU9iaiB9IGZyb20gJy4vdHlwZXMvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBCb2FyZCwgUGllY2VUeXBlLCBTcXVhcmUgfSBmcm9tICcuL3R5cGVzL3R5cGVzJztcbmltcG9ydCB7IGdldExlZ2FsTW92ZXMgfSBmcm9tICcuL3V0aWxzL21vdmVzJztcblxudHlwZSBIaXN0b3J5VHlwZSA9IFNxdWFyZVtdW107XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhpc3RvcnkoXG4gIHByZXZIaXN0b3J5OiBIaXN0b3J5VHlwZSxcbiAgYm9hcmQ6IEJvYXJkLFxuICBwaWVjZU1hcDogQWxsUGllY2VNYXBcbik6IEhpc3RvcnlPYmoge1xuICBjb25zdCBoaXN0b3J5OiBIaXN0b3J5VHlwZSA9IHByZXZIaXN0b3J5IHx8IFtdO1xuXG4gIGNvbnN0IGdldCA9IHtcbiAgICBwaWVjZVByZWZpeDogKGZyb206IFNxdWFyZSwgdG86IFNxdWFyZSkgPT4ge1xuICAgICAgY29uc3QgeyB0eXBlLCBjb2xvciB9ID0gYm9hcmQuZ2V0KHRvKT8ucGllY2UgYXMgUGllY2VPYmo7XG5cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdwYXduJzpcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIGNhc2UgJ2tuaWdodCc6XG4gICAgICAgIGNhc2UgJ3Jvb2snOiB7XG4gICAgICAgICAgbGV0IHByZWZpeCA9IHR5cGUgPT09ICdyb29rJyA/ICdSJyA6ICdOJztcbiAgICAgICAgICBpZiAocGllY2VNYXBbY29sb3JdW3R5cGVdLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgLy8gbG9vayBmb3IgcGllY2Ugb2Ygc2FtZSB0eXBlIHRoYXQgY291bGR2ZSBhbHNvIHdlbnQgdG8gdGhlIHNxdWFyZVxuICAgICAgICAgICAgcGllY2VNYXBbY29sb3JdW3R5cGVdLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHMgPT09IHRvKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgY29uc3QgYm9hcmRDb3B5ID0gbmV3IE1hcChib2FyZCk7XG4gICAgICAgICAgICAgIGJvYXJkQ29weS5zZXQodG8sIHsgcGllY2U6IG51bGwgfSk7XG5cbiAgICAgICAgICAgICAgaWYgKGdldExlZ2FsTW92ZXMocywgYm9hcmRDb3B5KS5pbmNsdWRlcyh0bykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbeDEsIHkxXSA9IGZyb20uc3BsaXQoJycpO1xuICAgICAgICAgICAgICAgIGNvbnN0IFt4Ml0gPSBzLnNwbGl0KCcnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzYW1lRmlsZSA9IHgxID09PSB4MjtcblxuICAgICAgICAgICAgICAgIHByZWZpeCA9IHNhbWVGaWxlID8gcHJlZml4ICsgeTEgOiBwcmVmaXggKyB4MTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHByZWZpeDtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY29uc3QgcHJlZml4ID0gdHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICByZXR1cm4gcHJlZml4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjYXN0bGVOb3RhdGlvbjogKHNpZGU6ICdraW5nc2lkZScgfCAncXVlZW5zaWRlJykgPT4ge1xuICAgICAgcmV0dXJuIHNpZGUgPT09ICdraW5nc2lkZScgPyAnTy1PJyA6ICdPLU8tTyc7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGFmZml4ID0ge1xuICAgIGNhcHR1cmU6IChtb3ZlOiBTcXVhcmUsIHByZWZpeDogc3RyaW5nKSA9PiB7XG4gICAgICByZXR1cm4gYCR7cHJlZml4fXgke21vdmV9YDtcbiAgICB9LFxuICAgIHByb21vdGU6IChtb3ZlOiBTcXVhcmUsIHBpZWNlVHlwZTogUGllY2VUeXBlKSA9PiB7XG4gICAgICBjb25zdCBzdWZmaXggPVxuICAgICAgICBwaWVjZVR5cGUgPT09ICdrbmlnaHQnID8gJ04nIDogcGllY2VUeXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICByZXR1cm4gYCR7bW92ZX09JHtzdWZmaXh9YDtcbiAgICB9LFxuICAgIGNoZWNrOiAobm90YXRpb246IHN0cmluZykgPT4ge1xuICAgICAgcmV0dXJuIGAke25vdGF0aW9ufStgO1xuICAgIH0sXG4gICAgY2hlY2ttYXRlOiAobm90YXRpb246IHN0cmluZykgPT4ge1xuICAgICAgcmV0dXJuIGAke25vdGF0aW9ufSNgO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGdldCxcbiAgICBhZmZpeCxcbiAgICBpbnNlcnRNb3ZlOiAobm90YXRpb246IHN0cmluZykgPT4ge1xuICAgICAgY29uc3QgbGFzdE1vdmVQYWlyID0gaGlzdG9yeVtoaXN0b3J5Lmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGxhc3RNb3ZlUGFpci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgbGFzdE1vdmVQYWlyLnB1c2gobm90YXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbmV3TW92ZVBhaXIgPSBbbm90YXRpb25dO1xuICAgICAgICBoaXN0b3J5LnB1c2gobmV3TW92ZVBhaXIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbiIsImltcG9ydCB7IEFsbFBpZWNlTWFwIH0gZnJvbSAnLi90eXBlcy9pbnRlcmZhY2VzJztcblxuY29uc3Qgc3RhbmRhcmQ6IEFsbFBpZWNlTWFwID0ge1xuICB3aGl0ZToge1xuICAgIHJvb2s6IFsnYTEnLCAnaDEnXSxcbiAgICBrbmlnaHQ6IFsnZzEnLCAnYjEnXSxcbiAgICBiaXNob3A6IFsnZjEnLCAnYzEnXSxcbiAgICBraW5nOiBbJ2UxJ10sXG4gICAgcXVlZW46IFsnZDEnXSxcbiAgICBwYXduOiBbJ2EyJywgJ2IyJywgJ2MyJywgJ2QyJywgJ2UyJywgJ2YyJywgJ2cyJywgJ2gyJ11cbiAgfSxcbiAgYmxhY2s6IHtcbiAgICByb29rOiBbJ2E4JywgJ2g4J10sXG4gICAga25pZ2h0OiBbJ2c4JywgJ2I4J10sXG4gICAgYmlzaG9wOiBbJ2Y4JywgJ2M4J10sXG4gICAga2luZzogWydlOCddLFxuICAgIHF1ZWVuOiBbJ2Q4J10sXG4gICAgcGF3bjogWydhNycsICdiNycsICdjNycsICdkNycsICdlNycsICdmNycsICdnNycsICdoNyddXG4gIH1cbn07XG5cbmV4cG9ydCB7IHN0YW5kYXJkIH07XG4iLCJpbXBvcnQgR2FtZWJvYXJkIGZyb20gJy4vR2FtZWJvYXJkJztcbmltcG9ydCBIaXN0b3J5IGZyb20gJy4vSGlzdG9yeSc7XG5pbXBvcnQgQ2FzdGxlIGZyb20gJy4vQ2FzdGxlJztcbmltcG9ydCAqIGFzIHN0YXJ0aW5nUG9zaXRpb25zIGZyb20gJy4vc3RhcnRpbmdQb3NpdGlvbnMnO1xuaW1wb3J0IHsgcmFua3MsIGZpbGVzIH0gZnJvbSAnLi9yYW5rc0FuZEZpbGVzJztcblxuZXhwb3J0IHsgR2FtZWJvYXJkLCBIaXN0b3J5LCBDYXN0bGUsIHN0YXJ0aW5nUG9zaXRpb25zLCByYW5rcywgZmlsZXMgfTtcbiJdLCJuYW1lcyI6WyJ0b1hZIiwic3F1YXJlIiwieCIsInkiLCJzcGxpdCIsImluZGV4T2YiLCJ0b0xvd2VyQ2FzZSIsIk51bWJlciIsImZyb21YWSIsImNvb3JkIiwiY29sIiwiY29uY2F0IiwidG9TdHJpbmciLCJjYWxjRGlzdGFuY2UiLCJzcXVhcmVPbmUiLCJzcXVhcmVUd28iLCJ4MSIsInkxIiwieDIiLCJ5MiIsInhEaWZmIiwieURpZmYiLCJtb3ZlcyIsIlBpZWNlIiwiY29sb3IiLCJ0eXBlIiwiaGFzTW92ZSIsImZyb20iLCJ0byIsIm9uZVNxdWFyZVZlcnQiLCJ5QnlOIiwieEJ5TiIsIm9uZVNxdWFyZUxhdGVyYWwiLCJvbmVTcXVhcmVEaWFnb25hbGx5IiwiZGlhZ29uYWwiLCJ2ZXJ0QW5kTGF0ZXJhbCIsIm9ubHlNb3Zlc0luRnJvbnQiLCJyZWd1bGFyTW92ZSIsImZpcnN0TW92ZSIsImp1bXBUd28iLCJnZXRQYXduQ2FwdHVyZXMiLCJvcmlnaW4iLCJuZXdZIiwiY2FwdHVyZU9uZSIsImNhcHR1cmVUd28iLCJNYXRoIiwiYWJzIiwibnVtIiwic3BsaXRJbnRvVmVjdG9ycyIsImFycmF5T2ZNb3ZlcyIsInN0YXJ0IiwicmVkdWNlIiwiYWNjIiwiY3VyciIsInZlY3RvciIsImNoYXJBdCIsInNsaWNlIiwicHVzaCIsImdldEJlZ2lubmluZ09mVmVjdG9yIiwibGVuZ3RoIiwiYWNjSXNCZWdpbm5pbmciLCJnZXRNb3Zlc0Fsb25nVmVjdG9yIiwiczEiLCJzMiIsImFsbFNxdWFyZXMiLCJsaWVzU2FtZVZlcnRPckxhdCIsImxpZXNTYW1lRGlhZ29uYWxseSIsImxpZXNPblNhbWVMaW5lIiwibWF0Y2hpbmdWZWN0b3IiLCJzcXVhcmVzQWxvbmdWZWN0b3IiLCJmaWx0ZXIiLCJzIiwic29ydE1vdmVzQ2xvc2VzdFRvIiwic29ydCIsImEiLCJiIiwieDFEaWZmIiwieTFEaWZmIiwiYURpZmYiLCJ4MkRpZmYiLCJ5MkRpZmYiLCJiRGlmZiIsImdldFBvc3NpYmxlTW92ZXMiLCJib2FyZCIsIkFycmF5Iiwia2V5cyIsImdldCIsInBpZWNlIiwiZ2V0TGVnYWxNb3ZlcyIsInBvc3NpYmxlTW92ZXMiLCJvYnN0cnVjdGlvbnMiLCJfYSIsImxlZ2FsTW92ZXMiLCJjYXB0dXJlc0F2YWlsYWJsZSIsInVub2JzdHJ1Y3RlZE1vdmVzIiwicmVtb3ZlTW92ZXNXaXRoUGllY2VzIiwicmVtb3ZlT2JzdHJ1Y3RlZE1vdmVzIiwicmVtb3ZlUHJvdGVjdGVkU3F1YXJlcyIsImdldExlZ2FsTW92ZXNJbkNoZWNrIiwia2luZ1BvcyIsInNxdWFyZUdpdmluZ0NoZWNrIiwic3F1YXJlc1RoYXREZWFsV2l0aENoZWNrIiwiZ2V0U3F1YXJlc0JldHdlZW5LaW5nQW5kQ2hlY2siLCJpbmNsdWRlcyIsImdldEF0dGFja2luZ01vdmVzIiwiYXR0YWNraW5nTW92ZXMiLCJnZXRBbGxNb3Zlc0ZvckNvbG9yIiwic2tpcEtpbmciLCJhbGxNb3ZlcyIsImVudHJpZXMiLCJmbGF0IiwiZ2V0QXR0YWNraW5nTW92ZXNGb3JDb2xvciIsInBhd25TcXVhcmUiLCJwYXduIiwiY2FwdHVyZU1vdmVzIiwic3F1YXJlVmFsIiwiZW5QYXNzYW50IiwiY2hlY2tQb3MiLCJzcXVhcmVzQmV0d2VlbktpbmdBbmRQaWVjZSIsInJlbW92ZU1vdmVzQmVoaW5kVHdvU3F1YXJlcyIsInNvcnRlZCIsImZ1cnRoZXN0U3F1YXJlIiwiY2xvc2VzdFNxdWFyZSIsInJlbW92ZWRPbmVFbmQiLCJyZW1vdmVNb3Zlc0JlaGluZFNxdWFyZSIsInJlbW92ZWRCb3RoRW5kcyIsInJldmVyc2UiLCJjb3B5IiwiaW5kZXgiLCJzcGxpY2UiLCJzdGFydGluZ1NxdWFyZSIsImZpbHRlcmVkTW92ZXMiLCJhbGxWZWN0b3JzIiwib2JzdHJ1Y3Rpb25WZWN0b3JzIiwiY2xvc2VzdE9ic3RydWN0aW9uIiwia2luZyIsIm9wcENvbG9yIiwiYm9hcmRDb3B5IiwiTWFwIiwiZm9yRWFjaCIsInNldCIsImFsbEVuZW15TW92ZXMiLCJnZXREaXNjb3ZlcmVkQ2hlY2siLCJraW5nQ29sb3IiLCJ2YWNhdGVkIiwiY2FuQmxvY2tPckNhcHR1cmVDaGVjayIsImJsb2NrT3JDYXB0dXJlU3F1YXJlcyIsIm93blBpZWNlTW92ZXMiLCJzb21lIiwibW92ZSIsImZpbGVzIiwicmFua3MiLCJDYXN0bGUiLCJ3aGl0ZUtpbmdzaWRlIiwid2hpdGVRdWVlbnNpZGUiLCJibGFja0tpbmdzaWRlIiwiYmxhY2tRdWVlbnNpZGUiLCJ3aGl0ZSIsImtpbmdzaWRlIiwicXVlZW5zaWRlIiwiYmxhY2siLCJjcmVhdGVCb2FyZCIsImZpbGUiLCJyYW5rIiwiR2FtZWJvYXJkIiwic3F1YXJlc0dpdmluZ0NoZWNrIiwiQ2FzdGxlUmlnaHRzIiwibWFrZU1vdmUiLCJwcm9tb3RlIiwiYXQiLCJ2YWxpZGF0ZSIsInByb21vdGlvbiIsInJlbW92ZSIsImNoZWNrVG9nZ2xlIiwidG9nZ2xlIiwiY2FzdGxlU2lkZSIsImNhc3RsZVNxdWFyZXMiLCJzaWRlIiwic3F1YXJlcyIsIk9iamVjdCIsImNhc3RsaW5nIiwiY2FzdGxlIiwiY2FuQ2FzdGxlIiwiY2hlY2tJZlJvb2tFeGlzdHMiLCJvcHBNb3ZlcyIsInJvb2tFeGlzdHMiLCJsb29wU3RhcnQiLCJsb29wRW5kIiwiaSIsImtpbmdQb3NpdGlvbiIsInJvb2tQb3MiLCJnZXRSb29rUG9zIiwicGllY2VNYXAiLCJyb29rIiwiZmluZCIsImdldFJpZ2h0c0FmdGVyTW92ZSIsImNhc3RsZVJpZ2h0cyIsImdldFNxdWFyZSIsImN1cnJlbnQiLCJlblBhc3NhbnRTcXVhcmUiLCJzZXRFblBhc3NhbnQiLCJzcXVhcmVPYmoiLCJ2YWx1ZXMiLCJ1bmRlZmluZWQiLCJwbGFjZSIsInBpZWNlVHlwZSIsInZhbHVlIiwic3F1YXJlc0dpdmluZ0NoZWNrQWZ0ZXJNb3ZlIiwiZW5kIiwicGllY2VIaXRzS2luZyIsImRpc2NvdmVyZWRDaGVjayIsImlzQ2hlY2ttYXRlIiwiZW5kT2ZCb2FyZCIsIkhpc3RvcnkiLCJwcmV2SGlzdG9yeSIsImhpc3RvcnkiLCJwaWVjZVByZWZpeCIsInByZWZpeCIsInNhbWVGaWxlIiwidG9VcHBlckNhc2UiLCJjYXN0bGVOb3RhdGlvbiIsImFmZml4IiwiY2FwdHVyZSIsInN1ZmZpeCIsImNoZWNrIiwibm90YXRpb24iLCJjaGVja21hdGUiLCJpbnNlcnRNb3ZlIiwibGFzdE1vdmVQYWlyIiwibmV3TW92ZVBhaXIiLCJzdGFuZGFyZCIsImtuaWdodCIsImJpc2hvcCIsInF1ZWVuIiwic3RhcnRpbmdQb3NpdGlvbnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///708\n")}},__webpack_require__={d:(Q,F)=>{for(var B in F)__webpack_require__.o(F,B)&&!__webpack_require__.o(Q,B)&&Object.defineProperty(Q,B,{enumerable:!0,get:F[B]})},o:(Q,F)=>Object.prototype.hasOwnProperty.call(Q,F),r:Q=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})}},__webpack_exports__={};return __webpack_modules__[708](0,__webpack_exports__,__webpack_require__),__webpack_exports__})()}));