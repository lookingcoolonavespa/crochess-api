!function(Q,F){"object"==typeof exports&&"object"==typeof module?module.exports=F():"function"==typeof define&&define.amd?define([],F):"object"==typeof exports?exports.croChess=F():Q.croChess=F()}(this,(()=>(()=>{"use strict";var __webpack_modules__={327:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"Castle\": () => (/* reexport */ Castle),\n  \"Gameboard\": () => (/* reexport */ src_Gameboard),\n  \"History\": () => (/* reexport */ History),\n  \"files\": () => (/* reexport */ files),\n  \"ranks\": () => (/* reexport */ ranks),\n  \"startingPositions\": () => (/* reexport */ startingPositions_namespaceObject)\n});\n\n// NAMESPACE OBJECT: ./src/startingPositions.ts\nvar startingPositions_namespaceObject = {};\n__webpack_require__.r(startingPositions_namespaceObject);\n__webpack_require__.d(startingPositions_namespaceObject, {\n  \"standard\": () => (standard)\n});\n\n;// CONCATENATED MODULE: ./src/utils/helpers.ts\nfunction toXY(square) {\n  const [x, y] = square.split('');\n  return {\n    x: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'].indexOf(x.toLowerCase()),\n    y: Number(y)\n  };\n}\nfunction fromXY(coord) {\n  const {\n    x,\n    y\n  } = coord;\n  const col = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'][x];\n  if (!col) return '';\n  return col.concat(y.toString());\n}\nconst calcDistance = squareOne => squareTwo => {\n  const {\n    x: x1,\n    y: y1\n  } = toXY(squareOne);\n  const {\n    x: x2,\n    y: y2\n  } = toXY(squareTwo);\n  const xDiff = x1 - x2;\n  const yDiff = y1 - y2;\n  return {\n    xDiff,\n    yDiff\n  };\n};\nfunction getPieceFromAbbr(abbr) {\n  switch (abbr) {\n    case 'K':\n      return 'king';\n\n    case 'Q':\n      return 'queen';\n\n    case 'N':\n      return 'knight';\n\n    case 'B':\n      return 'bishop';\n\n    case 'R':\n      return 'rook';\n  }\n}\nfunction parseNotation(notation) {\n  const move = {};\n  const replaced = notation.replace(/[+x#]/, '');\n\n  if (+replaced[0] === 0) {\n    // this is castle\n    move.castle = replaced.length === 3 ? 'kingside' : 'queenside';\n    return move;\n  }\n\n  if (replaced[0].toUpperCase() === replaced[0]) {\n    // this is piece move\n    move.pieceType = getPieceFromAbbr(replaced[0]);\n    move.to = replaced.slice(-2);\n\n    switch (replaced.length) {\n      case 4:\n        move.from = replaced[1];\n        break;\n\n      case 5:\n        move.from = replaced.slice(1, 3);\n        break;\n    }\n\n    return move;\n  } else {\n    // is a pawn move\n    move.pieceType = 'pawn';\n\n    if (replaced.includes('=')) {\n      // indicates promotion\n      move.promote = getPieceFromAbbr(replaced.slice(-1));\n    }\n\n    const promoteNoteIndex = replaced.indexOf('=');\n    const noPromoteNotation = replaced.slice(0, promoteNoteIndex === -1 ? replaced.length : promoteNoteIndex);\n\n    if (noPromoteNotation.length === 3) {\n      move.from = replaced[0];\n    }\n\n    move.to = noPromoteNotation.slice(-2);\n  }\n\n  return move;\n}\nfunction deepCopy2dArray(arr) {\n  return arr.map(n => [...n]);\n}\n;// CONCATENATED MODULE: ./src/Piece.ts\n\n\n\nconst Piece = (color, type) => {\n  function hasMove(from, to) {\n    switch (type) {\n      case 'king':\n        {\n          const oneSquareVert = utils_moves.yByN(1)(from)(to) && utils_moves.xByN(0)(from)(to);\n          const oneSquareLateral = utils_moves.xByN(1)(from)(to) && utils_moves.yByN(0)(from)(to);\n          const oneSquareDiagonally = utils_moves.yByN(1)(from)(to) && utils_moves.xByN(1)(from)(to);\n          return from !== to && (oneSquareDiagonally || oneSquareVert || oneSquareLateral);\n        }\n\n      case 'queen':\n        {\n          return from !== to && (utils_moves.diagonal(from)(to) || utils_moves.vertAndLateral(from)(to));\n        }\n\n      case 'bishop':\n        {\n          return from !== to && utils_moves.diagonal(from)(to);\n        }\n\n      case 'knight':\n        {\n          return from !== to && (utils_moves.xByN(1)(from)(to) && utils_moves.yByN(2)(from)(to) || utils_moves.xByN(2)(from)(to) && utils_moves.yByN(1)(from)(to));\n        }\n\n      case 'rook':\n        {\n          return from !== to && utils_moves.vertAndLateral(to)(from);\n        }\n\n      case 'pawn':\n        {\n          const {\n            x: x1,\n            y: y1\n          } = toXY(from);\n          const {\n            x: x2,\n            y: y2\n          } = toXY(to);\n          const onlyMovesInFront = color === 'white' ? y1 < y2 : y1 > y2;\n          const regularMove = utils_moves.yByN(1)(from)(to) && x1 === x2;\n          const firstMove = color === 'white' ? y1 === 2 : y1 === 7;\n          const jumpTwo = utils_moves.yByN(2)(from)(to) && x1 === x2;\n          return from !== to && onlyMovesInFront && (regularMove || firstMove && jumpTwo);\n        }\n    }\n  }\n\n  function getPawnCaptures(origin) {\n    if (type !== 'pawn') return;\n    const {\n      x,\n      y\n    } = toXY(origin);\n    const newY = color === 'white' ? y + 1 : y - 1;\n    const captureOne = {\n      x: x + 1,\n      y: newY\n    };\n    const captureTwo = {\n      x: x - 1,\n      y: newY\n    };\n    return [fromXY(captureOne), fromXY(captureTwo)];\n  }\n\n  return {\n    hasMove,\n    getPawnCaptures,\n\n    get type() {\n      return type;\n    },\n\n    get color() {\n      return color;\n    }\n\n  };\n};\n\n/* harmony default export */ const src_Piece = (Piece);\n;// CONCATENATED MODULE: ./src/utils/moves.ts\n\n\nconst moves = {\n  vertAndLateral: from => to => {\n    const [x1, y1] = from.split('');\n    const [x2, y2] = to.split('');\n    return x1 === x2 || y1 === y2;\n  },\n  diagonal: from => to => {\n    const {\n      x: x1,\n      y: y1\n    } = toXY(from);\n    const {\n      x: x2,\n      y: y2\n    } = toXY(to);\n    return Math.abs(x2 - x1) === Math.abs(y2 - y1);\n  },\n  xByN: num => from => to => {\n    const {\n      x: x1\n    } = toXY(from);\n    const {\n      x: x2\n    } = toXY(to);\n    return Math.abs(x1 - x2) === num;\n  },\n  yByN: num => from => to => {\n    const {\n      y: y1\n    } = toXY(from);\n    const {\n      y: y2\n    } = toXY(to);\n    return Math.abs(y1 - y2) === num;\n  }\n};\n/* harmony default export */ const utils_moves = (moves);\n/* dealing with move vectors */\n\nfunction splitIntoVectors(arrayOfMoves, start) {\n  return arrayOfMoves.reduce((acc, curr) => {\n    const {\n      xDiff,\n      yDiff\n    } = calcDistance(start)(curr);\n    let vector = '';\n    if (yDiff !== 0) vector = yDiff < 0 ? 'up' : 'down';\n    if (xDiff !== 0) vector += xDiff < 0 ? 'Right' : 'Left'; // normalize vector name\n\n    vector = vector.charAt(0).toLowerCase() + vector.slice(1);\n    acc[vector] = acc[vector] || [];\n    acc[vector].push(curr);\n    return acc;\n  }, {});\n}\n\nfunction getBeginningOfVector(vector) {\n  if (vector.length === 0) return '';\n  return vector.reduce((acc, curr) => {\n    const {\n      x: x1,\n      y: y1\n    } = toXY(acc);\n    const {\n      x: x2,\n      y: y2\n    } = toXY(curr);\n    const accIsBeginning = x1 === x2 ? y1 < y2 : x1 < x2;\n    return accIsBeginning ? acc : curr;\n  });\n}\n\nconst getMovesAlongVector = (s1, s2, allSquares) => {\n  const liesSameVertOrLat = moves.vertAndLateral(s1)(s2);\n  const liesSameDiagonally = moves.diagonal(s1)(s2);\n  const liesOnSameLine = liesSameVertOrLat || liesSameDiagonally;\n  if (!liesOnSameLine) return [];\n  const matchingVector = liesSameDiagonally ? 'diagonal' : 'vertAndLateral';\n  const squaresAlongVector = allSquares.filter(s => moves[matchingVector](s1)(s) && moves[matchingVector](s2)(s));\n  return squaresAlongVector;\n};\n/* sort moves */\n\n\nconst sortMovesClosestTo = square => moves => {\n  return [...moves].sort((a, b) => {\n    const {\n      xDiff: x1Diff,\n      yDiff: y1Diff\n    } = calcDistance(square)(a);\n    const aDiff = Math.abs(x1Diff) + Math.abs(y1Diff);\n    const {\n      xDiff: x2Diff,\n      yDiff: y2Diff\n    } = calcDistance(square)(b);\n    const bDiff = Math.abs(x2Diff) + Math.abs(y2Diff);\n    return aDiff - bDiff;\n  });\n};\n/* get moves */\n\n\nfunction getPossibleMoves(origin, board) {\n  // get all moves that can happen if no other pieces were on the board\n  const allSquares = Array.from(board.keys());\n  const square = board.get(origin);\n  const {\n    type,\n    color\n  } = square.piece;\n  const piece = src_Piece(color, type);\n  return allSquares.filter(s => piece.hasMove(origin, s));\n}\n\nfunction getLegalMoves(origin, board) {\n  // get moves regardless of whether or not there is check\n  const square = board.get(origin);\n  const piece = square.piece;\n  const possibleMoves = getPossibleMoves(origin, board);\n  const obstructions = possibleMoves.filter(s => {\n    var _a;\n\n    return (_a = board.get(s)) === null || _a === void 0 ? void 0 : _a.piece;\n  });\n\n  if (!obstructions.length) {\n    switch (piece.type) {\n      case 'pawn':\n        return [...getPawnCaptures(origin, board), ...possibleMoves];\n\n      case 'king':\n        return removeProtectedSquares(origin, possibleMoves, board);\n\n      default:\n        return possibleMoves;\n    }\n  }\n\n  let legalMoves = [];\n\n  switch (piece.type) {\n    case 'knight':\n      {\n        legalMoves = possibleMoves;\n        break;\n      }\n\n    case 'pawn':\n      {\n        const capturesAvailable = getPawnCaptures(origin, board);\n        const unobstructedMoves = removeMovesWithPieces(removeObstructedMoves(origin, possibleMoves, obstructions), board);\n        legalMoves = [...capturesAvailable, ...unobstructedMoves];\n        break;\n      }\n\n    case 'king':\n      {\n        legalMoves = removeProtectedSquares(origin, possibleMoves, board);\n        break;\n      }\n\n    default:\n      {\n        legalMoves = removeObstructedMoves(origin, possibleMoves, obstructions);\n      }\n  }\n\n  return removeMovesWithPieces(legalMoves, board, piece.color);\n}\n\nfunction getLegalMovesInCheck(origin, board, kingPos, squareGivingCheck) {\n  const squaresThatDealWithCheck = getSquaresBetweenKingAndCheck(kingPos, squareGivingCheck, Array.from(board.keys()));\n  const moves = getLegalMoves(origin, board);\n  return moves.filter(s => squaresThatDealWithCheck.includes(s));\n}\n\nfunction getAttackingMoves(origin, board) {\n  const square = board.get(origin);\n  const {\n    type,\n    color\n  } = square.piece;\n\n  switch (type) {\n    case 'pawn':\n      {\n        const piece = src_Piece(color, 'pawn');\n        return piece.getPawnCaptures(origin);\n      }\n\n    case 'king':\n      {\n        // need to do this because getLegalMoves will recursively call removeProtectedSquares otherwise\n        const attackingMoves = removeMovesWithPieces(getPossibleMoves(origin, board), board, color);\n        return attackingMoves;\n      }\n\n    default:\n      return getLegalMoves(origin, board);\n  }\n}\n\nfunction getAllMovesForColor(color, board, skipKing) {\n  const allMoves = [];\n\n  for (const [square, {\n    piece\n  }] of board.entries()) {\n    if (!piece) continue;\n    if (piece.color !== color) continue;\n    if (skipKing && piece.type === 'king') continue;\n    allMoves.push(getLegalMoves(square, board));\n  }\n\n  return allMoves.flat();\n}\n\nfunction getAttackingMovesForColor(color, board) {\n  const allMoves = [];\n\n  for (const [square, {\n    piece\n  }] of board.entries()) {\n    if (!piece) continue;\n    if (piece.color !== color) continue;\n    allMoves.push(getAttackingMoves(square, board));\n  }\n\n  return allMoves.flat();\n}\n\nfunction getPawnCaptures(pawnSquare, board) {\n  var _a;\n\n  const {\n    color\n  } = (_a = board.get(pawnSquare)) === null || _a === void 0 ? void 0 : _a.piece;\n  const pawn = src_Piece(color, 'pawn');\n  const captureMoves = pawn.getPawnCaptures(pawnSquare);\n  if (!captureMoves) return [];\n  return captureMoves.filter(s => {\n    const squareVal = board.get(s);\n    if (!squareVal) return false;\n    const piece = squareVal.piece;\n    const enPassant = squareVal.enPassant;\n    return piece && piece.color !== pawn.color || enPassant && enPassant.color !== pawn.color;\n  });\n}\n\nfunction getSquaresBetweenKingAndCheck(kingPos, checkPos, allSquares) {\n  // includes kingPos and checkPos\n  const squaresAlongVector = getMovesAlongVector(kingPos, checkPos, allSquares);\n  const squaresBetweenKingAndPiece = removeMovesBehindTwoSquares(kingPos, checkPos, squaresAlongVector);\n  return squaresBetweenKingAndPiece;\n}\n/* filter moves */\n\n\nfunction removeMovesBehindTwoSquares(s1, s2, vector) {\n  const sorted = sortMovesClosestTo(getBeginningOfVector(vector))(vector);\n  let furthestSquare;\n  let closestSquare;\n\n  if (sorted.indexOf(s1) > sorted.indexOf(s2)) {\n    furthestSquare = s1;\n    closestSquare = s2;\n  } else {\n    furthestSquare = s2;\n    closestSquare = s1;\n  }\n\n  const removedOneEnd = removeMovesBehindSquare(furthestSquare)(sorted);\n  const removedBothEnds = removeMovesBehindSquare(closestSquare)(removedOneEnd.reverse());\n  return removedBothEnds;\n}\n\nconst removeMovesBehindSquare = square => moves => {\n  const copy = [...moves];\n  const index = moves.indexOf(square);\n  if (index === -1) return [];\n  copy.splice(index + 1);\n  return copy;\n};\n\nfunction removeObstructedMoves(startingSquare, possibleMoves, obstructions) {\n  // a) split possible moves into vectors (up,down,left,right, and/or diagonals)\n  // b) see which obstructions belong to which vector\n  // c) find the closest obstruction\n  // d) remove all the moves behind that obstruction\n  const filteredMoves = [];\n  const allVectors = splitIntoVectors(possibleMoves, startingSquare);\n  const obstructionVectors = splitIntoVectors(obstructions, startingSquare);\n\n  for (const vector in allVectors) {\n    if (!obstructionVectors[vector]) {\n      // look for vector obstruction is on\n      filteredMoves.push(allVectors[vector]);\n      continue;\n    }\n\n    const sorted = sortMovesClosestTo(startingSquare)(allVectors[vector]);\n    const closestObstruction = sortMovesClosestTo(startingSquare)(obstructionVectors[vector])[0];\n    filteredMoves.push(removeMovesBehindSquare(closestObstruction)(sorted));\n  }\n\n  return filteredMoves.flat();\n}\n\nfunction removeProtectedSquares(kingPos, possibleMoves, board) {\n  var _a;\n\n  const king = (_a = board.get(kingPos)) === null || _a === void 0 ? void 0 : _a.piece;\n  const oppColor = king.color === 'white' ? 'black' : 'white';\n  const enemyPiecesInVicinity = possibleMoves.filter(s => {\n    var _a, _b;\n\n    return ((_b = (_a = board.get(s)) === null || _a === void 0 ? void 0 : _a.piece) === null || _b === void 0 ? void 0 : _b.color) === oppColor;\n  });\n  const squaresProtectedByEnemyInVicinity = enemyPiecesInVicinity.map(s => getAttackingMoves(s, board)).flat(); // bc king cant move if square is protected\n  // set king piece on each square in possible moves to find which squares are protected\n\n  const boardCopy = new Map(board);\n  possibleMoves.forEach(s => boardCopy.set(s, {\n    piece: king\n  }));\n  const squaresProtectedByRange = getAttackingMovesForColor(oppColor, boardCopy);\n  return possibleMoves.filter(s => {\n    return !squaresProtectedByRange.includes(s) && !squaresProtectedByEnemyInVicinity.includes(s);\n  });\n}\n\nfunction removeMovesWithPieces(moves, board, color) {\n  return moves.filter(s => {\n    const squareVal = board.get(s);\n    if (!squareVal) return false;\n    if (color) return !squareVal.piece || squareVal.piece.color !== color;else return !squareVal.piece;\n  });\n}\n/* gameboard checks */\n\n\nfunction getDiscoveredCheck(kingPos, kingColor, vacated, board) {\n  var _a; // openSquare is a square just vacated\n\n\n  let squaresAlongVector = getMovesAlongVector(kingPos, vacated, Array.from(board.keys()));\n  squaresAlongVector = squaresAlongVector.filter(s => s !== kingPos && s !== vacated);\n  if (!squaresAlongVector.length) return '';\n\n  for (const square of squaresAlongVector) {\n    const piece = (_a = board.get(square)) === null || _a === void 0 ? void 0 : _a.piece;\n    if (!piece || piece.color === kingColor) continue;\n    const legalMoves = getLegalMoves(square, board);\n    if (legalMoves.includes(kingPos)) return square;\n  }\n\n  return '';\n}\n\nfunction canBlockOrCaptureCheck(kingPos, squareGivingCheck, board) {\n  var _a;\n\n  const king = (_a = board.get(kingPos)) === null || _a === void 0 ? void 0 : _a.piece;\n  const blockOrCaptureSquares = getSquaresBetweenKingAndCheck(kingPos, squareGivingCheck, Array.from(board.keys())); // also includes check square\n\n  const ownPieceMoves = getAllMovesForColor(king.color, board, true);\n  return ownPieceMoves.some(move => blockOrCaptureSquares.includes(move));\n}\n\nfunction getPiecesWithMove(board, move, pieceType, color) {\n  const pieceSquares = [];\n\n  for (const [square, {\n    piece\n  }] of board.entries()) {\n    if (!piece) continue;\n    if (piece.color !== color) continue;\n    if (piece.type !== pieceType) continue;\n  }\n}\n\n\n;// CONCATENATED MODULE: ./src/ranksAndFiles.ts\nconst files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];\nconst ranks = [1, 2, 3, 4, 5, 6, 7, 8];\n\n;// CONCATENATED MODULE: ./src/Castle.ts\nfunction Castle(whiteKingside, whiteQueenside, blackKingside, blackQueenside) {\n  return {\n    white: {\n      kingside: whiteKingside,\n      queenside: whiteQueenside\n    },\n    black: {\n      kingside: blackKingside,\n      queenside: blackQueenside\n    }\n  };\n}\n;// CONCATENATED MODULE: ./src/moveNotation.ts\nconst moveNotation = notation => {\n  function castle(side) {\n    notation = side === 'kingside' ? '0-0' : '0-0-0';\n    return notation;\n  }\n\n  const affix = {\n    pieceNotation: (pieceType, differentiation) => {\n      differentiation = differentiation || '';\n\n      switch (pieceType) {\n        case 'pawn':\n          {\n            notation = differentiation + notation;\n            return notation;\n          }\n\n        case 'king':\n          {\n            notation = 'K' + notation;\n            return notation;\n          }\n\n        case 'knight':\n          {\n            notation = 'N' + differentiation + notation;\n            return notation;\n          }\n\n        default:\n          {\n            notation = pieceType[0].toUpperCase() + differentiation + notation;\n            return notation;\n          }\n      }\n    },\n    capture: () => {\n      notation = `x${notation}`;\n      return notation;\n    },\n    promote: pieceType => {\n      const suffix = '=' + pieceType === 'knight' ? 'N' : pieceType.charAt(0).toUpperCase();\n      notation += '=' + suffix;\n      return notation;\n    },\n    check: () => {\n      notation += '+';\n      return notation;\n    },\n    checkmate: () => {\n      notation += '#';\n      return notation;\n    }\n  };\n\n  function get(moveDetails) {\n    const {\n      capture,\n      castle: castleSide,\n      promote,\n      check,\n      checkmate,\n      pieceType,\n      differentiation\n    } = moveDetails;\n    if (castleSide) return castle(castleSide);\n    if (capture) affix.capture();\n    affix.pieceNotation(pieceType, differentiation);\n    if (promote) affix.promote(promote);\n    if (checkmate) affix.checkmate();else if (check) affix.check();\n    return notation;\n  }\n\n  return {\n    get\n  };\n};\n\n/* harmony default export */ const src_moveNotation = (moveNotation);\n;// CONCATENATED MODULE: ./src/Gameboard.ts\n\n\n\n\n\n\n\n\nfunction createBoard() {\n  return files.reduce((acc, file) => {\n    ranks.forEach(rank => {\n      const square = file.concat(rank.toString());\n      acc.set(square, {\n        piece: null\n      });\n    });\n    return acc;\n  }, new Map());\n}\n\nconst Gameboard = (board = createBoard(), squaresGivingCheck, CastleRights) => {\n  board = new Map(board);\n\n  function placePieces(pieceMap, boardMap = board) {\n    let color;\n\n    for (color in pieceMap) {\n      const map = pieceMap[color];\n      let pieceType;\n\n      for (pieceType in map) {\n        const squares = map[pieceType];\n        squares.forEach(s => at(s, boardMap).place({\n          type: pieceType,\n          color: color\n        }));\n      }\n    }\n  }\n\n  function makeMove(s1, s2, promote) {\n    const piece = at(s1).piece; // validate move\n\n    if (!piece) return;\n    if (!validate.move(s1, s2)) return;\n    if (promote && !validate.promotion(s1, s2)) return;\n\n    switch (piece.type) {\n      case 'pawn':\n        {\n          if (promote) {\n            at(s1).promote(promote);\n          }\n\n          if (enPassant.isCapture(s1, s2)) {\n            enPassant.capture(s2);\n          }\n\n          enPassant.remove();\n\n          if (enPassant.checkToggle(s1, s2)) {\n            enPassant.toggle(piece.color, s2);\n          }\n\n          from(s1).to(s2);\n          break;\n        }\n\n      case 'king':\n        {\n          // check if move is castle\n          const castleSide = get.castleSide(piece.color, s2);\n          if (castleSide) castle(piece.color, castleSide);else from(s1).to(s2);\n          enPassant.remove();\n          break;\n        }\n\n      default:\n        from(s1).to(s2);\n        enPassant.remove();\n    }\n\n    return board;\n  }\n\n  function castle(color, side, boardMap = board) {\n    const castleSquares = get.castleSquares(color)[side];\n    const kingPos = get.kingPosition(color, boardMap);\n    const rookPos = getRookPos();\n    from(rookPos, boardMap).to(castleSquares[0]);\n    from(kingPos, boardMap).to(castleSquares[1]);\n\n    function getRookPos() {\n      const pieceMap = get.pieceMap(boardMap);\n      const rookPos = pieceMap[color].rook.find(square => {\n        const file = square.split('')[0];\n        return side === 'kingside' ? files.indexOf(file) > 3 : files.indexOf(file) < 3;\n      });\n      return rookPos;\n    } // need to get king position\n    // need to get castle squares\n    // need to find rook\n\n  }\n\n  const enPassant = (() => {\n    function getSquare(current, color) {\n      const {\n        x,\n        y\n      } = toXY(current);\n      const newY = color === 'white' ? y - 1 : y + 1;\n      return fromXY({\n        x,\n        y: newY\n      });\n    }\n\n    return {\n      checkToggle: (from, to) => {\n        const {\n          y: y1\n        } = toXY(from);\n        const {\n          y: y2\n        } = toXY(to);\n        return Math.abs(y1 - y2) === 2;\n      },\n      toggle: (color, current, boardMap = board) => {\n        const enPassantSquare = getSquare(current, color);\n        at(enPassantSquare, boardMap).setEnPassant(color, current);\n      },\n      remove: (boardMap = board) => {\n        for (const squareObj of boardMap.values()) {\n          if (squareObj.enPassant) return squareObj.enPassant = undefined;\n        }\n      },\n      isCapture: (from, to, boardMap = board) => {\n        var _a;\n\n        const piece = at(from, boardMap).piece;\n        const enPassant = (_a = boardMap.get(to)) === null || _a === void 0 ? void 0 : _a.enPassant;\n        if (!piece || piece.type !== 'pawn') return false;\n        if (!enPassant) return false;\n        if (enPassant.color === piece.color) return false;\n        return true;\n      },\n      capture: (to, boardMap = board) => {\n        var _a;\n\n        const enPassant = (_a = boardMap.get(to)) === null || _a === void 0 ? void 0 : _a.enPassant;\n        at(enPassant.current, boardMap).remove();\n      }\n    };\n  })();\n\n  const at = (square, boardMap = board) => ({\n    place: piece => {\n      if (!boardMap.get(square)) return;\n      boardMap.set(square, {\n        piece\n      });\n    },\n    remove: () => {\n      if (!boardMap.get(square)) return;\n      boardMap.set(square, {\n        piece: null\n      });\n    },\n    promote: pieceType => {\n      const squareVal = boardMap.get(square);\n      const piece = squareVal === null || squareVal === void 0 ? void 0 : squareVal.piece;\n      if (!piece) return;\n      boardMap.set(square, Object.assign(Object.assign({}, squareVal), {\n        piece: Object.assign(Object.assign({}, piece), {\n          type: pieceType\n        })\n      }));\n    },\n    setEnPassant: (color, current) => {\n      if (!boardMap.get(square)) return;\n      boardMap.set(square, {\n        piece: null,\n        enPassant: {\n          current\n          /* square pawn is on */\n          ,\n          color\n        }\n      });\n    },\n\n    get piece() {\n      var _a;\n\n      return (_a = boardMap.get(square)) === null || _a === void 0 ? void 0 : _a.piece;\n    },\n\n    getLegalMoves: (checks = squaresGivingCheck || []) => {\n      const {\n        type,\n        color\n      } = at(square, boardMap).piece;\n\n      switch (checks.length) {\n        case 2:\n          {\n            if (type !== 'king') return [];\n            return getLegalMoves(square, boardMap);\n          }\n\n        case 1:\n          {\n            if (type === 'king') return getLegalMoves(square, boardMap);else return getLegalMovesInCheck(square, boardMap, get.kingPosition(color), checks[0]);\n          }\n\n        default:\n          {\n            if (type === 'king') {\n              let legalMoves = getLegalMoves(square, boardMap);\n              if (get.canCastle(color, 'kingside')) legalMoves = [...legalMoves, ...get.castleSquares(color).kingside];\n              if (get.canCastle(color, 'queenside')) legalMoves = [...legalMoves, ...get.castleSquares(color).queenside];\n              return legalMoves;\n            } else return getLegalMoves(square, boardMap);\n          }\n      }\n    }\n  });\n\n  const from = (s1, boardMap = board) => ({\n    to: s2 => {\n      const piece = at(s1, boardMap).piece;\n      if (!piece) return; // move piece\n\n      at(s1, boardMap).remove();\n      at(s2, boardMap).place(piece);\n    }\n  });\n\n  const get = {\n    kingPosition: (color, boardMap = board) => {\n      for (const [square, value] of boardMap.entries()) {\n        if (value.piece && value.piece.type === 'king' && value.piece.color === color) return square;\n      }\n    },\n    pieceMap: (boardMap = board) => {\n      const pieceMap = {\n        white: {},\n        black: {}\n      };\n\n      for (const [square, value] of boardMap.entries()) {\n        const {\n          piece\n        } = value;\n        if (!piece) continue;\n        const {\n          type,\n          color\n        } = piece;\n        pieceMap[color][type] = pieceMap[color][type] ? [...pieceMap[color][type], square] : [square];\n      }\n\n      return pieceMap;\n    },\n    piecesThatHitSquare: (color, pieceType, square, boardMap = board) => {\n      const pieceMap = get.pieceMap(boardMap);\n      if (pieceMap[color][pieceType].includes(square)) return [];\n      const pieces = [];\n      if (pieceMap[color][pieceType].length <= 1) return [];\n      pieceMap[color][pieceType].forEach(s => {\n        if (at(s, boardMap).getLegalMoves().includes(square)) pieces.push(s);\n      });\n      return pieces;\n    },\n    squaresGivingCheckAfterMove: (from, end) => {\n      var _a;\n\n      const squaresGivingCheck = [];\n      const piece = (_a = board.get(end)) === null || _a === void 0 ? void 0 : _a.piece;\n      const oppColor = piece.color === 'white' ? 'black' : 'white';\n      const kingPosition = get.kingPosition(oppColor);\n      const pieceHitsKing = getLegalMoves(end, board).includes(kingPosition);\n      if (pieceHitsKing) squaresGivingCheck.push(end);\n      const discoveredCheck = getDiscoveredCheck(kingPosition, oppColor, from, board);\n      if (discoveredCheck && discoveredCheck !== end) squaresGivingCheck.push(discoveredCheck);\n      return squaresGivingCheck;\n    },\n    isCheckmate: (colorOfKing, squaresGivingCheck, boardMap = board) => {\n      const kingPos = get.kingPosition(colorOfKing, boardMap);\n      const legalMoves = at(kingPos, boardMap).getLegalMoves(); // check if check can be blocked\n\n      if (squaresGivingCheck.length === 1) {\n        if (canBlockOrCaptureCheck(kingPos, squaresGivingCheck[0], boardMap)) return false;\n      }\n\n      if (legalMoves.length) return false;\n      return true;\n    },\n\n    castleSquares(color) {\n      const rank = color === 'white' ? 1 : 8;\n      return {\n        kingside: [`f${rank}`, `g${rank}`],\n        queenside: [`d${rank}`, `c${rank}`]\n      };\n    },\n\n    castleSide(color, to) {\n      let castleSide = '';\n      const castleSquares = get.castleSquares(color);\n\n      for (const [side, squares] of Object.entries(castleSquares)) {\n        if (squares[1] === to) castleSide = side;\n      }\n\n      return castleSide;\n    },\n\n    castleRightsAfterMove: (square, boardMap = board) => {\n      const piece = at(square, boardMap).piece;\n      const castleRights = CastleRights || Castle(true, true, true, true);\n\n      if (castleRights[piece.color].kingside || castleRights[piece.color].queenside) {\n        // check if i need to change castling rights\n        if (piece.type === 'king') {\n          castleRights[piece.color].kingside = false;\n          castleRights[piece.color].queenside = false;\n        }\n\n        if (piece.type === 'rook') {\n          // need to find if it is kingside or queenside rook\n          const [file] = square.split('');\n          const kingside = files.indexOf(file) > 3;\n          if (kingside) castleRights[piece.color].kingside = false;else castleRights[piece.color].queenside = false;\n        }\n      }\n\n      return castleRights;\n    },\n    canCastle: (color, side, boardMap = board) => {\n      if (CastleRights && !CastleRights[color][side]) return false; // check if rook still exists\n\n      if (!checkIfRookExists()) return false;\n      const oppColor = color === 'white' ? 'black' : 'white';\n      const oppMoves = getAttackingMovesForColor(oppColor, boardMap);\n      const castleSquares = get.castleSquares(color)[side];\n\n      for (const square of castleSquares) {\n        // check if castle square is cleared\n        if (at(square, boardMap).piece) return false; // make sure castle square isnt attacked\n\n        if (oppMoves.includes(square)) return false;\n      }\n\n      return true;\n\n      function checkIfRookExists() {\n        let rookExists = false;\n        const rank = color === 'white' ? 1 : 8;\n        const loopStart = side === 'queenside' ? files.indexOf('a') : files.indexOf('d');\n        const loopEnd = side === 'queenside' ? files.indexOf('e') : files.indexOf('h');\n\n        for (let i = loopStart; i <= loopEnd; i++) {\n          const square = files[i] + rank;\n          const piece = at(square, boardMap).piece;\n          if (!piece) continue;\n          if (piece.type === 'rook') rookExists = true;\n        }\n\n        return rookExists;\n      }\n    },\n    boardStateFromHistory: history => {\n      const boardStates = [];\n      const boardMap = createBoard();\n      placePieces(standard, boardMap);\n      let pieceMap = standard; // history is 2d array\n\n      const flat = history.flat();\n      /* iterate over history */\n\n      for (const [i, m] of flat.entries()) {\n        const parsed = parseNotation(m);\n        const color = i % 2 === 0 ? 'white' : 'black';\n\n        if (parsed.castle) {\n          castle(color, parsed.castle, boardMap);\n          pieceMap = get.pieceMap(boardMap);\n          boardStates.push(new Map(boardMap));\n          continue;\n        }\n\n        const possiblePieces = pieceMap[color][parsed.pieceType].filter(s => getLegalMoves(s, boardMap).includes(parsed.to)); // get 'from' square\n\n        let s1;\n\n        if (parsed.from) {\n          const notation = parsed.from;\n          if (notation.length === 2) s1 = notation;else {\n            s1 = possiblePieces.find(s => {\n              // if notation is a number, that means piece is on the rank === notation, if not, same file\n              return isNaN(Number(notation)) ? s[0] === notation : s[1] === notation;\n            }) || '';\n          }\n        } else s1 = possiblePieces[0];\n\n        const piece = at(s1, boardMap).piece;\n\n        if (!s1 || !piece) {\n          break;\n        } // make move\n\n\n        if (piece.type === 'pawn') {\n          if (enPassant.isCapture(s1, parsed.to, boardMap)) {\n            enPassant.capture(parsed.to, boardMap);\n          }\n\n          enPassant.remove(boardMap);\n          if (enPassant.checkToggle(s1, parsed.to)) enPassant.toggle(color, parsed.to, boardMap);\n\n          if (parsed.promote) {\n            at(s1, boardMap).promote(parsed.promote);\n          }\n        } else enPassant.remove(boardMap);\n\n        from(s1, boardMap).to(parsed.to);\n        pieceMap = get.pieceMap(boardMap);\n        boardStates.push(new Map(boardMap));\n      }\n\n      return boardStates;\n    },\n\n    moveNotation(from, to, promote, check, checkmate, boardMap = board) {\n      var _a;\n\n      const moveDetails = {};\n      const {\n        type,\n        color\n      } = at(from, boardMap).piece;\n      moveDetails.pieceType = type;\n      if (checkmate) moveDetails.checkmate = checkmate;else if (check) moveDetails.check = check;\n      let capture = false;\n\n      switch (type) {\n        case 'pawn':\n          {\n            capture = (_a = src_Piece(color, type).getPawnCaptures(from)) === null || _a === void 0 ? void 0 : _a.includes(to);\n            moveDetails.capture = capture;\n            if (capture) moveDetails.differentiation = from[0];\n            break;\n          }\n\n        default:\n          {\n            capture = !!at(to, boardMap).piece;\n            moveDetails.capture = capture;\n          }\n      }\n\n      if (promote) moveDetails.promote = promote; // get differentiation ie. when multiple pieces hit the same square\n\n      const piecesThatHitSquare = get.piecesThatHitSquare(color, type, to, boardMap);\n\n      switch (piecesThatHitSquare.length) {\n        case 3:\n          moveDetails.differentiation = from;\n          break;\n\n        case 2:\n          {\n            // need to find if on same file or rank\n            const otherPiece = piecesThatHitSquare.find(s => s !== from);\n            moveDetails.differentiation = otherPiece[0] === from[0] ? from[1] : from[0];\n          }\n      }\n\n      return src_moveNotation(to).get(moveDetails);\n    }\n\n  };\n  const validate = {\n    move: (from, to, boardMap = board) => {\n      const piece = at(from, boardMap).piece;\n      if (!piece) return false;\n      if (!at(from, boardMap).getLegalMoves().includes(to)) return false;\n      return true;\n    },\n    promotion: (from, to, boardMap = board) => {\n      const piece = at(from, boardMap).piece;\n      if ((piece === null || piece === void 0 ? void 0 : piece.type) !== 'pawn') return false;\n      const endOfBoard = piece.color === 'white' ? 8 : 1;\n      const [, rank] = to.split('');\n      if (+rank !== endOfBoard) return false;\n      return true;\n    }\n  };\n  return {\n    createBoard,\n    placePieces,\n    castle,\n    enPassant,\n    at,\n    from,\n    get,\n    validate,\n    makeMove,\n\n    get board() {\n      return board;\n    }\n\n  };\n};\n\n/* harmony default export */ const src_Gameboard = (Gameboard);\n;// CONCATENATED MODULE: ./src/History.ts\n\nfunction History(prevHistory) {\n  const history = deepCopy2dArray(prevHistory) || [];\n  return {\n    insertMove: notation => {\n      const lastPair = history[history.length - 1];\n\n      if (lastPair && lastPair.length === 1) {\n        lastPair.push(notation);\n      } else {\n        const newPair = [notation];\n        history.push(newPair);\n      }\n\n      return history;\n    }\n  };\n}\n;// CONCATENATED MODULE: ./src/startingPositions.ts\nconst standard = {\n  white: {\n    rook: ['a1', 'h1'],\n    knight: ['g1', 'b1'],\n    bishop: ['f1', 'c1'],\n    king: ['e1'],\n    queen: ['d1'],\n    pawn: ['a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2']\n  },\n  black: {\n    rook: ['a8', 'h8'],\n    knight: ['g8', 'b8'],\n    bishop: ['f8', 'c8'],\n    king: ['e8'],\n    queen: ['d8'],\n    pawn: ['a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7']\n  }\n};\n\n;// CONCATENATED MODULE: ./src/main.ts\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzI3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUdNLFNBQVVBLElBQVYsQ0FBZUMsTUFBZixFQUE2QjtBQUNqQyxRQUFNLENBQUNDLENBQUQsRUFBSUMsQ0FBSixJQUFTRixNQUFNLENBQUNHLEtBQVAsQ0FBYSxFQUFiLENBQWY7QUFDQSxTQUFPO0FBQ0xGLEtBQUMsRUFBRSxDQUFDLEdBQUQsRUFBTSxHQUFOLEVBQVcsR0FBWCxFQUFnQixHQUFoQixFQUFxQixHQUFyQixFQUEwQixHQUExQixFQUErQixHQUEvQixFQUFvQyxHQUFwQyxFQUF5Q0csT0FBekMsQ0FBaURILENBQUMsQ0FBQ0ksV0FBRixFQUFqRCxDQURFO0FBRUxILEtBQUMsRUFBRUksTUFBTSxDQUFDSixDQUFEO0FBRkosR0FBUDtBQUlEO0FBRUssU0FBVUssTUFBVixDQUFpQkMsS0FBakIsRUFBNkI7QUFDakMsUUFBTTtBQUFFUCxLQUFGO0FBQUtDO0FBQUwsTUFBV00sS0FBakI7QUFDQSxRQUFNQyxHQUFHLEdBQUcsQ0FBQyxHQUFELEVBQU0sR0FBTixFQUFXLEdBQVgsRUFBZ0IsR0FBaEIsRUFBcUIsR0FBckIsRUFBMEIsR0FBMUIsRUFBK0IsR0FBL0IsRUFBb0MsR0FBcEMsRUFBeUNSLENBQXpDLENBQVo7QUFDQSxNQUFJLENBQUNRLEdBQUwsRUFBVSxPQUFPLEVBQVA7QUFDVixTQUFPQSxHQUFHLENBQUNDLE1BQUosQ0FBV1IsQ0FBQyxDQUFDUyxRQUFGLEVBQVgsQ0FBUDtBQUNEO0FBRU0sTUFBTUMsWUFBWSxHQUFJQyxTQUFELElBQXdCQyxTQUFELElBQXNCO0FBQ3ZFLFFBQU07QUFBRWIsS0FBQyxFQUFFYyxFQUFMO0FBQVNiLEtBQUMsRUFBRWM7QUFBWixNQUFtQmpCLElBQUksQ0FBQ2MsU0FBRCxDQUE3QjtBQUNBLFFBQU07QUFBRVosS0FBQyxFQUFFZ0IsRUFBTDtBQUFTZixLQUFDLEVBQUVnQjtBQUFaLE1BQW1CbkIsSUFBSSxDQUFDZSxTQUFELENBQTdCO0FBRUEsUUFBTUssS0FBSyxHQUFHSixFQUFFLEdBQUdFLEVBQW5CO0FBQ0EsUUFBTUcsS0FBSyxHQUFHSixFQUFFLEdBQUdFLEVBQW5CO0FBQ0EsU0FBTztBQUNMQyxTQURLO0FBRUxDO0FBRkssR0FBUDtBQUlELENBVk07QUFZRCxTQUFVQyxnQkFBVixDQUEyQkMsSUFBM0IsRUFBa0Q7QUFDdEQsVUFBUUEsSUFBUjtBQUNFLFNBQUssR0FBTDtBQUNFLGFBQU8sTUFBUDs7QUFFRixTQUFLLEdBQUw7QUFDRSxhQUFPLE9BQVA7O0FBRUYsU0FBSyxHQUFMO0FBQ0UsYUFBTyxRQUFQOztBQUVGLFNBQUssR0FBTDtBQUNFLGFBQU8sUUFBUDs7QUFFRixTQUFLLEdBQUw7QUFDRSxhQUFPLE1BQVA7QUFkSjtBQWdCRDtBQUVLLFNBQVVDLGFBQVYsQ0FBd0JDLFFBQXhCLEVBQXdDO0FBQzVDLFFBQU1DLElBQUksR0FBNEIsRUFBdEM7QUFFQSxRQUFNQyxRQUFRLEdBQUdGLFFBQVEsQ0FBQ0csT0FBVCxDQUFpQixPQUFqQixFQUEwQixFQUExQixDQUFqQjs7QUFFQSxNQUFJLENBQUNELFFBQVEsQ0FBQyxDQUFELENBQVQsS0FBaUIsQ0FBckIsRUFBd0I7QUFDdEI7QUFDQUQsUUFBSSxDQUFDRyxNQUFMLEdBQWNGLFFBQVEsQ0FBQ0csTUFBVCxLQUFvQixDQUFwQixHQUF3QixVQUF4QixHQUFxQyxXQUFuRDtBQUNBLFdBQU9KLElBQVA7QUFDRDs7QUFFRCxNQUFJQyxRQUFRLENBQUMsQ0FBRCxDQUFSLENBQVlJLFdBQVosT0FBOEJKLFFBQVEsQ0FBQyxDQUFELENBQTFDLEVBQStDO0FBQzdDO0FBQ0FELFFBQUksQ0FBQ00sU0FBTCxHQUFpQlYsZ0JBQWdCLENBQUNLLFFBQVEsQ0FBQyxDQUFELENBQVQsQ0FBakM7QUFDQUQsUUFBSSxDQUFDTyxFQUFMLEdBQVVOLFFBQVEsQ0FBQ08sS0FBVCxDQUFlLENBQUMsQ0FBaEIsQ0FBVjs7QUFFQSxZQUFRUCxRQUFRLENBQUNHLE1BQWpCO0FBQ0UsV0FBSyxDQUFMO0FBQ0VKLFlBQUksQ0FBQ1MsSUFBTCxHQUFZUixRQUFRLENBQUMsQ0FBRCxDQUFwQjtBQUNBOztBQUNGLFdBQUssQ0FBTDtBQUNFRCxZQUFJLENBQUNTLElBQUwsR0FBWVIsUUFBUSxDQUFDTyxLQUFULENBQWUsQ0FBZixFQUFrQixDQUFsQixDQUFaO0FBQ0E7QUFOSjs7QUFTQSxXQUFPUixJQUFQO0FBQ0QsR0FmRCxNQWVPO0FBQ0w7QUFDQUEsUUFBSSxDQUFDTSxTQUFMLEdBQWlCLE1BQWpCOztBQUVBLFFBQUlMLFFBQVEsQ0FBQ1MsUUFBVCxDQUFrQixHQUFsQixDQUFKLEVBQTRCO0FBQzFCO0FBQ0FWLFVBQUksQ0FBQ1csT0FBTCxHQUFlZixnQkFBZ0IsQ0FBQ0ssUUFBUSxDQUFDTyxLQUFULENBQWUsQ0FBQyxDQUFoQixDQUFELENBQS9CO0FBQ0Q7O0FBRUQsVUFBTUksZ0JBQWdCLEdBQUdYLFFBQVEsQ0FBQ3RCLE9BQVQsQ0FBaUIsR0FBakIsQ0FBekI7QUFDQSxVQUFNa0MsaUJBQWlCLEdBQUdaLFFBQVEsQ0FBQ08sS0FBVCxDQUN4QixDQUR3QixFQUV4QkksZ0JBQWdCLEtBQUssQ0FBQyxDQUF0QixHQUEwQlgsUUFBUSxDQUFDRyxNQUFuQyxHQUE0Q1EsZ0JBRnBCLENBQTFCOztBQUlBLFFBQUlDLGlCQUFpQixDQUFDVCxNQUFsQixLQUE2QixDQUFqQyxFQUFvQztBQUNsQ0osVUFBSSxDQUFDUyxJQUFMLEdBQVlSLFFBQVEsQ0FBQyxDQUFELENBQXBCO0FBQ0Q7O0FBQ0RELFFBQUksQ0FBQ08sRUFBTCxHQUFVTSxpQkFBaUIsQ0FBQ0wsS0FBbEIsQ0FBd0IsQ0FBQyxDQUF6QixDQUFWO0FBQ0Q7O0FBRUQsU0FBT1IsSUFBUDtBQUNEO0FBRUssU0FBVWMsZUFBVixDQUEwQkMsR0FBMUIsRUFBeUM7QUFDN0MsU0FBT0EsR0FBRyxDQUFDQyxHQUFKLENBQVNDLENBQUQsSUFBTyxDQUFDLEdBQUdBLENBQUosQ0FBZixDQUFQO0FBQ0QsQzs7QUNwR0Q7QUFDQTs7QUFJQSxNQUFNRSxLQUFLLEdBQUcsQ0FBQ0MsS0FBRCxFQUFlQyxJQUFmLEtBQWtDO0FBQzlDLFdBQVNDLE9BQVQsQ0FBaUJiLElBQWpCLEVBQStCRixFQUEvQixFQUF5QztBQUN2QyxZQUFRYyxJQUFSO0FBQ0UsV0FBSyxNQUFMO0FBQWE7QUFDWCxnQkFBTUUsYUFBYSxHQUNqQkwsZ0JBQUEsQ0FBVyxDQUFYLEVBQWNULElBQWQsRUFBb0JGLEVBQXBCLEtBQTJCVyxnQkFBQSxDQUFXLENBQVgsRUFBY1QsSUFBZCxFQUFvQkYsRUFBcEIsQ0FEN0I7QUFFQSxnQkFBTW1CLGdCQUFnQixHQUNwQlIsZ0JBQUEsQ0FBVyxDQUFYLEVBQWNULElBQWQsRUFBb0JGLEVBQXBCLEtBQTJCVyxnQkFBQSxDQUFXLENBQVgsRUFBY1QsSUFBZCxFQUFvQkYsRUFBcEIsQ0FEN0I7QUFFQSxnQkFBTW9CLG1CQUFtQixHQUN2QlQsZ0JBQUEsQ0FBVyxDQUFYLEVBQWNULElBQWQsRUFBb0JGLEVBQXBCLEtBQTJCVyxnQkFBQSxDQUFXLENBQVgsRUFBY1QsSUFBZCxFQUFvQkYsRUFBcEIsQ0FEN0I7QUFHQSxpQkFDRUUsSUFBSSxLQUFLRixFQUFULEtBQ0NvQixtQkFBbUIsSUFBSUosYUFBdkIsSUFBd0NHLGdCQUR6QyxDQURGO0FBSUQ7O0FBQ0QsV0FBSyxPQUFMO0FBQWM7QUFDWixpQkFDRWpCLElBQUksS0FBS0YsRUFBVCxLQUNDVyxvQkFBQSxDQUFlVCxJQUFmLEVBQXFCRixFQUFyQixLQUE0QlcsMEJBQUEsQ0FBcUJULElBQXJCLEVBQTJCRixFQUEzQixDQUQ3QixDQURGO0FBSUQ7O0FBQ0QsV0FBSyxRQUFMO0FBQWU7QUFDYixpQkFBT0UsSUFBSSxLQUFLRixFQUFULElBQWVXLG9CQUFBLENBQWVULElBQWYsRUFBcUJGLEVBQXJCLENBQXRCO0FBQ0Q7O0FBQ0QsV0FBSyxRQUFMO0FBQWU7QUFDYixpQkFDRUUsSUFBSSxLQUFLRixFQUFULEtBQ0VXLGdCQUFBLENBQVcsQ0FBWCxFQUFjVCxJQUFkLEVBQW9CRixFQUFwQixLQUEyQlcsZ0JBQUEsQ0FBVyxDQUFYLEVBQWNULElBQWQsRUFBb0JGLEVBQXBCLENBQTVCLElBQ0VXLGdCQUFBLENBQVcsQ0FBWCxFQUFjVCxJQUFkLEVBQW9CRixFQUFwQixLQUEyQlcsZ0JBQUEsQ0FBVyxDQUFYLEVBQWNULElBQWQsRUFBb0JGLEVBQXBCLENBRjlCLENBREY7QUFLRDs7QUFDRCxXQUFLLE1BQUw7QUFBYTtBQUNYLGlCQUFPRSxJQUFJLEtBQUtGLEVBQVQsSUFBZVcsMEJBQUEsQ0FBcUJYLEVBQXJCLEVBQXlCRSxJQUF6QixDQUF0QjtBQUNEOztBQUNELFdBQUssTUFBTDtBQUFhO0FBQ1gsZ0JBQU07QUFBRWpDLGFBQUMsRUFBRWMsRUFBTDtBQUFTYixhQUFDLEVBQUVjO0FBQVosY0FBbUJqQixJQUFJLENBQUNtQyxJQUFELENBQTdCO0FBQ0EsZ0JBQU07QUFBRWpDLGFBQUMsRUFBRWdCLEVBQUw7QUFBU2YsYUFBQyxFQUFFZ0I7QUFBWixjQUFtQm5CLElBQUksQ0FBQ2lDLEVBQUQsQ0FBN0I7QUFFQSxnQkFBTXVCLGdCQUFnQixHQUFHVixLQUFLLEtBQUssT0FBVixHQUFvQjdCLEVBQUUsR0FBR0UsRUFBekIsR0FBOEJGLEVBQUUsR0FBR0UsRUFBNUQ7QUFDQSxnQkFBTXNDLFdBQVcsR0FBR2IsZ0JBQUEsQ0FBVyxDQUFYLEVBQWNULElBQWQsRUFBb0JGLEVBQXBCLEtBQTJCakIsRUFBRSxLQUFLRSxFQUF0RDtBQUVBLGdCQUFNd0MsU0FBUyxHQUFHWixLQUFLLEtBQUssT0FBVixHQUFvQjdCLEVBQUUsS0FBSyxDQUEzQixHQUErQkEsRUFBRSxLQUFLLENBQXhEO0FBQ0EsZ0JBQU0wQyxPQUFPLEdBQUdmLGdCQUFBLENBQVcsQ0FBWCxFQUFjVCxJQUFkLEVBQW9CRixFQUFwQixLQUEyQmpCLEVBQUUsS0FBS0UsRUFBbEQ7QUFFQSxpQkFDRWlCLElBQUksS0FBS0YsRUFBVCxJQUNBdUIsZ0JBREEsS0FFQ0MsV0FBVyxJQUFLQyxTQUFTLElBQUlDLE9BRjlCLENBREY7QUFLRDtBQWhESDtBQWtERDs7QUFFRCxXQUFTQyxlQUFULENBQXlCQyxNQUF6QixFQUF1QztBQUNyQyxRQUFJZCxJQUFJLEtBQUssTUFBYixFQUFxQjtBQUVyQixVQUFNO0FBQUU3QyxPQUFGO0FBQUtDO0FBQUwsUUFBV0gsSUFBSSxDQUFDNkQsTUFBRCxDQUFyQjtBQUVBLFVBQU1DLElBQUksR0FBR2hCLEtBQUssS0FBSyxPQUFWLEdBQW9CM0MsQ0FBQyxHQUFHLENBQXhCLEdBQTRCQSxDQUFDLEdBQUcsQ0FBN0M7QUFFQSxVQUFNNEQsVUFBVSxHQUFHO0FBQUU3RCxPQUFDLEVBQUVBLENBQUMsR0FBRyxDQUFUO0FBQVlDLE9BQUMsRUFBRTJEO0FBQWYsS0FBbkI7QUFDQSxVQUFNRSxVQUFVLEdBQUc7QUFBRTlELE9BQUMsRUFBRUEsQ0FBQyxHQUFHLENBQVQ7QUFBWUMsT0FBQyxFQUFFMkQ7QUFBZixLQUFuQjtBQUVBLFdBQU8sQ0FBQ3RELE1BQU0sQ0FBQ3VELFVBQUQsQ0FBUCxFQUFxQnZELE1BQU0sQ0FBQ3dELFVBQUQsQ0FBM0IsQ0FBUDtBQUNEOztBQUVELFNBQU87QUFDTGhCLFdBREs7QUFFTFksbUJBRks7O0FBR0wsUUFBSWIsSUFBSixHQUFRO0FBQ04sYUFBT0EsSUFBUDtBQUNELEtBTEk7O0FBTUwsUUFBSUQsS0FBSixHQUFTO0FBQ1AsYUFBT0EsS0FBUDtBQUNEOztBQVJJLEdBQVA7QUFVRCxDQTdFRDs7QUErRUEsZ0RBQWVELEtBQWYsRTs7QUNwRkE7QUFHQTtBQUVBLE1BQU1ELEtBQUssR0FBRztBQUNaVyxnQkFBYyxFQUFHcEIsSUFBRCxJQUFtQkYsRUFBRCxJQUFlO0FBQy9DLFVBQU0sQ0FBQ2pCLEVBQUQsRUFBS0MsRUFBTCxJQUFXa0IsSUFBSSxDQUFDL0IsS0FBTCxDQUFXLEVBQVgsQ0FBakI7QUFDQSxVQUFNLENBQUNjLEVBQUQsRUFBS0MsRUFBTCxJQUFXYyxFQUFFLENBQUM3QixLQUFILENBQVMsRUFBVCxDQUFqQjtBQUNBLFdBQU9ZLEVBQUUsS0FBS0UsRUFBUCxJQUFhRCxFQUFFLEtBQUtFLEVBQTNCO0FBQ0QsR0FMVztBQU1abUMsVUFBUSxFQUFHbkIsSUFBRCxJQUFtQkYsRUFBRCxJQUFlO0FBQ3pDLFVBQU07QUFBRS9CLE9BQUMsRUFBRWMsRUFBTDtBQUFTYixPQUFDLEVBQUVjO0FBQVosUUFBbUJqQixJQUFJLENBQUNtQyxJQUFELENBQTdCO0FBQ0EsVUFBTTtBQUFFakMsT0FBQyxFQUFFZ0IsRUFBTDtBQUFTZixPQUFDLEVBQUVnQjtBQUFaLFFBQW1CbkIsSUFBSSxDQUFDaUMsRUFBRCxDQUE3QjtBQUNBLFdBQU9nQyxJQUFJLENBQUNDLEdBQUwsQ0FBU2hELEVBQUUsR0FBR0YsRUFBZCxNQUFzQmlELElBQUksQ0FBQ0MsR0FBTCxDQUFTL0MsRUFBRSxHQUFHRixFQUFkLENBQTdCO0FBQ0QsR0FWVztBQVdaa0MsTUFBSSxFQUFHZ0IsR0FBRCxJQUFrQmhDLElBQUQsSUFBbUJGLEVBQUQsSUFBZTtBQUN0RCxVQUFNO0FBQUUvQixPQUFDLEVBQUVjO0FBQUwsUUFBWWhCLElBQUksQ0FBQ21DLElBQUQsQ0FBdEI7QUFDQSxVQUFNO0FBQUVqQyxPQUFDLEVBQUVnQjtBQUFMLFFBQVlsQixJQUFJLENBQUNpQyxFQUFELENBQXRCO0FBQ0EsV0FBT2dDLElBQUksQ0FBQ0MsR0FBTCxDQUFTbEQsRUFBRSxHQUFHRSxFQUFkLE1BQXNCaUQsR0FBN0I7QUFDRCxHQWZXO0FBZ0JaakIsTUFBSSxFQUFHaUIsR0FBRCxJQUFrQmhDLElBQUQsSUFBbUJGLEVBQUQsSUFBZTtBQUN0RCxVQUFNO0FBQUU5QixPQUFDLEVBQUVjO0FBQUwsUUFBWWpCLElBQUksQ0FBQ21DLElBQUQsQ0FBdEI7QUFDQSxVQUFNO0FBQUVoQyxPQUFDLEVBQUVnQjtBQUFMLFFBQVluQixJQUFJLENBQUNpQyxFQUFELENBQXRCO0FBQ0EsV0FBT2dDLElBQUksQ0FBQ0MsR0FBTCxDQUFTakQsRUFBRSxHQUFHRSxFQUFkLE1BQXNCZ0QsR0FBN0I7QUFDRDtBQXBCVyxDQUFkO0FBdUJBLGtEQUFldkIsS0FBZjtBQUVBOztBQUVBLFNBQVN3QixnQkFBVCxDQUEwQkMsWUFBMUIsRUFBK0NDLEtBQS9DLEVBQTREO0FBSTFELFNBQU9ELFlBQVksQ0FBQ0UsTUFBYixDQUFvQixDQUFDQyxHQUFELEVBQWVDLElBQWYsS0FBK0I7QUFDeEQsVUFBTTtBQUFFckQsV0FBRjtBQUFTQztBQUFULFFBQW1CUixZQUFZLENBQUN5RCxLQUFELENBQVosQ0FBb0JHLElBQXBCLENBQXpCO0FBRUEsUUFBSUMsTUFBTSxHQUFHLEVBQWI7QUFDQSxRQUFJckQsS0FBSyxLQUFLLENBQWQsRUFBaUJxRCxNQUFNLEdBQUdyRCxLQUFLLEdBQUcsQ0FBUixHQUFZLElBQVosR0FBbUIsTUFBNUI7QUFDakIsUUFBSUQsS0FBSyxLQUFLLENBQWQsRUFBaUJzRCxNQUFNLElBQUl0RCxLQUFLLEdBQUcsQ0FBUixHQUFZLE9BQVosR0FBc0IsTUFBaEMsQ0FMdUMsQ0FPeEQ7O0FBQ0FzRCxVQUFNLEdBQUdBLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjLENBQWQsRUFBaUJyRSxXQUFqQixLQUFpQ29FLE1BQU0sQ0FBQ3hDLEtBQVAsQ0FBYSxDQUFiLENBQTFDO0FBRUFzQyxPQUFHLENBQUNFLE1BQUQsQ0FBSCxHQUFjRixHQUFHLENBQUNFLE1BQUQsQ0FBSCxJQUFlLEVBQTdCO0FBQ0FGLE9BQUcsQ0FBQ0UsTUFBRCxDQUFILENBQVlFLElBQVosQ0FBaUJILElBQWpCO0FBRUEsV0FBT0QsR0FBUDtBQUNELEdBZE0sRUFjSixFQWRJLENBQVA7QUFlRDs7QUFFRCxTQUFTSyxvQkFBVCxDQUE4QkgsTUFBOUIsRUFBMkM7QUFDekMsTUFBSUEsTUFBTSxDQUFDNUMsTUFBUCxLQUFrQixDQUF0QixFQUF5QixPQUFPLEVBQVA7QUFFekIsU0FBTzRDLE1BQU0sQ0FBQ0gsTUFBUCxDQUFjLENBQUNDLEdBQUQsRUFBTUMsSUFBTixLQUFjO0FBQ2pDLFVBQU07QUFBRXZFLE9BQUMsRUFBRWMsRUFBTDtBQUFTYixPQUFDLEVBQUVjO0FBQVosUUFBbUJqQixJQUFJLENBQUN3RSxHQUFELENBQTdCO0FBQ0EsVUFBTTtBQUFFdEUsT0FBQyxFQUFFZ0IsRUFBTDtBQUFTZixPQUFDLEVBQUVnQjtBQUFaLFFBQW1CbkIsSUFBSSxDQUFDeUUsSUFBRCxDQUE3QjtBQUVBLFVBQU1LLGNBQWMsR0FBRzlELEVBQUUsS0FBS0UsRUFBUCxHQUFZRCxFQUFFLEdBQUdFLEVBQWpCLEdBQXNCSCxFQUFFLEdBQUdFLEVBQWxEO0FBQ0EsV0FBTzRELGNBQWMsR0FBR04sR0FBSCxHQUFTQyxJQUE5QjtBQUNELEdBTk0sQ0FBUDtBQU9EOztBQUVELE1BQU1NLG1CQUFtQixHQUFHLENBQzFCQyxFQUQwQixFQUUxQkMsRUFGMEIsRUFHMUJDLFVBSDBCLEtBSWpCO0FBQ1QsUUFBTUMsaUJBQWlCLEdBQUd2QyxLQUFLLENBQUNXLGNBQU4sQ0FBcUJ5QixFQUFyQixFQUF5QkMsRUFBekIsQ0FBMUI7QUFDQSxRQUFNRyxrQkFBa0IsR0FBR3hDLEtBQUssQ0FBQ1UsUUFBTixDQUFlMEIsRUFBZixFQUFtQkMsRUFBbkIsQ0FBM0I7QUFFQSxRQUFNSSxjQUFjLEdBQUdGLGlCQUFpQixJQUFJQyxrQkFBNUM7QUFDQSxNQUFJLENBQUNDLGNBQUwsRUFBcUIsT0FBTyxFQUFQO0FBRXJCLFFBQU1DLGNBQWMsR0FBR0Ysa0JBQWtCLEdBQUcsVUFBSCxHQUFnQixnQkFBekQ7QUFFQSxRQUFNRyxrQkFBa0IsR0FBR0wsVUFBVSxDQUFDTSxNQUFYLENBQ3hCQyxDQUFELElBQU83QyxLQUFLLENBQUMwQyxjQUFELENBQUwsQ0FBc0JOLEVBQXRCLEVBQTBCUyxDQUExQixLQUFnQzdDLEtBQUssQ0FBQzBDLGNBQUQsQ0FBTCxDQUFzQkwsRUFBdEIsRUFBMEJRLENBQTFCLENBRGQsQ0FBM0I7QUFHQSxTQUFPRixrQkFBUDtBQUNELENBakJEO0FBbUJBOzs7QUFFQSxNQUFNRyxrQkFBa0IsR0FDckJ6RixNQUFELElBQ0MyQyxLQUFELElBQXdCO0FBQ3RCLFNBQU8sQ0FBQyxHQUFHQSxLQUFKLEVBQVcrQyxJQUFYLENBQWdCLENBQUNDLENBQUQsRUFBSUMsQ0FBSixLQUFTO0FBQzlCLFVBQU07QUFBRXpFLFdBQUssRUFBRTBFLE1BQVQ7QUFBaUJ6RSxXQUFLLEVBQUUwRTtBQUF4QixRQUFtQ2xGLFlBQVksQ0FBQ1osTUFBRCxDQUFaLENBQXFCMkYsQ0FBckIsQ0FBekM7QUFDQSxVQUFNSSxLQUFLLEdBQUcvQixJQUFJLENBQUNDLEdBQUwsQ0FBUzRCLE1BQVQsSUFBbUI3QixJQUFJLENBQUNDLEdBQUwsQ0FBUzZCLE1BQVQsQ0FBakM7QUFFQSxVQUFNO0FBQUUzRSxXQUFLLEVBQUU2RSxNQUFUO0FBQWlCNUUsV0FBSyxFQUFFNkU7QUFBeEIsUUFBbUNyRixZQUFZLENBQUNaLE1BQUQsQ0FBWixDQUFxQjRGLENBQXJCLENBQXpDO0FBQ0EsVUFBTU0sS0FBSyxHQUFHbEMsSUFBSSxDQUFDQyxHQUFMLENBQVMrQixNQUFULElBQW1CaEMsSUFBSSxDQUFDQyxHQUFMLENBQVNnQyxNQUFULENBQWpDO0FBRUEsV0FBT0YsS0FBSyxHQUFHRyxLQUFmO0FBQ0QsR0FSTSxDQUFQO0FBU0QsQ0FaSDtBQWNBOzs7QUFFQSxTQUFTQyxnQkFBVCxDQUEwQnZDLE1BQTFCLEVBQTBDd0MsS0FBMUMsRUFBc0Q7QUFDcEQ7QUFDQSxRQUFNbkIsVUFBVSxHQUFHb0IsS0FBSyxDQUFDbkUsSUFBTixDQUFXa0UsS0FBSyxDQUFDRSxJQUFOLEVBQVgsQ0FBbkI7QUFFQSxRQUFNdEcsTUFBTSxHQUFHb0csS0FBSyxDQUFDRyxHQUFOLENBQVUzQyxNQUFWLENBQWY7QUFFQSxRQUFNO0FBQUVkLFFBQUY7QUFBUUQ7QUFBUixNQUFrQjdDLE1BQU0sQ0FBQ3dHLEtBQS9CO0FBQ0EsUUFBTUEsS0FBSyxHQUFHNUQsU0FBSyxDQUFDQyxLQUFELEVBQVFDLElBQVIsQ0FBbkI7QUFFQSxTQUFPbUMsVUFBVSxDQUFDTSxNQUFYLENBQW1CQyxDQUFELElBQU9nQixLQUFLLENBQUN6RCxPQUFOLENBQWNhLE1BQWQsRUFBc0I0QixDQUF0QixDQUF6QixDQUFQO0FBQ0Q7O0FBRUQsU0FBU2lCLGFBQVQsQ0FBdUI3QyxNQUF2QixFQUF1Q3dDLEtBQXZDLEVBQW1EO0FBQ2pEO0FBQ0EsUUFBTXBHLE1BQU0sR0FBR29HLEtBQUssQ0FBQ0csR0FBTixDQUFVM0MsTUFBVixDQUFmO0FBRUEsUUFBTTRDLEtBQUssR0FBR3hHLE1BQU0sQ0FBQ3dHLEtBQXJCO0FBRUEsUUFBTUUsYUFBYSxHQUFHUCxnQkFBZ0IsQ0FBQ3ZDLE1BQUQsRUFBU3dDLEtBQVQsQ0FBdEM7QUFFQSxRQUFNTyxZQUFZLEdBQUdELGFBQWEsQ0FBQ25CLE1BQWQsQ0FBc0JDLENBQUQsSUFBTTtBQUFBOztBQUFDLHNCQUFLLENBQUNlLEdBQU4sQ0FBVWYsQ0FBVixPQUFZLElBQVosSUFBWW9CLGFBQVosR0FBWSxNQUFaLEdBQVlBLEdBQUVKLEtBQWQ7QUFBbUIsR0FBL0MsQ0FBckI7O0FBQ0EsTUFBSSxDQUFDRyxZQUFZLENBQUM5RSxNQUFsQixFQUEwQjtBQUN4QixZQUFRMkUsS0FBSyxDQUFDMUQsSUFBZDtBQUNFLFdBQUssTUFBTDtBQUNFLGVBQU8sQ0FBQyxHQUFHYSxlQUFlLENBQUNDLE1BQUQsRUFBU3dDLEtBQVQsQ0FBbkIsRUFBb0MsR0FBR00sYUFBdkMsQ0FBUDs7QUFFRixXQUFLLE1BQUw7QUFDRSxlQUFPRyxzQkFBc0IsQ0FBQ2pELE1BQUQsRUFBUzhDLGFBQVQsRUFBd0JOLEtBQXhCLENBQTdCOztBQUNGO0FBQ0UsZUFBT00sYUFBUDtBQVBKO0FBU0Q7O0FBRUQsTUFBSUksVUFBVSxHQUFVLEVBQXhCOztBQUNBLFVBQVFOLEtBQUssQ0FBQzFELElBQWQ7QUFDRSxTQUFLLFFBQUw7QUFBZTtBQUNiZ0Usa0JBQVUsR0FBR0osYUFBYjtBQUNBO0FBQ0Q7O0FBQ0QsU0FBSyxNQUFMO0FBQWE7QUFDWCxjQUFNSyxpQkFBaUIsR0FBR3BELGVBQWUsQ0FBQ0MsTUFBRCxFQUFTd0MsS0FBVCxDQUF6QztBQUNBLGNBQU1ZLGlCQUFpQixHQUFHQyxxQkFBcUIsQ0FDN0NDLHFCQUFxQixDQUFDdEQsTUFBRCxFQUFTOEMsYUFBVCxFQUF3QkMsWUFBeEIsQ0FEd0IsRUFFN0NQLEtBRjZDLENBQS9DO0FBSUFVLGtCQUFVLEdBQUcsQ0FBQyxHQUFHQyxpQkFBSixFQUF1QixHQUFHQyxpQkFBMUIsQ0FBYjtBQUNBO0FBQ0Q7O0FBQ0QsU0FBSyxNQUFMO0FBQWE7QUFDWEYsa0JBQVUsR0FBR0Qsc0JBQXNCLENBQUNqRCxNQUFELEVBQVM4QyxhQUFULEVBQXdCTixLQUF4QixDQUFuQztBQUNBO0FBQ0Q7O0FBQ0Q7QUFBUztBQUNQVSxrQkFBVSxHQUFHSSxxQkFBcUIsQ0FBQ3RELE1BQUQsRUFBUzhDLGFBQVQsRUFBd0JDLFlBQXhCLENBQWxDO0FBQ0Q7QUFwQkg7O0FBdUJBLFNBQU9NLHFCQUFxQixDQUFDSCxVQUFELEVBQWFWLEtBQWIsRUFBb0JJLEtBQUssQ0FBQzNELEtBQTFCLENBQTVCO0FBQ0Q7O0FBRUQsU0FBU3NFLG9CQUFULENBQ0V2RCxNQURGLEVBRUV3QyxLQUZGLEVBR0VnQixPQUhGLEVBSUVDLGlCQUpGLEVBSTJCO0FBRXpCLFFBQU1DLHdCQUF3QixHQUFHQyw2QkFBNkIsQ0FDNURILE9BRDRELEVBRTVEQyxpQkFGNEQsRUFHNURoQixLQUFLLENBQUNuRSxJQUFOLENBQVdrRSxLQUFLLENBQUNFLElBQU4sRUFBWCxDQUg0RCxDQUE5RDtBQUtBLFFBQU0zRCxLQUFLLEdBQUc4RCxhQUFhLENBQUM3QyxNQUFELEVBQVN3QyxLQUFULENBQTNCO0FBRUEsU0FBT3pELEtBQUssQ0FBQzRDLE1BQU4sQ0FBY0MsQ0FBRCxJQUFPOEIsd0JBQXdCLENBQUNuRixRQUF6QixDQUFrQ3FELENBQWxDLENBQXBCLENBQVA7QUFDRDs7QUFFRCxTQUFTZ0MsaUJBQVQsQ0FBMkI1RCxNQUEzQixFQUEyQ3dDLEtBQTNDLEVBQXVEO0FBQ3JELFFBQU1wRyxNQUFNLEdBQUdvRyxLQUFLLENBQUNHLEdBQU4sQ0FBVTNDLE1BQVYsQ0FBZjtBQUVBLFFBQU07QUFBRWQsUUFBRjtBQUFRRDtBQUFSLE1BQWtCN0MsTUFBTSxDQUFDd0csS0FBL0I7O0FBRUEsVUFBUTFELElBQVI7QUFDRSxTQUFLLE1BQUw7QUFBYTtBQUNYLGNBQU0wRCxLQUFLLEdBQUc1RCxTQUFLLENBQUNDLEtBQUQsRUFBUSxNQUFSLENBQW5CO0FBQ0EsZUFBTzJELEtBQUssQ0FBQzdDLGVBQU4sQ0FBc0JDLE1BQXRCLENBQVA7QUFDRDs7QUFDRCxTQUFLLE1BQUw7QUFBYTtBQUNYO0FBQ0EsY0FBTTZELGNBQWMsR0FBR1IscUJBQXFCLENBQzFDZCxnQkFBZ0IsQ0FBQ3ZDLE1BQUQsRUFBU3dDLEtBQVQsQ0FEMEIsRUFFMUNBLEtBRjBDLEVBRzFDdkQsS0FIMEMsQ0FBNUM7QUFLQSxlQUFPNEUsY0FBUDtBQUNEOztBQUNEO0FBQ0UsYUFBT2hCLGFBQWEsQ0FBQzdDLE1BQUQsRUFBU3dDLEtBQVQsQ0FBcEI7QUFmSjtBQWlCRDs7QUFFRCxTQUFTc0IsbUJBQVQsQ0FDRTdFLEtBREYsRUFFRXVELEtBRkYsRUFHRXVCLFFBSEYsRUFHb0I7QUFFbEIsUUFBTUMsUUFBUSxHQUFZLEVBQTFCOztBQUNBLE9BQUssTUFBTSxDQUFDNUgsTUFBRCxFQUFTO0FBQUV3RztBQUFGLEdBQVQsQ0FBWCxJQUFrQ0osS0FBSyxDQUFDeUIsT0FBTixFQUFsQyxFQUFtRDtBQUNqRCxRQUFJLENBQUNyQixLQUFMLEVBQVk7QUFDWixRQUFJQSxLQUFLLENBQUMzRCxLQUFOLEtBQWdCQSxLQUFwQixFQUEyQjtBQUMzQixRQUFJOEUsUUFBUSxJQUFJbkIsS0FBSyxDQUFDMUQsSUFBTixLQUFlLE1BQS9CLEVBQXVDO0FBRXZDOEUsWUFBUSxDQUFDakQsSUFBVCxDQUFjOEIsYUFBYSxDQUFDekcsTUFBRCxFQUFTb0csS0FBVCxDQUEzQjtBQUNEOztBQUVELFNBQU93QixRQUFRLENBQUNFLElBQVQsRUFBUDtBQUNEOztBQUVELFNBQVNDLHlCQUFULENBQW1DbEYsS0FBbkMsRUFBaUR1RCxLQUFqRCxFQUE2RDtBQUMzRCxRQUFNd0IsUUFBUSxHQUFZLEVBQTFCOztBQUNBLE9BQUssTUFBTSxDQUFDNUgsTUFBRCxFQUFTO0FBQUV3RztBQUFGLEdBQVQsQ0FBWCxJQUFrQ0osS0FBSyxDQUFDeUIsT0FBTixFQUFsQyxFQUFtRDtBQUNqRCxRQUFJLENBQUNyQixLQUFMLEVBQVk7QUFDWixRQUFJQSxLQUFLLENBQUMzRCxLQUFOLEtBQWdCQSxLQUFwQixFQUEyQjtBQUUzQitFLFlBQVEsQ0FBQ2pELElBQVQsQ0FBYzZDLGlCQUFpQixDQUFDeEgsTUFBRCxFQUFTb0csS0FBVCxDQUEvQjtBQUNEOztBQUVELFNBQU93QixRQUFRLENBQUNFLElBQVQsRUFBUDtBQUNEOztBQUVELFNBQVNuRSxlQUFULENBQXlCcUUsVUFBekIsRUFBNkM1QixLQUE3QyxFQUF5RDs7O0FBQ3ZELFFBQU07QUFBRXZEO0FBQUYsTUFBWSxXQUFLLENBQUMwRCxHQUFOLENBQVV5QixVQUFWLE9BQXFCLElBQXJCLElBQXFCcEIsYUFBckIsR0FBcUIsTUFBckIsR0FBcUJBLEdBQUVKLEtBQXpDO0FBQ0EsUUFBTXlCLElBQUksR0FBR3JGLFNBQUssQ0FBQ0MsS0FBRCxFQUFRLE1BQVIsQ0FBbEI7QUFFQSxRQUFNcUYsWUFBWSxHQUFHRCxJQUFJLENBQUN0RSxlQUFMLENBQXFCcUUsVUFBckIsQ0FBckI7QUFDQSxNQUFJLENBQUNFLFlBQUwsRUFBbUIsT0FBTyxFQUFQO0FBRW5CLFNBQU9BLFlBQVksQ0FBQzNDLE1BQWIsQ0FBcUJDLENBQUQsSUFBTTtBQUMvQixVQUFNMkMsU0FBUyxHQUFHL0IsS0FBSyxDQUFDRyxHQUFOLENBQVVmLENBQVYsQ0FBbEI7QUFDQSxRQUFJLENBQUMyQyxTQUFMLEVBQWdCLE9BQU8sS0FBUDtBQUVoQixVQUFNM0IsS0FBSyxHQUFHMkIsU0FBUyxDQUFDM0IsS0FBeEI7QUFDQSxVQUFNNEIsU0FBUyxHQUE2QkQsU0FBUyxDQUFDQyxTQUF0RDtBQUVBLFdBQ0c1QixLQUFLLElBQUlBLEtBQUssQ0FBQzNELEtBQU4sS0FBZ0JvRixJQUFJLENBQUNwRixLQUEvQixJQUNDdUYsU0FBUyxJQUFJQSxTQUFTLENBQUN2RixLQUFWLEtBQW9Cb0YsSUFBSSxDQUFDcEYsS0FGekM7QUFJRCxHQVhNLENBQVA7QUFZRDs7QUFFRCxTQUFTMEUsNkJBQVQsQ0FDRUgsT0FERixFQUVFaUIsUUFGRixFQUdFcEQsVUFIRixFQUdtQjtBQUVqQjtBQUNBLFFBQU1LLGtCQUFrQixHQUFHUixtQkFBbUIsQ0FBQ3NDLE9BQUQsRUFBVWlCLFFBQVYsRUFBb0JwRCxVQUFwQixDQUE5QztBQUNBLFFBQU1xRCwwQkFBMEIsR0FBR0MsMkJBQTJCLENBQzVEbkIsT0FENEQsRUFFNURpQixRQUY0RCxFQUc1RC9DLGtCQUg0RCxDQUE5RDtBQUtBLFNBQU9nRCwwQkFBUDtBQUNEO0FBRUQ7OztBQUVBLFNBQVNDLDJCQUFULENBQ0V4RCxFQURGLEVBRUVDLEVBRkYsRUFHRVAsTUFIRixFQUdlO0FBRWIsUUFBTStELE1BQU0sR0FBRy9DLGtCQUFrQixDQUFDYixvQkFBb0IsQ0FBQ0gsTUFBRCxDQUFyQixDQUFsQixDQUFpREEsTUFBakQsQ0FBZjtBQUNBLE1BQUlnRSxjQUFKO0FBQ0EsTUFBSUMsYUFBSjs7QUFFQSxNQUFJRixNQUFNLENBQUNwSSxPQUFQLENBQWUyRSxFQUFmLElBQXFCeUQsTUFBTSxDQUFDcEksT0FBUCxDQUFlNEUsRUFBZixDQUF6QixFQUE2QztBQUMzQ3lELGtCQUFjLEdBQUcxRCxFQUFqQjtBQUNBMkQsaUJBQWEsR0FBRzFELEVBQWhCO0FBQ0QsR0FIRCxNQUdPO0FBQ0x5RCxrQkFBYyxHQUFHekQsRUFBakI7QUFDQTBELGlCQUFhLEdBQUczRCxFQUFoQjtBQUNEOztBQUNELFFBQU00RCxhQUFhLEdBQUdDLHVCQUF1QixDQUFDSCxjQUFELENBQXZCLENBQXdDRCxNQUF4QyxDQUF0QjtBQUNBLFFBQU1LLGVBQWUsR0FBR0QsdUJBQXVCLENBQUNGLGFBQUQsQ0FBdkIsQ0FDdEJDLGFBQWEsQ0FBQ0csT0FBZCxFQURzQixDQUF4QjtBQUlBLFNBQU9ELGVBQVA7QUFDRDs7QUFFRCxNQUFNRCx1QkFBdUIsR0FDMUI1SSxNQUFELElBQ0MyQyxLQUFELElBQXdCO0FBQ3RCLFFBQU1vRyxJQUFJLEdBQUcsQ0FBQyxHQUFHcEcsS0FBSixDQUFiO0FBQ0EsUUFBTXFHLEtBQUssR0FBR3JHLEtBQUssQ0FBQ3ZDLE9BQU4sQ0FBY0osTUFBZCxDQUFkO0FBRUEsTUFBSWdKLEtBQUssS0FBSyxDQUFDLENBQWYsRUFBa0IsT0FBTyxFQUFQO0FBRWxCRCxNQUFJLENBQUNFLE1BQUwsQ0FBWUQsS0FBSyxHQUFHLENBQXBCO0FBRUEsU0FBT0QsSUFBUDtBQUNELENBWEg7O0FBYUEsU0FBUzdCLHFCQUFULENBQ0VnQyxjQURGLEVBRUV4QyxhQUZGLEVBR0VDLFlBSEYsRUFHcUI7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFFQSxRQUFNd0MsYUFBYSxHQUFZLEVBQS9CO0FBRUEsUUFBTUMsVUFBVSxHQUFHakYsZ0JBQWdCLENBQUN1QyxhQUFELEVBQWdCd0MsY0FBaEIsQ0FBbkM7QUFDQSxRQUFNRyxrQkFBa0IsR0FBR2xGLGdCQUFnQixDQUFDd0MsWUFBRCxFQUFldUMsY0FBZixDQUEzQzs7QUFDQSxPQUFLLE1BQU16RSxNQUFYLElBQXFCMkUsVUFBckIsRUFBaUM7QUFDL0IsUUFBSSxDQUFDQyxrQkFBa0IsQ0FBQzVFLE1BQUQsQ0FBdkIsRUFBaUM7QUFDL0I7QUFDQTBFLG1CQUFhLENBQUN4RSxJQUFkLENBQW1CeUUsVUFBVSxDQUFDM0UsTUFBRCxDQUE3QjtBQUNBO0FBQ0Q7O0FBRUQsVUFBTStELE1BQU0sR0FBRy9DLGtCQUFrQixDQUFDeUQsY0FBRCxDQUFsQixDQUFtQ0UsVUFBVSxDQUFDM0UsTUFBRCxDQUE3QyxDQUFmO0FBQ0EsVUFBTTZFLGtCQUFrQixHQUFHN0Qsa0JBQWtCLENBQUN5RCxjQUFELENBQWxCLENBQ3pCRyxrQkFBa0IsQ0FBQzVFLE1BQUQsQ0FETyxFQUV6QixDQUZ5QixDQUEzQjtBQUlBMEUsaUJBQWEsQ0FBQ3hFLElBQWQsQ0FBbUJpRSx1QkFBdUIsQ0FBQ1Usa0JBQUQsQ0FBdkIsQ0FBNENkLE1BQTVDLENBQW5CO0FBQ0Q7O0FBRUQsU0FBT1csYUFBYSxDQUFDckIsSUFBZCxFQUFQO0FBQ0Q7O0FBRUQsU0FBU2pCLHNCQUFULENBQ0VPLE9BREYsRUFFRVYsYUFGRixFQUdFTixLQUhGLEVBR2M7OztBQUVaLFFBQU1tRCxJQUFJLEdBQUcsV0FBSyxDQUFDaEQsR0FBTixDQUFVYSxPQUFWLE9BQWtCLElBQWxCLElBQWtCUixhQUFsQixHQUFrQixNQUFsQixHQUFrQkEsR0FBRUosS0FBakM7QUFDQSxRQUFNZ0QsUUFBUSxHQUFHRCxJQUFJLENBQUMxRyxLQUFMLEtBQWUsT0FBZixHQUF5QixPQUF6QixHQUFtQyxPQUFwRDtBQUVBLFFBQU00RyxxQkFBcUIsR0FBYS9DLGFBQWEsQ0FBQ25CLE1BQWQsQ0FDckNDLENBQUQsSUFBTTtBQUFBOztBQUFDLDZCQUFLLENBQUNlLEdBQU4sQ0FBVWYsQ0FBVixPQUFZLElBQVosSUFBWW9CLGFBQVosR0FBWSxNQUFaLEdBQVlBLEdBQUVKLEtBQWQsTUFBbUIsSUFBbkIsSUFBbUJrRCxhQUFuQixHQUFtQixNQUFuQixHQUFtQkEsR0FBRTdHLEtBQXJCLE1BQStCMkcsUUFBL0I7QUFBdUMsR0FEUixDQUF4QztBQUdBLFFBQU1HLGlDQUFpQyxHQUFhRixxQkFBcUIsQ0FDdEVoSCxHQURpRCxDQUM1QytDLENBQUQsSUFBT2dDLGlCQUFpQixDQUFDaEMsQ0FBRCxFQUFJWSxLQUFKLENBRHFCLEVBRWpEMEIsSUFGaUQsRUFBcEQsQ0FSWSxDQVdaO0FBQ0E7O0FBQ0EsUUFBTThCLFNBQVMsR0FBRyxJQUFJQyxHQUFKLENBQVF6RCxLQUFSLENBQWxCO0FBQ0FNLGVBQWEsQ0FBQ29ELE9BQWQsQ0FBdUJ0RSxDQUFELElBQU9vRSxTQUFTLENBQUNHLEdBQVYsQ0FBY3ZFLENBQWQsRUFBaUI7QUFBRWdCLFNBQUssRUFBRStDO0FBQVQsR0FBakIsQ0FBN0I7QUFFQSxRQUFNUyx1QkFBdUIsR0FBR2pDLHlCQUF5QixDQUN2RHlCLFFBRHVELEVBRXZESSxTQUZ1RCxDQUF6RDtBQUlBLFNBQU9sRCxhQUFhLENBQUNuQixNQUFkLENBQXNCQyxDQUFELElBQU07QUFDaEMsV0FDRSxDQUFDd0UsdUJBQXVCLENBQUM3SCxRQUF4QixDQUFpQ3FELENBQWpDLENBQUQsSUFDQSxDQUFDbUUsaUNBQWlDLENBQUN4SCxRQUFsQyxDQUEyQ3FELENBQTNDLENBRkg7QUFJRCxHQUxNLENBQVA7QUFNRDs7QUFFRCxTQUFTeUIscUJBQVQsQ0FDRXRFLEtBREYsRUFFRXlELEtBRkYsRUFHRXZELEtBSEYsRUFHZTtBQUViLFNBQU9GLEtBQUssQ0FBQzRDLE1BQU4sQ0FBY0MsQ0FBRCxJQUFNO0FBQ3hCLFVBQU0yQyxTQUFTLEdBQUcvQixLQUFLLENBQUNHLEdBQU4sQ0FBVWYsQ0FBVixDQUFsQjtBQUNBLFFBQUksQ0FBQzJDLFNBQUwsRUFBZ0IsT0FBTyxLQUFQO0FBRWhCLFFBQUl0RixLQUFKLEVBQVcsT0FBTyxDQUFDc0YsU0FBUyxDQUFDM0IsS0FBWCxJQUFvQjJCLFNBQVMsQ0FBQzNCLEtBQVYsQ0FBZ0IzRCxLQUFoQixLQUEwQkEsS0FBckQsQ0FBWCxLQUNLLE9BQU8sQ0FBQ3NGLFNBQVMsQ0FBQzNCLEtBQWxCO0FBQ04sR0FOTSxDQUFQO0FBT0Q7QUFFRDs7O0FBRUEsU0FBU3lELGtCQUFULENBQ0U3QyxPQURGLEVBRUU4QyxTQUZGLEVBR0VDLE9BSEYsRUFJRS9ELEtBSkYsRUFJYztTQUFBLENBRVo7OztBQUNBLE1BQUlkLGtCQUFrQixHQUFHUixtQkFBbUIsQ0FDMUNzQyxPQUQwQyxFQUUxQytDLE9BRjBDLEVBRzFDOUQsS0FBSyxDQUFDbkUsSUFBTixDQUFXa0UsS0FBSyxDQUFDRSxJQUFOLEVBQVgsQ0FIMEMsQ0FBNUM7QUFLQWhCLG9CQUFrQixHQUFHQSxrQkFBa0IsQ0FBQ0MsTUFBbkIsQ0FDbEJDLENBQUQsSUFBT0EsQ0FBQyxLQUFLNEIsT0FBTixJQUFpQjVCLENBQUMsS0FBSzJFLE9BRFgsQ0FBckI7QUFHQSxNQUFJLENBQUM3RSxrQkFBa0IsQ0FBQ3pELE1BQXhCLEVBQWdDLE9BQU8sRUFBUDs7QUFFaEMsT0FBSyxNQUFNN0IsTUFBWCxJQUFxQnNGLGtCQUFyQixFQUF5QztBQUN2QyxVQUFNa0IsS0FBSyxHQUFHLFdBQUssQ0FBQ0QsR0FBTixDQUFVdkcsTUFBVixPQUFpQixJQUFqQixJQUFpQjRHLGFBQWpCLEdBQWlCLE1BQWpCLEdBQWlCQSxHQUFFSixLQUFqQztBQUNBLFFBQUksQ0FBQ0EsS0FBRCxJQUFVQSxLQUFLLENBQUMzRCxLQUFOLEtBQWdCcUgsU0FBOUIsRUFBeUM7QUFFekMsVUFBTXBELFVBQVUsR0FBR0wsYUFBYSxDQUFDekcsTUFBRCxFQUFTb0csS0FBVCxDQUFoQztBQUNBLFFBQUlVLFVBQVUsQ0FBQzNFLFFBQVgsQ0FBb0JpRixPQUFwQixDQUFKLEVBQWtDLE9BQU9wSCxNQUFQO0FBQ25DOztBQUVELFNBQU8sRUFBUDtBQUNEOztBQUVELFNBQVNvSyxzQkFBVCxDQUNFaEQsT0FERixFQUVFQyxpQkFGRixFQUdFakIsS0FIRixFQUdjOzs7QUFFWixRQUFNbUQsSUFBSSxHQUFHLFdBQUssQ0FBQ2hELEdBQU4sQ0FBVWEsT0FBVixPQUFrQixJQUFsQixJQUFrQlIsYUFBbEIsR0FBa0IsTUFBbEIsR0FBa0JBLEdBQUVKLEtBQWpDO0FBRUEsUUFBTTZELHFCQUFxQixHQUFHOUMsNkJBQTZCLENBQ3pESCxPQUR5RCxFQUV6REMsaUJBRnlELEVBR3pEaEIsS0FBSyxDQUFDbkUsSUFBTixDQUFXa0UsS0FBSyxDQUFDRSxJQUFOLEVBQVgsQ0FIeUQsQ0FBM0QsQ0FKWSxDQVFUOztBQUVILFFBQU1nRSxhQUFhLEdBQUc1QyxtQkFBbUIsQ0FBQzZCLElBQUksQ0FBQzFHLEtBQU4sRUFBYXVELEtBQWIsRUFBb0IsSUFBcEIsQ0FBekM7QUFDQSxTQUFPa0UsYUFBYSxDQUFDQyxJQUFkLENBQW9COUksSUFBRCxJQUFVNEkscUJBQXFCLENBQUNsSSxRQUF0QixDQUErQlYsSUFBL0IsQ0FBN0IsQ0FBUDtBQUNEOztBQUVELFNBQVMrSSxpQkFBVCxDQUNFcEUsS0FERixFQUVFM0UsSUFGRixFQUdFTSxTQUhGLEVBSUVjLEtBSkYsRUFJMEI7QUFFeEIsUUFBTTRILFlBQVksR0FBVSxFQUE1Qjs7QUFDQSxPQUFLLE1BQU0sQ0FBQ3pLLE1BQUQsRUFBUztBQUFFd0c7QUFBRixHQUFULENBQVgsSUFBa0NKLEtBQUssQ0FBQ3lCLE9BQU4sRUFBbEMsRUFBbUQ7QUFDakQsUUFBSSxDQUFDckIsS0FBTCxFQUFZO0FBQ1osUUFBSUEsS0FBSyxDQUFDM0QsS0FBTixLQUFnQkEsS0FBcEIsRUFBMkI7QUFDM0IsUUFBSTJELEtBQUssQ0FBQzFELElBQU4sS0FBZWYsU0FBbkIsRUFBOEI7QUFDL0I7QUFDRjs7OztBQzFiRCxNQUFNMkksS0FBSyxHQUFHLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxHQUFYLEVBQWdCLEdBQWhCLEVBQXFCLEdBQXJCLEVBQTBCLEdBQTFCLEVBQStCLEdBQS9CLEVBQW9DLEdBQXBDLENBQWQ7QUFDQSxNQUFNQyxLQUFLLEdBQUcsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixFQUFtQixDQUFuQixFQUFzQixDQUF0QixDQUFkOzs7QUNDYyxTQUFVQyxNQUFWLENBQ1pDLGFBRFksRUFFWkMsY0FGWSxFQUdaQyxhQUhZLEVBSVpDLGNBSlksRUFJVztBQUV2QixTQUFPO0FBQ0xDLFNBQUssRUFBRTtBQUNMQyxjQUFRLEVBQUVMLGFBREw7QUFFTE0sZUFBUyxFQUFFTDtBQUZOLEtBREY7QUFLTE0sU0FBSyxFQUFFO0FBQ0xGLGNBQVEsRUFBRUgsYUFETDtBQUVMSSxlQUFTLEVBQUVIO0FBRk47QUFMRixHQUFQO0FBVUQsQzs7QUNmRCxNQUFNSyxZQUFZLEdBQUk3SixRQUFELElBQXFCO0FBQ3hDLFdBQVNJLE1BQVQsQ0FBZ0IwSixJQUFoQixFQUE4QztBQUM1QzlKLFlBQVEsR0FBRzhKLElBQUksS0FBSyxVQUFULEdBQXNCLEtBQXRCLEdBQThCLE9BQXpDO0FBQ0EsV0FBTzlKLFFBQVA7QUFDRDs7QUFFRCxRQUFNK0osS0FBSyxHQUFHO0FBQ1pDLGlCQUFhLEVBQUUsQ0FBQ3pKLFNBQUQsRUFBdUIwSixlQUF2QixLQUFtRDtBQUNoRUEscUJBQWUsR0FBR0EsZUFBZSxJQUFJLEVBQXJDOztBQUVBLGNBQVExSixTQUFSO0FBQ0UsYUFBSyxNQUFMO0FBQWE7QUFDWFAsb0JBQVEsR0FBR2lLLGVBQWUsR0FBR2pLLFFBQTdCO0FBQ0EsbUJBQU9BLFFBQVA7QUFDRDs7QUFDRCxhQUFLLE1BQUw7QUFBYTtBQUNYQSxvQkFBUSxHQUFHLE1BQU1BLFFBQWpCO0FBQ0EsbUJBQU9BLFFBQVA7QUFDRDs7QUFDRCxhQUFLLFFBQUw7QUFBZTtBQUNiQSxvQkFBUSxHQUFHLE1BQU1pSyxlQUFOLEdBQXdCakssUUFBbkM7QUFDQSxtQkFBT0EsUUFBUDtBQUNEOztBQUNEO0FBQVM7QUFDUEEsb0JBQVEsR0FBR08sU0FBUyxDQUFDLENBQUQsQ0FBVCxDQUFhRCxXQUFiLEtBQTZCMkosZUFBN0IsR0FBK0NqSyxRQUExRDtBQUNBLG1CQUFPQSxRQUFQO0FBQ0Q7QUFoQkg7QUFrQkQsS0F0Qlc7QUF1QlprSyxXQUFPLEVBQUUsTUFBSztBQUNabEssY0FBUSxHQUFHLElBQUlBLFFBQVEsRUFBdkI7QUFDQSxhQUFPQSxRQUFQO0FBQ0QsS0ExQlc7QUEyQlpZLFdBQU8sRUFBR0wsU0FBRCxJQUF5QjtBQUNoQyxZQUFNNEosTUFBTSxHQUNWLE1BQU01SixTQUFOLEtBQW9CLFFBQXBCLEdBQStCLEdBQS9CLEdBQXFDQSxTQUFTLENBQUMyQyxNQUFWLENBQWlCLENBQWpCLEVBQW9CNUMsV0FBcEIsRUFEdkM7QUFFQU4sY0FBUSxJQUFJLE1BQU1tSyxNQUFsQjtBQUNBLGFBQU9uSyxRQUFQO0FBQ0QsS0FoQ1c7QUFpQ1pvSyxTQUFLLEVBQUUsTUFBSztBQUNWcEssY0FBUSxJQUFJLEdBQVo7QUFDQSxhQUFPQSxRQUFQO0FBQ0QsS0FwQ1c7QUFxQ1pxSyxhQUFTLEVBQUUsTUFBSztBQUNkckssY0FBUSxJQUFJLEdBQVo7QUFDQSxhQUFPQSxRQUFQO0FBQ0Q7QUF4Q1csR0FBZDs7QUEyQ0EsV0FBUytFLEdBQVQsQ0FBYXVGLFdBQWIsRUFBOEM7QUFDNUMsVUFBTTtBQUNKSixhQURJO0FBRUo5SixZQUFNLEVBQUVtSyxVQUZKO0FBR0ozSixhQUhJO0FBSUp3SixXQUpJO0FBS0pDLGVBTEk7QUFNSjlKLGVBTkk7QUFPSjBKO0FBUEksUUFRRkssV0FSSjtBQVVBLFFBQUlDLFVBQUosRUFBZ0IsT0FBT25LLE1BQU0sQ0FBQ21LLFVBQUQsQ0FBYjtBQUVoQixRQUFJTCxPQUFKLEVBQWFILEtBQUssQ0FBQ0csT0FBTjtBQUNiSCxTQUFLLENBQUNDLGFBQU4sQ0FBb0J6SixTQUFwQixFQUE0QzBKLGVBQTVDO0FBQ0EsUUFBSXJKLE9BQUosRUFBYW1KLEtBQUssQ0FBQ25KLE9BQU4sQ0FBY0EsT0FBZDtBQUViLFFBQUl5SixTQUFKLEVBQWVOLEtBQUssQ0FBQ00sU0FBTixHQUFmLEtBQ0ssSUFBSUQsS0FBSixFQUFXTCxLQUFLLENBQUNLLEtBQU47QUFFaEIsV0FBT3BLLFFBQVA7QUFDRDs7QUFDRCxTQUFPO0FBQ0wrRTtBQURLLEdBQVA7QUFHRCxDQTFFRDs7QUE0RUEsdURBQWU4RSxZQUFmLEU7O0FDL0VBO0FBT0E7QUFDQTtBQW1CQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTWSxXQUFULEdBQW9CO0FBQ2xCLFNBQU92QixZQUFBLENBQWEsQ0FBQ25HLEdBQUQsRUFBTTJILElBQU4sS0FBYztBQUNoQ3ZCLElBQUFBLGFBQUEsQ0FBZXdCLElBQUQsSUFBUztBQUNyQixZQUFNbk0sTUFBTSxHQUFHa00sSUFBSSxDQUFDeEwsTUFBTCxDQUFZeUwsSUFBSSxDQUFDeEwsUUFBTCxFQUFaLENBQWY7QUFDQTRELFNBQUcsQ0FBQ3dGLEdBQUosQ0FBUS9KLE1BQVIsRUFBZ0I7QUFBRXdHLGFBQUssRUFBRTtBQUFULE9BQWhCO0FBQ0QsS0FIRDtBQUlBLFdBQU9qQyxHQUFQO0FBQ0QsR0FOTSxFQU1KLElBQUlzRixHQUFKLEVBTkksQ0FBUDtBQU9EOztBQUVELE1BQU11QyxTQUFTLEdBQUcsQ0FDaEJoRyxLQUFLLEdBQUc2RixXQUFXLEVBREgsRUFFaEJJLGtCQUZnQixFQUdoQkMsWUFIZ0IsS0FJQTtBQUNoQmxHLE9BQUssR0FBRyxJQUFJeUQsR0FBSixDQUFRekQsS0FBUixDQUFSOztBQUVBLFdBQVNtRyxXQUFULENBQXFCQyxRQUFyQixFQUE0Q0MsUUFBUSxHQUFHckcsS0FBdkQsRUFBNEQ7QUFDMUQsUUFBSXZELEtBQUo7O0FBQ0EsU0FBS0EsS0FBTCxJQUFjMkosUUFBZCxFQUF3QjtBQUN0QixZQUFNL0osR0FBRyxHQUFHK0osUUFBUSxDQUFDM0osS0FBRCxDQUFwQjtBQUVBLFVBQUlkLFNBQUo7O0FBQ0EsV0FBS0EsU0FBTCxJQUFrQlUsR0FBbEIsRUFBdUI7QUFDckIsY0FBTWlLLE9BQU8sR0FBR2pLLEdBQUcsQ0FBQ1YsU0FBRCxDQUFuQjtBQUNBMkssZUFBTyxDQUFDNUMsT0FBUixDQUFpQnRFLENBQUQsSUFDZG1ILEVBQUUsQ0FBQ25ILENBQUQsRUFBSWlILFFBQUosQ0FBRixDQUFnQkcsS0FBaEIsQ0FBc0I7QUFBRTlKLGNBQUksRUFBRWYsU0FBUjtBQUFtQmMsZUFBSyxFQUFFQTtBQUExQixTQUF0QixDQURGO0FBR0Q7QUFDRjtBQUNGOztBQUVELFdBQVNnSyxRQUFULENBQ0U5SCxFQURGLEVBRUVDLEVBRkYsRUFHRTVDLE9BSEYsRUFHcUI7QUFFbkIsVUFBTW9FLEtBQUssR0FBR21HLEVBQUUsQ0FBQzVILEVBQUQsQ0FBRixDQUFPeUIsS0FBckIsQ0FGbUIsQ0FJbkI7O0FBQ0EsUUFBSSxDQUFDQSxLQUFMLEVBQVk7QUFDWixRQUFJLENBQUNzRyxRQUFRLENBQUNyTCxJQUFULENBQWNzRCxFQUFkLEVBQWtCQyxFQUFsQixDQUFMLEVBQTRCO0FBQzVCLFFBQUk1QyxPQUFPLElBQUksQ0FBQzBLLFFBQVEsQ0FBQ0MsU0FBVCxDQUFtQmhJLEVBQW5CLEVBQXVCQyxFQUF2QixDQUFoQixFQUE0Qzs7QUFFNUMsWUFBUXdCLEtBQUssQ0FBQzFELElBQWQ7QUFDRSxXQUFLLE1BQUw7QUFBYTtBQUNYLGNBQUlWLE9BQUosRUFBYTtBQUNYdUssY0FBRSxDQUFDNUgsRUFBRCxDQUFGLENBQU8zQyxPQUFQLENBQWVBLE9BQWY7QUFDRDs7QUFFRCxjQUFJZ0csU0FBUyxDQUFDNEUsU0FBVixDQUFvQmpJLEVBQXBCLEVBQXdCQyxFQUF4QixDQUFKLEVBQWlDO0FBQy9Cb0QscUJBQVMsQ0FBQ3NELE9BQVYsQ0FBa0IxRyxFQUFsQjtBQUNEOztBQUVEb0QsbUJBQVMsQ0FBQzZFLE1BQVY7O0FBQ0EsY0FBSTdFLFNBQVMsQ0FBQzhFLFdBQVYsQ0FBc0JuSSxFQUF0QixFQUEwQkMsRUFBMUIsQ0FBSixFQUFtQztBQUNqQ29ELHFCQUFTLENBQUMrRSxNQUFWLENBQWlCM0csS0FBSyxDQUFDM0QsS0FBdkIsRUFBOEJtQyxFQUE5QjtBQUNEOztBQUVEOUMsY0FBSSxDQUFDNkMsRUFBRCxDQUFKLENBQVMvQyxFQUFULENBQVlnRCxFQUFaO0FBQ0E7QUFDRDs7QUFFRCxXQUFLLE1BQUw7QUFBYTtBQUNYO0FBQ0EsZ0JBQU0rRyxVQUFVLEdBQUd4RixHQUFHLENBQUN3RixVQUFKLENBQWV2RixLQUFLLENBQUMzRCxLQUFyQixFQUE0Qm1DLEVBQTVCLENBQW5CO0FBQ0EsY0FBSStHLFVBQUosRUFBZ0JuSyxNQUFNLENBQUM0RSxLQUFLLENBQUMzRCxLQUFQLEVBQWNrSixVQUFkLENBQU4sQ0FBaEIsS0FDSzdKLElBQUksQ0FBQzZDLEVBQUQsQ0FBSixDQUFTL0MsRUFBVCxDQUFZZ0QsRUFBWjtBQUVMb0QsbUJBQVMsQ0FBQzZFLE1BQVY7QUFFQTtBQUNEOztBQUVEO0FBQ0UvSyxZQUFJLENBQUM2QyxFQUFELENBQUosQ0FBUy9DLEVBQVQsQ0FBWWdELEVBQVo7QUFDQW9ELGlCQUFTLENBQUM2RSxNQUFWO0FBaENKOztBQW1DQSxXQUFPN0csS0FBUDtBQUNEOztBQUVELFdBQVN4RSxNQUFULENBQ0VpQixLQURGLEVBRUV5SSxJQUZGLEVBR0VtQixRQUFRLEdBQUdyRyxLQUhiLEVBR2tCO0FBRWhCLFVBQU1nSCxhQUFhLEdBQUc3RyxHQUFHLENBQUM2RyxhQUFKLENBQWtCdkssS0FBbEIsRUFBeUJ5SSxJQUF6QixDQUF0QjtBQUVBLFVBQU1sRSxPQUFPLEdBQUdiLEdBQUcsQ0FBQzhHLFlBQUosQ0FBaUJ4SyxLQUFqQixFQUF3QjRKLFFBQXhCLENBQWhCO0FBQ0EsVUFBTWEsT0FBTyxHQUFHQyxVQUFVLEVBQTFCO0FBRUFyTCxRQUFJLENBQUNvTCxPQUFELEVBQVViLFFBQVYsQ0FBSixDQUF3QnpLLEVBQXhCLENBQTJCb0wsYUFBYSxDQUFDLENBQUQsQ0FBeEM7QUFDQWxMLFFBQUksQ0FBQ2tGLE9BQUQsRUFBVXFGLFFBQVYsQ0FBSixDQUF3QnpLLEVBQXhCLENBQTJCb0wsYUFBYSxDQUFDLENBQUQsQ0FBeEM7O0FBRUEsYUFBU0csVUFBVCxHQUFtQjtBQUNqQixZQUFNZixRQUFRLEdBQUdqRyxHQUFHLENBQUNpRyxRQUFKLENBQWFDLFFBQWIsQ0FBakI7QUFDQSxZQUFNYSxPQUFPLEdBQUdkLFFBQVEsQ0FBQzNKLEtBQUQsQ0FBUixDQUFnQjJLLElBQWhCLENBQXFCQyxJQUFyQixDQUEyQnpOLE1BQUQsSUFBVztBQUNuRCxjQUFNa00sSUFBSSxHQUFHbE0sTUFBTSxDQUFDRyxLQUFQLENBQWEsRUFBYixFQUFpQixDQUFqQixDQUFiO0FBQ0EsZUFBT21MLElBQUksS0FBSyxVQUFULEdBQ0haLGFBQUEsQ0FBY3dCLElBQWQsSUFBc0IsQ0FEbkIsR0FFSHhCLGFBQUEsQ0FBY3dCLElBQWQsSUFBc0IsQ0FGMUI7QUFHRCxPQUxlLENBQWhCO0FBT0EsYUFBT29CLE9BQVA7QUFDRCxLQXBCZSxDQXFCaEI7QUFDQTtBQUNBOztBQUNEOztBQUVELFFBQU1sRixTQUFTLEdBQUcsQ0FBQyxNQUFLO0FBQ3RCLGFBQVNzRixTQUFULENBQW1CQyxPQUFuQixFQUFvQzlLLEtBQXBDLEVBQWdEO0FBQzlDLFlBQU07QUFBRTVDLFNBQUY7QUFBS0M7QUFBTCxVQUFXSCxJQUFJLENBQUM0TixPQUFELENBQXJCO0FBQ0EsWUFBTTlKLElBQUksR0FBR2hCLEtBQUssS0FBSyxPQUFWLEdBQW9CM0MsQ0FBQyxHQUFHLENBQXhCLEdBQTRCQSxDQUFDLEdBQUcsQ0FBN0M7QUFDQSxhQUFPSyxNQUFNLENBQUM7QUFBRU4sU0FBRjtBQUFLQyxTQUFDLEVBQUUyRDtBQUFSLE9BQUQsQ0FBYjtBQUNEOztBQUVELFdBQU87QUFDTHFKLGlCQUFXLEVBQUUsQ0FBQ2hMLElBQUQsRUFBZUYsRUFBZixLQUFzQztBQUNqRCxjQUFNO0FBQUU5QixXQUFDLEVBQUVjO0FBQUwsWUFBWWpCLElBQUksQ0FBQ21DLElBQUQsQ0FBdEI7QUFDQSxjQUFNO0FBQUVoQyxXQUFDLEVBQUVnQjtBQUFMLFlBQVluQixJQUFJLENBQUNpQyxFQUFELENBQXRCO0FBRUEsZUFBT2dDLElBQUksQ0FBQ0MsR0FBTCxDQUFTakQsRUFBRSxHQUFHRSxFQUFkLE1BQXNCLENBQTdCO0FBQ0QsT0FOSTtBQU9MaU0sWUFBTSxFQUFFLENBQUN0SyxLQUFELEVBQWU4SyxPQUFmLEVBQWdDbEIsUUFBUSxHQUFHckcsS0FBM0MsS0FBMEQ7QUFDaEUsY0FBTXdILGVBQWUsR0FBR0YsU0FBUyxDQUFDQyxPQUFELEVBQVU5SyxLQUFWLENBQWpDO0FBQ0E4SixVQUFFLENBQUNpQixlQUFELEVBQWtCbkIsUUFBbEIsQ0FBRixDQUE4Qm9CLFlBQTlCLENBQTJDaEwsS0FBM0MsRUFBa0Q4SyxPQUFsRDtBQUNELE9BVkk7QUFXTFYsWUFBTSxFQUFFLENBQUNSLFFBQVEsR0FBR3JHLEtBQVosS0FBMkI7QUFDakMsYUFBSyxNQUFNMEgsU0FBWCxJQUF3QnJCLFFBQVEsQ0FBQ3NCLE1BQVQsRUFBeEIsRUFBMkM7QUFDekMsY0FBSUQsU0FBUyxDQUFDMUYsU0FBZCxFQUF5QixPQUFRMEYsU0FBUyxDQUFDMUYsU0FBVixHQUFzQjRGLFNBQTlCO0FBQzFCO0FBQ0YsT0FmSTtBQWdCTGhCLGVBQVMsRUFBRSxDQUFDOUssSUFBRCxFQUFlRixFQUFmLEVBQTJCeUssUUFBUSxHQUFHckcsS0FBdEMsS0FBd0Q7OztBQUNqRSxjQUFNSSxLQUFLLEdBQUdtRyxFQUFFLENBQUN6SyxJQUFELEVBQU91SyxRQUFQLENBQUYsQ0FBbUJqRyxLQUFqQztBQUNBLGNBQU00QixTQUFTLEdBQUcsY0FBUSxDQUFDN0IsR0FBVCxDQUFhdkUsRUFBYixPQUFnQixJQUFoQixJQUFnQjRFLGFBQWhCLEdBQWdCLE1BQWhCLEdBQWdCQSxHQUFFd0IsU0FBcEM7QUFDQSxZQUFJLENBQUM1QixLQUFELElBQVVBLEtBQUssQ0FBQzFELElBQU4sS0FBZSxNQUE3QixFQUFxQyxPQUFPLEtBQVA7QUFDckMsWUFBSSxDQUFDc0YsU0FBTCxFQUFnQixPQUFPLEtBQVA7QUFDaEIsWUFBSUEsU0FBUyxDQUFDdkYsS0FBVixLQUFvQjJELEtBQUssQ0FBQzNELEtBQTlCLEVBQXFDLE9BQU8sS0FBUDtBQUNyQyxlQUFPLElBQVA7QUFDRCxPQXZCSTtBQXdCTDZJLGFBQU8sRUFBRSxDQUFDMUosRUFBRCxFQUFheUssUUFBUSxHQUFHckcsS0FBeEIsS0FBaUM7OztBQUN4QyxjQUFNZ0MsU0FBUyxHQUFHLGNBQVEsQ0FBQzdCLEdBQVQsQ0FBYXZFLEVBQWIsT0FBZ0IsSUFBaEIsSUFBZ0I0RSxhQUFoQixHQUFnQixNQUFoQixHQUFnQkEsR0FBRXdCLFNBQXBDO0FBRUF1RSxVQUFFLENBQUN2RSxTQUFTLENBQUN1RixPQUFYLEVBQW9CbEIsUUFBcEIsQ0FBRixDQUFnQ1EsTUFBaEM7QUFDRDtBQTVCSSxLQUFQO0FBOEJELEdBckNpQixHQUFsQjs7QUF1Q0EsUUFBTU4sRUFBRSxHQUFHLENBQUMzTSxNQUFELEVBQWlCeU0sUUFBUSxHQUFHckcsS0FBNUIsTUFBdUM7QUFDaER3RyxTQUFLLEVBQUdwRyxLQUFELElBQTBCO0FBQy9CLFVBQUksQ0FBQ2lHLFFBQVEsQ0FBQ2xHLEdBQVQsQ0FBYXZHLE1BQWIsQ0FBTCxFQUEyQjtBQUUzQnlNLGNBQVEsQ0FBQzFDLEdBQVQsQ0FBYS9KLE1BQWIsRUFBcUI7QUFBRXdHO0FBQUYsT0FBckI7QUFDRCxLQUwrQztBQU1oRHlHLFVBQU0sRUFBRSxNQUFXO0FBQ2pCLFVBQUksQ0FBQ1IsUUFBUSxDQUFDbEcsR0FBVCxDQUFhdkcsTUFBYixDQUFMLEVBQTJCO0FBRTNCeU0sY0FBUSxDQUFDMUMsR0FBVCxDQUFhL0osTUFBYixFQUFxQjtBQUFFd0csYUFBSyxFQUFFO0FBQVQsT0FBckI7QUFDRCxLQVYrQztBQVdoRHBFLFdBQU8sRUFBR0wsU0FBRCxJQUErQjtBQUN0QyxZQUFNb0csU0FBUyxHQUFHc0UsUUFBUSxDQUFDbEcsR0FBVCxDQUFhdkcsTUFBYixDQUFsQjtBQUNBLFlBQU13RyxLQUFLLEdBQUcyQixTQUFTLFNBQVQsYUFBUyxXQUFULEdBQVMsTUFBVCxZQUFTLENBQUUzQixLQUF6QjtBQUNBLFVBQUksQ0FBQ0EsS0FBTCxFQUFZO0FBRVppRyxjQUFRLENBQUMxQyxHQUFULENBQWEvSixNQUFiLEVBQW1CaU8sZ0NBQ2Q5RixTQURjLEdBQ0w7QUFDWjNCLGFBQUssa0NBQU9BLEtBQVAsR0FBWTtBQUFFMUQsY0FBSSxFQUFFZjtBQUFSLFNBQVo7QUFETyxPQURLLENBQW5CO0FBSUQsS0FwQitDO0FBcUJoRDhMLGdCQUFZLEVBQUUsQ0FBQ2hMLEtBQUQsRUFBZThLLE9BQWYsS0FBd0M7QUFDcEQsVUFBSSxDQUFDbEIsUUFBUSxDQUFDbEcsR0FBVCxDQUFhdkcsTUFBYixDQUFMLEVBQTJCO0FBRTNCeU0sY0FBUSxDQUFDMUMsR0FBVCxDQUFhL0osTUFBYixFQUFxQjtBQUNuQndHLGFBQUssRUFBRSxJQURZO0FBRW5CNEIsaUJBQVMsRUFBRTtBQUNUdUY7QUFBUTtBQURDO0FBRVQ5SztBQUZTO0FBRlEsT0FBckI7QUFPRCxLQS9CK0M7O0FBZ0NoRCxRQUFJMkQsS0FBSixHQUFTOzs7QUFDUCxhQUFPLGNBQVEsQ0FBQ0QsR0FBVCxDQUFhdkcsTUFBYixPQUFvQixJQUFwQixJQUFvQjRHLGFBQXBCLEdBQW9CLE1BQXBCLEdBQW9CQSxHQUFFSixLQUE3QjtBQUNELEtBbEMrQzs7QUFtQ2hEQyxpQkFBYSxFQUFFLENBQUN5SCxNQUFNLEdBQUc3QixrQkFBa0IsSUFBSSxFQUFoQyxLQUE2QztBQUMxRCxZQUFNO0FBQUV2SixZQUFGO0FBQVFEO0FBQVIsVUFBa0I4SixFQUFFLENBQUMzTSxNQUFELEVBQVN5TSxRQUFULENBQUYsQ0FBcUJqRyxLQUE3Qzs7QUFFQSxjQUFRMEgsTUFBTSxDQUFDck0sTUFBZjtBQUNFLGFBQUssQ0FBTDtBQUFRO0FBQ04sZ0JBQUlpQixJQUFJLEtBQUssTUFBYixFQUFxQixPQUFPLEVBQVA7QUFDckIsbUJBQU8yRCxhQUFhLENBQUN6RyxNQUFELEVBQVN5TSxRQUFULENBQXBCO0FBQ0Q7O0FBQ0QsYUFBSyxDQUFMO0FBQVE7QUFDTixnQkFBSTNKLElBQUksS0FBSyxNQUFiLEVBQXFCLE9BQU8yRCxhQUFhLENBQUN6RyxNQUFELEVBQVN5TSxRQUFULENBQXBCLENBQXJCLEtBRUUsT0FBT3RGLG9CQUFvQixDQUN6Qm5ILE1BRHlCLEVBRXpCeU0sUUFGeUIsRUFHekJsRyxHQUFHLENBQUM4RyxZQUFKLENBQWlCeEssS0FBakIsQ0FIeUIsRUFJekJxTCxNQUFNLENBQUMsQ0FBRCxDQUptQixDQUEzQjtBQU1IOztBQUNEO0FBQVM7QUFDUCxnQkFBSXBMLElBQUksS0FBSyxNQUFiLEVBQXFCO0FBQ25CLGtCQUFJZ0UsVUFBVSxHQUFHTCxhQUFhLENBQUN6RyxNQUFELEVBQVN5TSxRQUFULENBQTlCO0FBQ0Esa0JBQUlsRyxHQUFHLENBQUM0SCxTQUFKLENBQWN0TCxLQUFkLEVBQXFCLFVBQXJCLENBQUosRUFDRWlFLFVBQVUsR0FBRyxDQUNYLEdBQUdBLFVBRFEsRUFFWCxHQUFHUCxHQUFHLENBQUM2RyxhQUFKLENBQWtCdkssS0FBbEIsRUFBeUJxSSxRQUZqQixDQUFiO0FBSUYsa0JBQUkzRSxHQUFHLENBQUM0SCxTQUFKLENBQWN0TCxLQUFkLEVBQXFCLFdBQXJCLENBQUosRUFDRWlFLFVBQVUsR0FBRyxDQUNYLEdBQUdBLFVBRFEsRUFFWCxHQUFHUCxHQUFHLENBQUM2RyxhQUFKLENBQWtCdkssS0FBbEIsRUFBeUJzSSxTQUZqQixDQUFiO0FBS0YscUJBQU9yRSxVQUFQO0FBQ0QsYUFkRCxNQWNPLE9BQU9MLGFBQWEsQ0FBQ3pHLE1BQUQsRUFBU3lNLFFBQVQsQ0FBcEI7QUFDUjtBQS9CSDtBQWlDRDtBQXZFK0MsR0FBdkMsQ0FBWDs7QUEwRUEsUUFBTXZLLElBQUksR0FBRyxDQUFDNkMsRUFBRCxFQUFhMEgsUUFBUSxHQUFHckcsS0FBeEIsTUFBbUM7QUFDOUNwRSxNQUFFLEVBQUdnRCxFQUFELElBQXFCO0FBQ3ZCLFlBQU13QixLQUFLLEdBQUdtRyxFQUFFLENBQUM1SCxFQUFELEVBQUswSCxRQUFMLENBQUYsQ0FBaUJqRyxLQUEvQjtBQUNBLFVBQUksQ0FBQ0EsS0FBTCxFQUFZLE9BRlcsQ0FJdkI7O0FBQ0FtRyxRQUFFLENBQUM1SCxFQUFELEVBQUswSCxRQUFMLENBQUYsQ0FBaUJRLE1BQWpCO0FBQ0FOLFFBQUUsQ0FBQzNILEVBQUQsRUFBS3lILFFBQUwsQ0FBRixDQUFpQkcsS0FBakIsQ0FBdUJwRyxLQUF2QjtBQUNEO0FBUjZDLEdBQW5DLENBQWI7O0FBV0EsUUFBTUQsR0FBRyxHQUFHO0FBQ1Y4RyxnQkFBWSxFQUFFLENBQUN4SyxLQUFELEVBQWU0SixRQUFRLEdBQUdyRyxLQUExQixLQUF1RDtBQUNuRSxXQUFLLE1BQU0sQ0FBQ3BHLE1BQUQsRUFBU29PLEtBQVQsQ0FBWCxJQUE4QjNCLFFBQVEsQ0FBQzVFLE9BQVQsRUFBOUIsRUFBa0Q7QUFDaEQsWUFDRXVHLEtBQUssQ0FBQzVILEtBQU4sSUFDQTRILEtBQUssQ0FBQzVILEtBQU4sQ0FBWTFELElBQVosS0FBcUIsTUFEckIsSUFFQXNMLEtBQUssQ0FBQzVILEtBQU4sQ0FBWTNELEtBQVosS0FBc0JBLEtBSHhCLEVBS0UsT0FBTzdDLE1BQVA7QUFDSDtBQUNGLEtBVlM7QUFXVndNLFlBQVEsRUFBRSxDQUFDQyxRQUFRLEdBQUdyRyxLQUFaLEtBQWtDO0FBQzFDLFlBQU1vRyxRQUFRLEdBQUc7QUFBRXZCLGFBQUssRUFBRSxFQUFUO0FBQXlCRyxhQUFLLEVBQUU7QUFBaEMsT0FBakI7O0FBQ0EsV0FBSyxNQUFNLENBQUNwTCxNQUFELEVBQVNvTyxLQUFULENBQVgsSUFBOEIzQixRQUFRLENBQUM1RSxPQUFULEVBQTlCLEVBQWtEO0FBQ2hELGNBQU07QUFBRXJCO0FBQUYsWUFBWTRILEtBQWxCO0FBQ0EsWUFBSSxDQUFDNUgsS0FBTCxFQUFZO0FBRVosY0FBTTtBQUFFMUQsY0FBRjtBQUFRRDtBQUFSLFlBQWtCMkQsS0FBeEI7QUFDQWdHLGdCQUFRLENBQUMzSixLQUFELENBQVIsQ0FBZ0JDLElBQWhCLElBQXdCMEosUUFBUSxDQUFDM0osS0FBRCxDQUFSLENBQWdCQyxJQUFoQixJQUNwQixDQUFDLEdBQUcwSixRQUFRLENBQUMzSixLQUFELENBQVIsQ0FBZ0JDLElBQWhCLENBQUosRUFBMkI5QyxNQUEzQixDQURvQixHQUVwQixDQUFDQSxNQUFELENBRko7QUFHRDs7QUFDRCxhQUFPd00sUUFBUDtBQUNELEtBdkJTO0FBd0JWNkIsdUJBQW1CLEVBQUUsQ0FDbkJ4TCxLQURtQixFQUVuQmQsU0FGbUIsRUFHbkIvQixNQUhtQixFQUluQnlNLFFBQVEsR0FBR3JHLEtBSlEsS0FLUDtBQUNaLFlBQU1vRyxRQUFRLEdBQUdqRyxHQUFHLENBQUNpRyxRQUFKLENBQWFDLFFBQWIsQ0FBakI7QUFDQSxVQUFJRCxRQUFRLENBQUMzSixLQUFELENBQVIsQ0FBZ0JkLFNBQWhCLEVBQTJCSSxRQUEzQixDQUFvQ25DLE1BQXBDLENBQUosRUFBaUQsT0FBTyxFQUFQO0FBRWpELFlBQU1zTyxNQUFNLEdBQWEsRUFBekI7QUFDQSxVQUFJOUIsUUFBUSxDQUFDM0osS0FBRCxDQUFSLENBQWdCZCxTQUFoQixFQUEyQkYsTUFBM0IsSUFBcUMsQ0FBekMsRUFBNEMsT0FBTyxFQUFQO0FBQzVDMkssY0FBUSxDQUFDM0osS0FBRCxDQUFSLENBQWdCZCxTQUFoQixFQUEyQitILE9BQTNCLENBQW9DdEUsQ0FBRCxJQUFNO0FBQ3ZDLFlBQUltSCxFQUFFLENBQUNuSCxDQUFELEVBQUlpSCxRQUFKLENBQUYsQ0FBZ0JoRyxhQUFoQixHQUFnQ3RFLFFBQWhDLENBQXlDbkMsTUFBekMsQ0FBSixFQUFzRHNPLE1BQU0sQ0FBQzNKLElBQVAsQ0FBWWEsQ0FBWjtBQUN2RCxPQUZEO0FBR0EsYUFBTzhJLE1BQVA7QUFDRCxLQXZDUztBQXdDVkMsK0JBQTJCLEVBQUUsQ0FBQ3JNLElBQUQsRUFBZXNNLEdBQWYsS0FBd0M7OztBQUNuRSxZQUFNbkMsa0JBQWtCLEdBQWEsRUFBckM7QUFFQSxZQUFNN0YsS0FBSyxHQUFHLFdBQUssQ0FBQ0QsR0FBTixDQUFVaUksR0FBVixPQUFjLElBQWQsSUFBYzVILGFBQWQsR0FBYyxNQUFkLEdBQWNBLEdBQUVKLEtBQTlCO0FBQ0EsWUFBTWdELFFBQVEsR0FBR2hELEtBQUssQ0FBQzNELEtBQU4sS0FBZ0IsT0FBaEIsR0FBMEIsT0FBMUIsR0FBb0MsT0FBckQ7QUFDQSxZQUFNd0ssWUFBWSxHQUFHOUcsR0FBRyxDQUFDOEcsWUFBSixDQUFpQjdELFFBQWpCLENBQXJCO0FBRUEsWUFBTWlGLGFBQWEsR0FBR2hJLGFBQWEsQ0FBQytILEdBQUQsRUFBTXBJLEtBQU4sQ0FBYixDQUEwQmpFLFFBQTFCLENBQW1Da0wsWUFBbkMsQ0FBdEI7QUFDQSxVQUFJb0IsYUFBSixFQUFtQnBDLGtCQUFrQixDQUFDMUgsSUFBbkIsQ0FBd0I2SixHQUF4QjtBQUVuQixZQUFNRSxlQUFlLEdBQUd6RSxrQkFBa0IsQ0FDeENvRCxZQUR3QyxFQUV4QzdELFFBRndDLEVBR3hDdEgsSUFId0MsRUFJeENrRSxLQUp3QyxDQUExQztBQU1BLFVBQUlzSSxlQUFlLElBQUlBLGVBQWUsS0FBS0YsR0FBM0MsRUFDRW5DLGtCQUFrQixDQUFDMUgsSUFBbkIsQ0FBd0IrSixlQUF4QjtBQUVGLGFBQU9yQyxrQkFBUDtBQUNELEtBNURTO0FBNkRWc0MsZUFBVyxFQUFFLENBQ1hDLFdBRFcsRUFFWHZDLGtCQUZXLEVBR1hJLFFBQVEsR0FBR3JHLEtBSEEsS0FJQTtBQUNYLFlBQU1nQixPQUFPLEdBQUdiLEdBQUcsQ0FBQzhHLFlBQUosQ0FBaUJ1QixXQUFqQixFQUE4Qm5DLFFBQTlCLENBQWhCO0FBQ0EsWUFBTTNGLFVBQVUsR0FBRzZGLEVBQUUsQ0FBQ3ZGLE9BQUQsRUFBVXFGLFFBQVYsQ0FBRixDQUFzQmhHLGFBQXRCLEVBQW5CLENBRlcsQ0FHWDs7QUFDQSxVQUFJNEYsa0JBQWtCLENBQUN4SyxNQUFuQixLQUE4QixDQUFsQyxFQUFxQztBQUNuQyxZQUFJdUksc0JBQXNCLENBQUNoRCxPQUFELEVBQVVpRixrQkFBa0IsQ0FBQyxDQUFELENBQTVCLEVBQWlDSSxRQUFqQyxDQUExQixFQUNFLE9BQU8sS0FBUDtBQUNIOztBQUNELFVBQUkzRixVQUFVLENBQUNqRixNQUFmLEVBQXVCLE9BQU8sS0FBUDtBQUN2QixhQUFPLElBQVA7QUFDRCxLQTNFUzs7QUE0RVZ1TCxpQkFBYSxDQUFDdkssS0FBRCxFQUFhO0FBQ3hCLFlBQU1zSixJQUFJLEdBQUd0SixLQUFLLEtBQUssT0FBVixHQUFvQixDQUFwQixHQUF3QixDQUFyQztBQUNBLGFBQU87QUFDTHFJLGdCQUFRLEVBQUUsQ0FBQyxJQUFJaUIsSUFBSSxFQUFULEVBQWEsSUFBSUEsSUFBSSxFQUFyQixDQURMO0FBRUxoQixpQkFBUyxFQUFFLENBQUMsSUFBSWdCLElBQUksRUFBVCxFQUFhLElBQUlBLElBQUksRUFBckI7QUFGTixPQUFQO0FBSUQsS0FsRlM7O0FBbUZWSixjQUFVLENBQUNsSixLQUFELEVBQWViLEVBQWYsRUFBeUI7QUFDakMsVUFBSStKLFVBQVUsR0FBa0MsRUFBaEQ7QUFDQSxZQUFNcUIsYUFBYSxHQUFHN0csR0FBRyxDQUFDNkcsYUFBSixDQUFrQnZLLEtBQWxCLENBQXRCOztBQUVBLFdBQUssTUFBTSxDQUFDeUksSUFBRCxFQUFPb0IsT0FBUCxDQUFYLElBQThCdUIsTUFBTSxDQUFDcEcsT0FBUCxDQUFldUYsYUFBZixDQUE5QixFQUE2RDtBQUMzRCxZQUFJVixPQUFPLENBQUMsQ0FBRCxDQUFQLEtBQWUxSyxFQUFuQixFQUF1QitKLFVBQVUsR0FBR1QsSUFBYjtBQUN4Qjs7QUFDRCxhQUFPUyxVQUFQO0FBQ0QsS0EzRlM7O0FBNEZWOEMseUJBQXFCLEVBQUUsQ0FBQzdPLE1BQUQsRUFBaUJ5TSxRQUFRLEdBQUdyRyxLQUE1QixLQUFnRDtBQUNyRSxZQUFNSSxLQUFLLEdBQUdtRyxFQUFFLENBQUMzTSxNQUFELEVBQVN5TSxRQUFULENBQUYsQ0FBcUJqRyxLQUFuQztBQUVBLFlBQU1zSSxZQUFZLEdBQUd4QyxZQUFZLElBQUkxQixNQUFNLENBQUMsSUFBRCxFQUFPLElBQVAsRUFBYSxJQUFiLEVBQW1CLElBQW5CLENBQTNDOztBQUVBLFVBQ0VrRSxZQUFZLENBQUN0SSxLQUFLLENBQUMzRCxLQUFQLENBQVosQ0FBMEJxSSxRQUExQixJQUNBNEQsWUFBWSxDQUFDdEksS0FBSyxDQUFDM0QsS0FBUCxDQUFaLENBQTBCc0ksU0FGNUIsRUFHRTtBQUNBO0FBQ0EsWUFBSTNFLEtBQUssQ0FBQzFELElBQU4sS0FBZSxNQUFuQixFQUEyQjtBQUN6QmdNLHNCQUFZLENBQUN0SSxLQUFLLENBQUMzRCxLQUFQLENBQVosQ0FBMEJxSSxRQUExQixHQUFxQyxLQUFyQztBQUNBNEQsc0JBQVksQ0FBQ3RJLEtBQUssQ0FBQzNELEtBQVAsQ0FBWixDQUEwQnNJLFNBQTFCLEdBQXNDLEtBQXRDO0FBQ0Q7O0FBRUQsWUFBSTNFLEtBQUssQ0FBQzFELElBQU4sS0FBZSxNQUFuQixFQUEyQjtBQUN6QjtBQUNBLGdCQUFNLENBQUNvSixJQUFELElBQVNsTSxNQUFNLENBQUNHLEtBQVAsQ0FBYSxFQUFiLENBQWY7QUFDQSxnQkFBTStLLFFBQVEsR0FBR1IsYUFBQSxDQUFjd0IsSUFBZCxJQUFzQixDQUF2QztBQUNBLGNBQUloQixRQUFKLEVBQWM0RCxZQUFZLENBQUN0SSxLQUFLLENBQUMzRCxLQUFQLENBQVosQ0FBMEJxSSxRQUExQixHQUFxQyxLQUFyQyxDQUFkLEtBQ0s0RCxZQUFZLENBQUN0SSxLQUFLLENBQUMzRCxLQUFQLENBQVosQ0FBMEJzSSxTQUExQixHQUFzQyxLQUF0QztBQUNOO0FBQ0Y7O0FBRUQsYUFBTzJELFlBQVA7QUFDRCxLQXJIUztBQXNIVlgsYUFBUyxFQUFFLENBQ1R0TCxLQURTLEVBRVR5SSxJQUZTLEVBR1RtQixRQUFRLEdBQUdyRyxLQUhGLEtBSUU7QUFDWCxVQUFJa0csWUFBWSxJQUFJLENBQUNBLFlBQVksQ0FBQ3pKLEtBQUQsQ0FBWixDQUFvQnlJLElBQXBCLENBQXJCLEVBQWdELE9BQU8sS0FBUCxDQURyQyxDQUdYOztBQUNBLFVBQUksQ0FBQ3lELGlCQUFpQixFQUF0QixFQUEwQixPQUFPLEtBQVA7QUFFMUIsWUFBTXZGLFFBQVEsR0FBRzNHLEtBQUssS0FBSyxPQUFWLEdBQW9CLE9BQXBCLEdBQThCLE9BQS9DO0FBQ0EsWUFBTW1NLFFBQVEsR0FBR2pILHlCQUF5QixDQUFDeUIsUUFBRCxFQUFXaUQsUUFBWCxDQUExQztBQUVBLFlBQU1XLGFBQWEsR0FBRzdHLEdBQUcsQ0FBQzZHLGFBQUosQ0FBa0J2SyxLQUFsQixFQUF5QnlJLElBQXpCLENBQXRCOztBQUNBLFdBQUssTUFBTXRMLE1BQVgsSUFBcUJvTixhQUFyQixFQUFvQztBQUNsQztBQUNBLFlBQUlULEVBQUUsQ0FBQzNNLE1BQUQsRUFBU3lNLFFBQVQsQ0FBRixDQUFxQmpHLEtBQXpCLEVBQWdDLE9BQU8sS0FBUCxDQUZFLENBR2xDOztBQUNBLFlBQUl3SSxRQUFRLENBQUM3TSxRQUFULENBQWtCbkMsTUFBbEIsQ0FBSixFQUErQixPQUFPLEtBQVA7QUFDaEM7O0FBRUQsYUFBTyxJQUFQOztBQUVBLGVBQVMrTyxpQkFBVCxHQUEwQjtBQUN4QixZQUFJRSxVQUFVLEdBQUcsS0FBakI7QUFDQSxjQUFNOUMsSUFBSSxHQUFHdEosS0FBSyxLQUFLLE9BQVYsR0FBb0IsQ0FBcEIsR0FBd0IsQ0FBckM7QUFDQSxjQUFNcU0sU0FBUyxHQUNiNUQsSUFBSSxLQUFLLFdBQVQsR0FBdUJaLGFBQUEsQ0FBYyxHQUFkLENBQXZCLEdBQTRDQSxhQUFBLENBQWMsR0FBZCxDQUQ5QztBQUVBLGNBQU15RSxPQUFPLEdBQ1g3RCxJQUFJLEtBQUssV0FBVCxHQUF1QlosYUFBQSxDQUFjLEdBQWQsQ0FBdkIsR0FBNENBLGFBQUEsQ0FBYyxHQUFkLENBRDlDOztBQUVBLGFBQUssSUFBSTBFLENBQUMsR0FBR0YsU0FBYixFQUF3QkUsQ0FBQyxJQUFJRCxPQUE3QixFQUFzQ0MsQ0FBQyxFQUF2QyxFQUEyQztBQUN6QyxnQkFBTXBQLE1BQU0sR0FBRzBLLEtBQUssQ0FBQzBFLENBQUQsQ0FBTCxHQUFXakQsSUFBMUI7QUFFQSxnQkFBTTNGLEtBQUssR0FBR21HLEVBQUUsQ0FBQzNNLE1BQUQsRUFBU3lNLFFBQVQsQ0FBRixDQUFxQmpHLEtBQW5DO0FBQ0EsY0FBSSxDQUFDQSxLQUFMLEVBQVk7QUFFWixjQUFJQSxLQUFLLENBQUMxRCxJQUFOLEtBQWUsTUFBbkIsRUFBMkJtTSxVQUFVLEdBQUcsSUFBYjtBQUM1Qjs7QUFDRCxlQUFPQSxVQUFQO0FBQ0Q7QUFDRixLQTlKUztBQStKVkkseUJBQXFCLEVBQUdDLE9BQUQsSUFBa0M7QUFDdkQsWUFBTUMsV0FBVyxHQUFZLEVBQTdCO0FBRUEsWUFBTTlDLFFBQVEsR0FBR1IsV0FBVyxFQUE1QjtBQUNBTSxpQkFBVyxDQUFDUCxRQUFELEVBQTZCUyxRQUE3QixDQUFYO0FBQ0EsVUFBSUQsUUFBUSxHQUFHUixRQUFmLENBTHVELENBT3ZEOztBQUNBLFlBQU1sRSxJQUFJLEdBQUd3SCxPQUFPLENBQUN4SCxJQUFSLEVBQWI7QUFFQTs7QUFDQSxXQUFLLE1BQU0sQ0FBQ3NILENBQUQsRUFBSUssQ0FBSixDQUFYLElBQXFCM0gsSUFBSSxDQUFDRCxPQUFMLEVBQXJCLEVBQXFDO0FBQ25DLGNBQU02SCxNQUFNLEdBQUduTyxhQUFhLENBQUNrTyxDQUFELENBQTVCO0FBQ0EsY0FBTTVNLEtBQUssR0FBR3VNLENBQUMsR0FBRyxDQUFKLEtBQVUsQ0FBVixHQUFjLE9BQWQsR0FBd0IsT0FBdEM7O0FBRUEsWUFBSU0sTUFBTSxDQUFDOU4sTUFBWCxFQUFtQjtBQUNqQkEsZ0JBQU0sQ0FBQ2lCLEtBQUQsRUFBUTZNLE1BQU0sQ0FBQzlOLE1BQWYsRUFBdUI2SyxRQUF2QixDQUFOO0FBQ0FELGtCQUFRLEdBQUdqRyxHQUFHLENBQUNpRyxRQUFKLENBQWFDLFFBQWIsQ0FBWDtBQUNBOEMscUJBQVcsQ0FBQzVLLElBQVosQ0FBaUIsSUFBSWtGLEdBQUosQ0FBUTRDLFFBQVIsQ0FBakI7QUFDQTtBQUNEOztBQUVELGNBQU1rRCxjQUFjLEdBQUduRCxRQUFRLENBQUMzSixLQUFELENBQVIsQ0FBZ0I2TSxNQUFNLENBQUMzTixTQUF2QixFQUFrQ3dELE1BQWxDLENBQTBDQyxDQUFELElBQzlEaUIsYUFBYSxDQUFDakIsQ0FBRCxFQUFJaUgsUUFBSixDQUFiLENBQTJCdEssUUFBM0IsQ0FBb0N1TixNQUFNLENBQUMxTixFQUEzQyxDQURxQixDQUF2QixDQVhtQyxDQWVuQzs7QUFDQSxZQUFJK0MsRUFBSjs7QUFDQSxZQUFJMkssTUFBTSxDQUFDeE4sSUFBWCxFQUFpQjtBQUNmLGdCQUFNVixRQUFRLEdBQUdrTyxNQUFNLENBQUN4TixJQUF4QjtBQUNBLGNBQUlWLFFBQVEsQ0FBQ0ssTUFBVCxLQUFvQixDQUF4QixFQUEyQmtELEVBQUUsR0FBR3ZELFFBQUwsQ0FBM0IsS0FDSztBQUNIdUQsY0FBRSxHQUNBNEssY0FBYyxDQUFDbEMsSUFBZixDQUFxQmpJLENBQUQsSUFBTTtBQUN4QjtBQUNBLHFCQUFPb0ssS0FBSyxDQUFDdFAsTUFBTSxDQUFDa0IsUUFBRCxDQUFQLENBQUwsR0FDSGdFLENBQUMsQ0FBQyxDQUFELENBQUQsS0FBU2hFLFFBRE4sR0FFSGdFLENBQUMsQ0FBQyxDQUFELENBQUQsS0FBU2hFLFFBRmI7QUFHRCxhQUxELEtBS00sRUFOUjtBQU9EO0FBQ0YsU0FaRCxNQVlPdUQsRUFBRSxHQUFHNEssY0FBYyxDQUFDLENBQUQsQ0FBbkI7O0FBRVAsY0FBTW5KLEtBQUssR0FBR21HLEVBQUUsQ0FBQzVILEVBQUQsRUFBSzBILFFBQUwsQ0FBRixDQUFpQmpHLEtBQS9COztBQUNBLFlBQUksQ0FBQ3pCLEVBQUQsSUFBTyxDQUFDeUIsS0FBWixFQUFtQjtBQUNqQjtBQUNELFNBbENrQyxDQW9DbkM7OztBQUNBLFlBQUlBLEtBQUssQ0FBQzFELElBQU4sS0FBZSxNQUFuQixFQUEyQjtBQUN6QixjQUFJc0YsU0FBUyxDQUFDNEUsU0FBVixDQUFvQmpJLEVBQXBCLEVBQXdCMkssTUFBTSxDQUFDMU4sRUFBL0IsRUFBbUN5SyxRQUFuQyxDQUFKLEVBQWtEO0FBQ2hEckUscUJBQVMsQ0FBQ3NELE9BQVYsQ0FBa0JnRSxNQUFNLENBQUMxTixFQUF6QixFQUE2QnlLLFFBQTdCO0FBQ0Q7O0FBRURyRSxtQkFBUyxDQUFDNkUsTUFBVixDQUFpQlIsUUFBakI7QUFFQSxjQUFJckUsU0FBUyxDQUFDOEUsV0FBVixDQUFzQm5JLEVBQXRCLEVBQTBCMkssTUFBTSxDQUFDMU4sRUFBakMsQ0FBSixFQUNFb0csU0FBUyxDQUFDK0UsTUFBVixDQUFpQnRLLEtBQWpCLEVBQXdCNk0sTUFBTSxDQUFDMU4sRUFBL0IsRUFBbUN5SyxRQUFuQzs7QUFFRixjQUFJaUQsTUFBTSxDQUFDdE4sT0FBWCxFQUFvQjtBQUNsQnVLLGNBQUUsQ0FBQzVILEVBQUQsRUFBSzBILFFBQUwsQ0FBRixDQUFpQnJLLE9BQWpCLENBQXlCc04sTUFBTSxDQUFDdE4sT0FBaEM7QUFDRDtBQUNGLFNBYkQsTUFhT2dHLFNBQVMsQ0FBQzZFLE1BQVYsQ0FBaUJSLFFBQWpCOztBQUVQdkssWUFBSSxDQUFDNkMsRUFBRCxFQUFLMEgsUUFBTCxDQUFKLENBQW1CekssRUFBbkIsQ0FBc0IwTixNQUFNLENBQUMxTixFQUE3QjtBQUNBd0ssZ0JBQVEsR0FBR2pHLEdBQUcsQ0FBQ2lHLFFBQUosQ0FBYUMsUUFBYixDQUFYO0FBQ0E4QyxtQkFBVyxDQUFDNUssSUFBWixDQUFpQixJQUFJa0YsR0FBSixDQUFRNEMsUUFBUixDQUFqQjtBQUNEOztBQUVELGFBQU84QyxXQUFQO0FBQ0QsS0FwT1M7O0FBcU9WbEUsZ0JBQVksQ0FDVm5KLElBRFUsRUFFVkYsRUFGVSxFQUdWSSxPQUhVLEVBSVZ3SixLQUpVLEVBS1ZDLFNBTFUsRUFNVlksUUFBUSxHQUFHckcsS0FORCxFQU1NOzs7QUFFaEIsWUFBTTBGLFdBQVcsR0FBeUIsRUFBMUM7QUFFQSxZQUFNO0FBQUVoSixZQUFGO0FBQVFEO0FBQVIsVUFBa0I4SixFQUFFLENBQUN6SyxJQUFELEVBQU91SyxRQUFQLENBQUYsQ0FBbUJqRyxLQUEzQztBQUNBc0YsaUJBQVcsQ0FBQy9KLFNBQVosR0FBd0JlLElBQXhCO0FBRUEsVUFBSStJLFNBQUosRUFBZUMsV0FBVyxDQUFDRCxTQUFaLEdBQXdCQSxTQUF4QixDQUFmLEtBQ0ssSUFBSUQsS0FBSixFQUFXRSxXQUFXLENBQUNGLEtBQVosR0FBb0JBLEtBQXBCO0FBRWhCLFVBQUlGLE9BQU8sR0FBRyxLQUFkOztBQUNBLGNBQVE1SSxJQUFSO0FBQ0UsYUFBSyxNQUFMO0FBQWE7QUFDWDRJLG1CQUFPLEdBQUcsZUFBSyxDQUFDN0ksS0FBRCxFQUFRQyxJQUFSLENBQUwsQ0FDUGEsZUFETyxDQUNTekIsSUFEVCxPQUNjLElBRGQsSUFDYzBFLGFBRGQsR0FDYyxNQURkLEdBQ2NBLEdBQ3BCekUsUUFEb0IsQ0FDWEgsRUFEVyxDQUR4QjtBQUdBOEosdUJBQVcsQ0FBQ0osT0FBWixHQUFzQkEsT0FBdEI7QUFDQSxnQkFBSUEsT0FBSixFQUFhSSxXQUFXLENBQUNMLGVBQVosR0FBOEJ2SixJQUFJLENBQUMsQ0FBRCxDQUFsQztBQUNiO0FBQ0Q7O0FBQ0Q7QUFBUztBQUNQd0osbUJBQU8sR0FBRyxDQUFDLENBQUNpQixFQUFFLENBQUMzSyxFQUFELEVBQUt5SyxRQUFMLENBQUYsQ0FBaUJqRyxLQUE3QjtBQUNBc0YsdUJBQVcsQ0FBQ0osT0FBWixHQUFzQkEsT0FBdEI7QUFDRDtBQVpIOztBQWVBLFVBQUl0SixPQUFKLEVBQWEwSixXQUFXLENBQUMxSixPQUFaLEdBQXNCQSxPQUF0QixDQTFCRyxDQTRCaEI7O0FBQ0EsWUFBTWlNLG1CQUFtQixHQUFHOUgsR0FBRyxDQUFDOEgsbUJBQUosQ0FDMUJ4TCxLQUQwQixFQUUxQkMsSUFGMEIsRUFHMUJkLEVBSDBCLEVBSTFCeUssUUFKMEIsQ0FBNUI7O0FBTUEsY0FBUTRCLG1CQUFtQixDQUFDeE0sTUFBNUI7QUFDRSxhQUFLLENBQUw7QUFDRWlLLHFCQUFXLENBQUNMLGVBQVosR0FBOEJ2SixJQUE5QjtBQUNBOztBQUNGLGFBQUssQ0FBTDtBQUFRO0FBQ047QUFDQSxrQkFBTTJOLFVBQVUsR0FBR3hCLG1CQUFtQixDQUFDWixJQUFwQixDQUNoQmpJLENBQUQsSUFBT0EsQ0FBQyxLQUFLdEQsSUFESSxDQUFuQjtBQUdBNEosdUJBQVcsQ0FBQ0wsZUFBWixHQUNFb0UsVUFBVSxDQUFDLENBQUQsQ0FBVixLQUFrQjNOLElBQUksQ0FBQyxDQUFELENBQXRCLEdBQTRCQSxJQUFJLENBQUMsQ0FBRCxDQUFoQyxHQUFzQ0EsSUFBSSxDQUFDLENBQUQsQ0FENUM7QUFFRDtBQVhIOztBQWNBLGFBQU9tSixnQkFBWSxDQUFDckosRUFBRCxDQUFaLENBQWlCdUUsR0FBakIsQ0FBcUJ1RixXQUFyQixDQUFQO0FBQ0Q7O0FBN1JTLEdBQVo7QUFnU0EsUUFBTWdCLFFBQVEsR0FBRztBQUNmckwsUUFBSSxFQUFFLENBQUNTLElBQUQsRUFBZUYsRUFBZixFQUEyQnlLLFFBQVEsR0FBR3JHLEtBQXRDLEtBQXdEO0FBQzVELFlBQU1JLEtBQUssR0FBR21HLEVBQUUsQ0FBQ3pLLElBQUQsRUFBT3VLLFFBQVAsQ0FBRixDQUFtQmpHLEtBQWpDO0FBQ0EsVUFBSSxDQUFDQSxLQUFMLEVBQVksT0FBTyxLQUFQO0FBRVosVUFBSSxDQUFDbUcsRUFBRSxDQUFDekssSUFBRCxFQUFPdUssUUFBUCxDQUFGLENBQW1CaEcsYUFBbkIsR0FBbUN0RSxRQUFuQyxDQUE0Q0gsRUFBNUMsQ0FBTCxFQUFzRCxPQUFPLEtBQVA7QUFFdEQsYUFBTyxJQUFQO0FBQ0QsS0FSYztBQVNmK0ssYUFBUyxFQUFFLENBQUM3SyxJQUFELEVBQWVGLEVBQWYsRUFBMkJ5SyxRQUFRLEdBQUdyRyxLQUF0QyxLQUF3RDtBQUNqRSxZQUFNSSxLQUFLLEdBQUdtRyxFQUFFLENBQUN6SyxJQUFELEVBQU91SyxRQUFQLENBQUYsQ0FBbUJqRyxLQUFqQztBQUVBLFVBQUksTUFBSyxTQUFMLFNBQUssV0FBTCxHQUFLLE1BQUwsUUFBSyxDQUFFMUQsSUFBUCxNQUFnQixNQUFwQixFQUE0QixPQUFPLEtBQVA7QUFFNUIsWUFBTWdOLFVBQVUsR0FBR3RKLEtBQUssQ0FBQzNELEtBQU4sS0FBZ0IsT0FBaEIsR0FBMEIsQ0FBMUIsR0FBOEIsQ0FBakQ7QUFDQSxZQUFNLEdBQUdzSixJQUFILElBQVduSyxFQUFFLENBQUM3QixLQUFILENBQVMsRUFBVCxDQUFqQjtBQUNBLFVBQUksQ0FBQ2dNLElBQUQsS0FBVTJELFVBQWQsRUFBMEIsT0FBTyxLQUFQO0FBRTFCLGFBQU8sSUFBUDtBQUNEO0FBbkJjLEdBQWpCO0FBc0JBLFNBQU87QUFDTDdELGVBREs7QUFFTE0sZUFGSztBQUdMM0ssVUFISztBQUlMd0csYUFKSztBQUtMdUUsTUFMSztBQU1MekssUUFOSztBQU9McUUsT0FQSztBQVFMdUcsWUFSSztBQVNMRCxZQVRLOztBQVVMLFFBQUl6RyxLQUFKLEdBQVM7QUFDUCxhQUFPQSxLQUFQO0FBQ0Q7O0FBWkksR0FBUDtBQWNELENBcmlCRDs7QUF1aUJBLG9EQUFlZ0csU0FBZixFOztBQy9rQkE7QUFFYyxTQUFVMkQsT0FBVixDQUFrQkMsV0FBbEIsRUFBMEM7QUFDdEQsUUFBTVYsT0FBTyxHQUFnQi9NLGVBQWUsQ0FBQ3lOLFdBQUQsQ0FBZixJQUFnQyxFQUE3RDtBQUVBLFNBQU87QUFDTEMsY0FBVSxFQUFHek8sUUFBRCxJQUFxQjtBQUMvQixZQUFNME8sUUFBUSxHQUFHWixPQUFPLENBQUNBLE9BQU8sQ0FBQ3pOLE1BQVIsR0FBaUIsQ0FBbEIsQ0FBeEI7O0FBQ0EsVUFBSXFPLFFBQVEsSUFBSUEsUUFBUSxDQUFDck8sTUFBVCxLQUFvQixDQUFwQyxFQUF1QztBQUNyQ3FPLGdCQUFRLENBQUN2TCxJQUFULENBQWNuRCxRQUFkO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsY0FBTTJPLE9BQU8sR0FBRyxDQUFDM08sUUFBRCxDQUFoQjtBQUNBOE4sZUFBTyxDQUFDM0ssSUFBUixDQUFhd0wsT0FBYjtBQUNEOztBQUVELGFBQU9iLE9BQVA7QUFDRDtBQVhJLEdBQVA7QUFhRCxDOztBQ2xCRCxNQUFNRSxRQUFRLEdBQWdCO0FBQzVCdkUsT0FBSyxFQUFFO0FBQ0x1QyxRQUFJLEVBQUUsQ0FBQyxJQUFELEVBQU8sSUFBUCxDQUREO0FBRUw0QyxVQUFNLEVBQUUsQ0FBQyxJQUFELEVBQU8sSUFBUCxDQUZIO0FBR0xDLFVBQU0sRUFBRSxDQUFDLElBQUQsRUFBTyxJQUFQLENBSEg7QUFJTDlHLFFBQUksRUFBRSxDQUFDLElBQUQsQ0FKRDtBQUtMK0csU0FBSyxFQUFFLENBQUMsSUFBRCxDQUxGO0FBTUxySSxRQUFJLEVBQUUsQ0FBQyxJQUFELEVBQU8sSUFBUCxFQUFhLElBQWIsRUFBbUIsSUFBbkIsRUFBeUIsSUFBekIsRUFBK0IsSUFBL0IsRUFBcUMsSUFBckMsRUFBMkMsSUFBM0M7QUFORCxHQURxQjtBQVM1Qm1ELE9BQUssRUFBRTtBQUNMb0MsUUFBSSxFQUFFLENBQUMsSUFBRCxFQUFPLElBQVAsQ0FERDtBQUVMNEMsVUFBTSxFQUFFLENBQUMsSUFBRCxFQUFPLElBQVAsQ0FGSDtBQUdMQyxVQUFNLEVBQUUsQ0FBQyxJQUFELEVBQU8sSUFBUCxDQUhIO0FBSUw5RyxRQUFJLEVBQUUsQ0FBQyxJQUFELENBSkQ7QUFLTCtHLFNBQUssRUFBRSxDQUFDLElBQUQsQ0FMRjtBQU1MckksUUFBSSxFQUFFLENBQUMsSUFBRCxFQUFPLElBQVAsRUFBYSxJQUFiLEVBQW1CLElBQW5CLEVBQXlCLElBQXpCLEVBQStCLElBQS9CLEVBQXFDLElBQXJDLEVBQTJDLElBQTNDO0FBTkQ7QUFUcUIsQ0FBOUI7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcm9DaGVzcy8uL3NyYy91dGlscy9oZWxwZXJzLnRzPzI4ZjMiLCJ3ZWJwYWNrOi8vY3JvQ2hlc3MvLi9zcmMvUGllY2UudHM/MmViOCIsIndlYnBhY2s6Ly9jcm9DaGVzcy8uL3NyYy91dGlscy9tb3Zlcy50cz81MGZiIiwid2VicGFjazovL2Nyb0NoZXNzLy4vc3JjL3JhbmtzQW5kRmlsZXMudHM/ZTYyMSIsIndlYnBhY2s6Ly9jcm9DaGVzcy8uL3NyYy9DYXN0bGUudHM/MWNlYSIsIndlYnBhY2s6Ly9jcm9DaGVzcy8uL3NyYy9tb3ZlTm90YXRpb24udHM/NzZlNSIsIndlYnBhY2s6Ly9jcm9DaGVzcy8uL3NyYy9HYW1lYm9hcmQudHM/NTdlMyIsIndlYnBhY2s6Ly9jcm9DaGVzcy8uL3NyYy9IaXN0b3J5LnRzPzRjMjEiLCJ3ZWJwYWNrOi8vY3JvQ2hlc3MvLi9zcmMvc3RhcnRpbmdQb3NpdGlvbnMudHM/M2JiYyIsIndlYnBhY2s6Ly9jcm9DaGVzcy8uL3NyYy9tYWluLnRzP2NkNDkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29vcmQsIFBhcnNlZE5vdGF0aW9uSW50ZXJmYWNlIH0gZnJvbSAnLi4vdHlwZXMvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBQaWVjZUFiYnJldmlhdGlvbiwgU3F1YXJlIH0gZnJvbSAnLi4vdHlwZXMvdHlwZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gdG9YWShzcXVhcmU6IFNxdWFyZSk6IENvb3JkIHtcbiAgY29uc3QgW3gsIHldID0gc3F1YXJlLnNwbGl0KCcnKTtcbiAgcmV0dXJuIHtcbiAgICB4OiBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJywgJ2cnLCAnaCddLmluZGV4T2YoeC50b0xvd2VyQ2FzZSgpKSxcbiAgICB5OiBOdW1iZXIoeSlcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21YWShjb29yZDogQ29vcmQpOiBTcXVhcmUge1xuICBjb25zdCB7IHgsIHkgfSA9IGNvb3JkO1xuICBjb25zdCBjb2wgPSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJywgJ2cnLCAnaCddW3hdO1xuICBpZiAoIWNvbCkgcmV0dXJuICcnO1xuICByZXR1cm4gY29sLmNvbmNhdCh5LnRvU3RyaW5nKCkpO1xufVxuXG5leHBvcnQgY29uc3QgY2FsY0Rpc3RhbmNlID0gKHNxdWFyZU9uZTogc3RyaW5nKSA9PiAoc3F1YXJlVHdvOiBzdHJpbmcpID0+IHtcbiAgY29uc3QgeyB4OiB4MSwgeTogeTEgfSA9IHRvWFkoc3F1YXJlT25lKTtcbiAgY29uc3QgeyB4OiB4MiwgeTogeTIgfSA9IHRvWFkoc3F1YXJlVHdvKTtcblxuICBjb25zdCB4RGlmZiA9IHgxIC0geDI7XG4gIGNvbnN0IHlEaWZmID0geTEgLSB5MjtcbiAgcmV0dXJuIHtcbiAgICB4RGlmZixcbiAgICB5RGlmZlxuICB9O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBpZWNlRnJvbUFiYnIoYWJicjogUGllY2VBYmJyZXZpYXRpb24pIHtcbiAgc3dpdGNoIChhYmJyKSB7XG4gICAgY2FzZSAnSyc6XG4gICAgICByZXR1cm4gJ2tpbmcnO1xuXG4gICAgY2FzZSAnUSc6XG4gICAgICByZXR1cm4gJ3F1ZWVuJztcblxuICAgIGNhc2UgJ04nOlxuICAgICAgcmV0dXJuICdrbmlnaHQnO1xuXG4gICAgY2FzZSAnQic6XG4gICAgICByZXR1cm4gJ2Jpc2hvcCc7XG5cbiAgICBjYXNlICdSJzpcbiAgICAgIHJldHVybiAncm9vayc7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlTm90YXRpb24obm90YXRpb246IHN0cmluZykge1xuICBjb25zdCBtb3ZlID0gPFBhcnNlZE5vdGF0aW9uSW50ZXJmYWNlPnt9O1xuXG4gIGNvbnN0IHJlcGxhY2VkID0gbm90YXRpb24ucmVwbGFjZSgvWyt4I10vLCAnJyk7XG5cbiAgaWYgKCtyZXBsYWNlZFswXSA9PT0gMCkge1xuICAgIC8vIHRoaXMgaXMgY2FzdGxlXG4gICAgbW92ZS5jYXN0bGUgPSByZXBsYWNlZC5sZW5ndGggPT09IDMgPyAna2luZ3NpZGUnIDogJ3F1ZWVuc2lkZSc7XG4gICAgcmV0dXJuIG1vdmU7XG4gIH1cblxuICBpZiAocmVwbGFjZWRbMF0udG9VcHBlckNhc2UoKSA9PT0gcmVwbGFjZWRbMF0pIHtcbiAgICAvLyB0aGlzIGlzIHBpZWNlIG1vdmVcbiAgICBtb3ZlLnBpZWNlVHlwZSA9IGdldFBpZWNlRnJvbUFiYnIocmVwbGFjZWRbMF0gYXMgUGllY2VBYmJyZXZpYXRpb24pO1xuICAgIG1vdmUudG8gPSByZXBsYWNlZC5zbGljZSgtMik7XG5cbiAgICBzd2l0Y2ggKHJlcGxhY2VkLmxlbmd0aCkge1xuICAgICAgY2FzZSA0OlxuICAgICAgICBtb3ZlLmZyb20gPSByZXBsYWNlZFsxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDU6XG4gICAgICAgIG1vdmUuZnJvbSA9IHJlcGxhY2VkLnNsaWNlKDEsIDMpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gbW92ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpcyBhIHBhd24gbW92ZVxuICAgIG1vdmUucGllY2VUeXBlID0gJ3Bhd24nO1xuXG4gICAgaWYgKHJlcGxhY2VkLmluY2x1ZGVzKCc9JykpIHtcbiAgICAgIC8vIGluZGljYXRlcyBwcm9tb3Rpb25cbiAgICAgIG1vdmUucHJvbW90ZSA9IGdldFBpZWNlRnJvbUFiYnIocmVwbGFjZWQuc2xpY2UoLTEpIGFzIFBpZWNlQWJicmV2aWF0aW9uKTtcbiAgICB9XG5cbiAgICBjb25zdCBwcm9tb3RlTm90ZUluZGV4ID0gcmVwbGFjZWQuaW5kZXhPZignPScpO1xuICAgIGNvbnN0IG5vUHJvbW90ZU5vdGF0aW9uID0gcmVwbGFjZWQuc2xpY2UoXG4gICAgICAwLFxuICAgICAgcHJvbW90ZU5vdGVJbmRleCA9PT0gLTEgPyByZXBsYWNlZC5sZW5ndGggOiBwcm9tb3RlTm90ZUluZGV4XG4gICAgKTtcbiAgICBpZiAobm9Qcm9tb3RlTm90YXRpb24ubGVuZ3RoID09PSAzKSB7XG4gICAgICBtb3ZlLmZyb20gPSByZXBsYWNlZFswXTtcbiAgICB9XG4gICAgbW92ZS50byA9IG5vUHJvbW90ZU5vdGF0aW9uLnNsaWNlKC0yKTtcbiAgfVxuXG4gIHJldHVybiBtb3ZlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVlcENvcHkyZEFycmF5KGFycjogc3RyaW5nW11bXSk6IHN0cmluZ1tdW10ge1xuICByZXR1cm4gYXJyLm1hcCgobikgPT4gWy4uLm5dKTtcbn1cbiIsImltcG9ydCBtb3ZlcyBmcm9tICcuL3V0aWxzL21vdmVzJztcbmltcG9ydCB7IHRvWFksIGZyb21YWSB9IGZyb20gJy4vdXRpbHMvaGVscGVycyc7XG5cbmltcG9ydCB7IENvbG9yLCBTcXVhcmUsIFBpZWNlVHlwZSB9IGZyb20gJy4vdHlwZXMvdHlwZXMnO1xuXG5jb25zdCBQaWVjZSA9IChjb2xvcjogQ29sb3IsIHR5cGU6IFBpZWNlVHlwZSkgPT4ge1xuICBmdW5jdGlvbiBoYXNNb3ZlKGZyb206IFNxdWFyZSwgdG86IFNxdWFyZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAna2luZyc6IHtcbiAgICAgICAgY29uc3Qgb25lU3F1YXJlVmVydCA9XG4gICAgICAgICAgbW92ZXMueUJ5TigxKShmcm9tKSh0bykgJiYgbW92ZXMueEJ5TigwKShmcm9tKSh0byk7XG4gICAgICAgIGNvbnN0IG9uZVNxdWFyZUxhdGVyYWwgPVxuICAgICAgICAgIG1vdmVzLnhCeU4oMSkoZnJvbSkodG8pICYmIG1vdmVzLnlCeU4oMCkoZnJvbSkodG8pO1xuICAgICAgICBjb25zdCBvbmVTcXVhcmVEaWFnb25hbGx5ID1cbiAgICAgICAgICBtb3Zlcy55QnlOKDEpKGZyb20pKHRvKSAmJiBtb3Zlcy54QnlOKDEpKGZyb20pKHRvKTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGZyb20gIT09IHRvICYmXG4gICAgICAgICAgKG9uZVNxdWFyZURpYWdvbmFsbHkgfHwgb25lU3F1YXJlVmVydCB8fCBvbmVTcXVhcmVMYXRlcmFsKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2FzZSAncXVlZW4nOiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgZnJvbSAhPT0gdG8gJiZcbiAgICAgICAgICAobW92ZXMuZGlhZ29uYWwoZnJvbSkodG8pIHx8IG1vdmVzLnZlcnRBbmRMYXRlcmFsKGZyb20pKHRvKSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2Jpc2hvcCc6IHtcbiAgICAgICAgcmV0dXJuIGZyb20gIT09IHRvICYmIG1vdmVzLmRpYWdvbmFsKGZyb20pKHRvKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2tuaWdodCc6IHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBmcm9tICE9PSB0byAmJlxuICAgICAgICAgICgobW92ZXMueEJ5TigxKShmcm9tKSh0bykgJiYgbW92ZXMueUJ5TigyKShmcm9tKSh0bykpIHx8XG4gICAgICAgICAgICAobW92ZXMueEJ5TigyKShmcm9tKSh0bykgJiYgbW92ZXMueUJ5TigxKShmcm9tKSh0bykpKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2FzZSAncm9vayc6IHtcbiAgICAgICAgcmV0dXJuIGZyb20gIT09IHRvICYmIG1vdmVzLnZlcnRBbmRMYXRlcmFsKHRvKShmcm9tKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ3Bhd24nOiB7XG4gICAgICAgIGNvbnN0IHsgeDogeDEsIHk6IHkxIH0gPSB0b1hZKGZyb20pO1xuICAgICAgICBjb25zdCB7IHg6IHgyLCB5OiB5MiB9ID0gdG9YWSh0byk7XG5cbiAgICAgICAgY29uc3Qgb25seU1vdmVzSW5Gcm9udCA9IGNvbG9yID09PSAnd2hpdGUnID8geTEgPCB5MiA6IHkxID4geTI7XG4gICAgICAgIGNvbnN0IHJlZ3VsYXJNb3ZlID0gbW92ZXMueUJ5TigxKShmcm9tKSh0bykgJiYgeDEgPT09IHgyO1xuXG4gICAgICAgIGNvbnN0IGZpcnN0TW92ZSA9IGNvbG9yID09PSAnd2hpdGUnID8geTEgPT09IDIgOiB5MSA9PT0gNztcbiAgICAgICAgY29uc3QganVtcFR3byA9IG1vdmVzLnlCeU4oMikoZnJvbSkodG8pICYmIHgxID09PSB4MjtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGZyb20gIT09IHRvICYmXG4gICAgICAgICAgb25seU1vdmVzSW5Gcm9udCAmJlxuICAgICAgICAgIChyZWd1bGFyTW92ZSB8fCAoZmlyc3RNb3ZlICYmIGp1bXBUd28pKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFBhd25DYXB0dXJlcyhvcmlnaW46IFNxdWFyZSkge1xuICAgIGlmICh0eXBlICE9PSAncGF3bicpIHJldHVybjtcblxuICAgIGNvbnN0IHsgeCwgeSB9ID0gdG9YWShvcmlnaW4pO1xuXG4gICAgY29uc3QgbmV3WSA9IGNvbG9yID09PSAnd2hpdGUnID8geSArIDEgOiB5IC0gMTtcblxuICAgIGNvbnN0IGNhcHR1cmVPbmUgPSB7IHg6IHggKyAxLCB5OiBuZXdZIH07XG4gICAgY29uc3QgY2FwdHVyZVR3byA9IHsgeDogeCAtIDEsIHk6IG5ld1kgfTtcblxuICAgIHJldHVybiBbZnJvbVhZKGNhcHR1cmVPbmUpLCBmcm9tWFkoY2FwdHVyZVR3byldO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBoYXNNb3ZlLFxuICAgIGdldFBhd25DYXB0dXJlcyxcbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH0sXG4gICAgZ2V0IGNvbG9yKCkge1xuICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFBpZWNlO1xuIiwiaW1wb3J0IHsgY2FsY0Rpc3RhbmNlLCB0b1hZIH0gZnJvbSAnLi9oZWxwZXJzJztcbmltcG9ydCB7IFNxdWFyZU9iaiwgUGllY2VPYmosIEVuUGFzc2FudE9iaiB9IGZyb20gJy4uL3R5cGVzL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgTW92ZXMsIEJvYXJkLCBTcXVhcmUsIENvbG9yLCBQaWVjZVR5cGUgfSBmcm9tICcuLi90eXBlcy90eXBlcyc7XG5pbXBvcnQgUGllY2UgZnJvbSAnLi4vUGllY2UnO1xuXG5jb25zdCBtb3ZlcyA9IHtcbiAgdmVydEFuZExhdGVyYWw6IChmcm9tOiBTcXVhcmUpID0+ICh0bzogU3F1YXJlKSA9PiB7XG4gICAgY29uc3QgW3gxLCB5MV0gPSBmcm9tLnNwbGl0KCcnKTtcbiAgICBjb25zdCBbeDIsIHkyXSA9IHRvLnNwbGl0KCcnKTtcbiAgICByZXR1cm4geDEgPT09IHgyIHx8IHkxID09PSB5MjtcbiAgfSxcbiAgZGlhZ29uYWw6IChmcm9tOiBTcXVhcmUpID0+ICh0bzogU3F1YXJlKSA9PiB7XG4gICAgY29uc3QgeyB4OiB4MSwgeTogeTEgfSA9IHRvWFkoZnJvbSk7XG4gICAgY29uc3QgeyB4OiB4MiwgeTogeTIgfSA9IHRvWFkodG8pO1xuICAgIHJldHVybiBNYXRoLmFicyh4MiAtIHgxKSA9PT0gTWF0aC5hYnMoeTIgLSB5MSk7XG4gIH0sXG4gIHhCeU46IChudW06IG51bWJlcikgPT4gKGZyb206IFNxdWFyZSkgPT4gKHRvOiBTcXVhcmUpID0+IHtcbiAgICBjb25zdCB7IHg6IHgxIH0gPSB0b1hZKGZyb20pO1xuICAgIGNvbnN0IHsgeDogeDIgfSA9IHRvWFkodG8pO1xuICAgIHJldHVybiBNYXRoLmFicyh4MSAtIHgyKSA9PT0gbnVtO1xuICB9LFxuICB5QnlOOiAobnVtOiBudW1iZXIpID0+IChmcm9tOiBTcXVhcmUpID0+ICh0bzogU3F1YXJlKSA9PiB7XG4gICAgY29uc3QgeyB5OiB5MSB9ID0gdG9YWShmcm9tKTtcbiAgICBjb25zdCB7IHk6IHkyIH0gPSB0b1hZKHRvKTtcbiAgICByZXR1cm4gTWF0aC5hYnMoeTEgLSB5MikgPT09IG51bTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgbW92ZXM7XG5cbi8qIGRlYWxpbmcgd2l0aCBtb3ZlIHZlY3RvcnMgKi9cblxuZnVuY3Rpb24gc3BsaXRJbnRvVmVjdG9ycyhhcnJheU9mTW92ZXM6IE1vdmVzLCBzdGFydDogU3F1YXJlKSB7XG4gIGludGVyZmFjZSBWZWN0b3JzIHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmdbXTtcbiAgfVxuICByZXR1cm4gYXJyYXlPZk1vdmVzLnJlZHVjZSgoYWNjOiBWZWN0b3JzLCBjdXJyOiBTcXVhcmUpID0+IHtcbiAgICBjb25zdCB7IHhEaWZmLCB5RGlmZiB9ID0gY2FsY0Rpc3RhbmNlKHN0YXJ0KShjdXJyKTtcblxuICAgIGxldCB2ZWN0b3IgPSAnJztcbiAgICBpZiAoeURpZmYgIT09IDApIHZlY3RvciA9IHlEaWZmIDwgMCA/ICd1cCcgOiAnZG93bic7XG4gICAgaWYgKHhEaWZmICE9PSAwKSB2ZWN0b3IgKz0geERpZmYgPCAwID8gJ1JpZ2h0JyA6ICdMZWZ0JztcblxuICAgIC8vIG5vcm1hbGl6ZSB2ZWN0b3IgbmFtZVxuICAgIHZlY3RvciA9IHZlY3Rvci5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIHZlY3Rvci5zbGljZSgxKTtcblxuICAgIGFjY1t2ZWN0b3JdID0gYWNjW3ZlY3Rvcl0gfHwgW107XG4gICAgYWNjW3ZlY3Rvcl0ucHVzaChjdXJyKTtcblxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gZ2V0QmVnaW5uaW5nT2ZWZWN0b3IodmVjdG9yOiBNb3Zlcykge1xuICBpZiAodmVjdG9yLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuXG4gIHJldHVybiB2ZWN0b3IucmVkdWNlKChhY2MsIGN1cnIpID0+IHtcbiAgICBjb25zdCB7IHg6IHgxLCB5OiB5MSB9ID0gdG9YWShhY2MpO1xuICAgIGNvbnN0IHsgeDogeDIsIHk6IHkyIH0gPSB0b1hZKGN1cnIpO1xuXG4gICAgY29uc3QgYWNjSXNCZWdpbm5pbmcgPSB4MSA9PT0geDIgPyB5MSA8IHkyIDogeDEgPCB4MjtcbiAgICByZXR1cm4gYWNjSXNCZWdpbm5pbmcgPyBhY2MgOiBjdXJyO1xuICB9KTtcbn1cblxuY29uc3QgZ2V0TW92ZXNBbG9uZ1ZlY3RvciA9IChcbiAgczE6IFNxdWFyZSxcbiAgczI6IFNxdWFyZSxcbiAgYWxsU3F1YXJlczogTW92ZXNcbik6IE1vdmVzID0+IHtcbiAgY29uc3QgbGllc1NhbWVWZXJ0T3JMYXQgPSBtb3Zlcy52ZXJ0QW5kTGF0ZXJhbChzMSkoczIpO1xuICBjb25zdCBsaWVzU2FtZURpYWdvbmFsbHkgPSBtb3Zlcy5kaWFnb25hbChzMSkoczIpO1xuXG4gIGNvbnN0IGxpZXNPblNhbWVMaW5lID0gbGllc1NhbWVWZXJ0T3JMYXQgfHwgbGllc1NhbWVEaWFnb25hbGx5O1xuICBpZiAoIWxpZXNPblNhbWVMaW5lKSByZXR1cm4gW107XG5cbiAgY29uc3QgbWF0Y2hpbmdWZWN0b3IgPSBsaWVzU2FtZURpYWdvbmFsbHkgPyAnZGlhZ29uYWwnIDogJ3ZlcnRBbmRMYXRlcmFsJztcblxuICBjb25zdCBzcXVhcmVzQWxvbmdWZWN0b3IgPSBhbGxTcXVhcmVzLmZpbHRlcihcbiAgICAocykgPT4gbW92ZXNbbWF0Y2hpbmdWZWN0b3JdKHMxKShzKSAmJiBtb3Zlc1ttYXRjaGluZ1ZlY3Rvcl0oczIpKHMpXG4gICk7XG4gIHJldHVybiBzcXVhcmVzQWxvbmdWZWN0b3I7XG59O1xuXG4vKiBzb3J0IG1vdmVzICovXG5cbmNvbnN0IHNvcnRNb3Zlc0Nsb3Nlc3RUbyA9XG4gIChzcXVhcmU6IFNxdWFyZSkgPT5cbiAgKG1vdmVzOiBNb3Zlcyk6IE1vdmVzID0+IHtcbiAgICByZXR1cm4gWy4uLm1vdmVzXS5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBjb25zdCB7IHhEaWZmOiB4MURpZmYsIHlEaWZmOiB5MURpZmYgfSA9IGNhbGNEaXN0YW5jZShzcXVhcmUpKGEpO1xuICAgICAgY29uc3QgYURpZmYgPSBNYXRoLmFicyh4MURpZmYpICsgTWF0aC5hYnMoeTFEaWZmKTtcblxuICAgICAgY29uc3QgeyB4RGlmZjogeDJEaWZmLCB5RGlmZjogeTJEaWZmIH0gPSBjYWxjRGlzdGFuY2Uoc3F1YXJlKShiKTtcbiAgICAgIGNvbnN0IGJEaWZmID0gTWF0aC5hYnMoeDJEaWZmKSArIE1hdGguYWJzKHkyRGlmZik7XG5cbiAgICAgIHJldHVybiBhRGlmZiAtIGJEaWZmO1xuICAgIH0pO1xuICB9O1xuXG4vKiBnZXQgbW92ZXMgKi9cblxuZnVuY3Rpb24gZ2V0UG9zc2libGVNb3ZlcyhvcmlnaW46IFNxdWFyZSwgYm9hcmQ6IEJvYXJkKSB7XG4gIC8vIGdldCBhbGwgbW92ZXMgdGhhdCBjYW4gaGFwcGVuIGlmIG5vIG90aGVyIHBpZWNlcyB3ZXJlIG9uIHRoZSBib2FyZFxuICBjb25zdCBhbGxTcXVhcmVzID0gQXJyYXkuZnJvbShib2FyZC5rZXlzKCkpO1xuXG4gIGNvbnN0IHNxdWFyZSA9IGJvYXJkLmdldChvcmlnaW4pIGFzIFNxdWFyZU9iajtcblxuICBjb25zdCB7IHR5cGUsIGNvbG9yIH0gPSBzcXVhcmUucGllY2UgYXMgUGllY2VPYmo7XG4gIGNvbnN0IHBpZWNlID0gUGllY2UoY29sb3IsIHR5cGUpO1xuXG4gIHJldHVybiBhbGxTcXVhcmVzLmZpbHRlcigocykgPT4gcGllY2UuaGFzTW92ZShvcmlnaW4sIHMpKTtcbn1cblxuZnVuY3Rpb24gZ2V0TGVnYWxNb3ZlcyhvcmlnaW46IFNxdWFyZSwgYm9hcmQ6IEJvYXJkKSB7XG4gIC8vIGdldCBtb3ZlcyByZWdhcmRsZXNzIG9mIHdoZXRoZXIgb3Igbm90IHRoZXJlIGlzIGNoZWNrXG4gIGNvbnN0IHNxdWFyZSA9IGJvYXJkLmdldChvcmlnaW4pIGFzIFNxdWFyZU9iajtcblxuICBjb25zdCBwaWVjZSA9IHNxdWFyZS5waWVjZSBhcyBQaWVjZU9iajtcblxuICBjb25zdCBwb3NzaWJsZU1vdmVzID0gZ2V0UG9zc2libGVNb3ZlcyhvcmlnaW4sIGJvYXJkKTtcblxuICBjb25zdCBvYnN0cnVjdGlvbnMgPSBwb3NzaWJsZU1vdmVzLmZpbHRlcigocykgPT4gYm9hcmQuZ2V0KHMpPy5waWVjZSk7XG4gIGlmICghb2JzdHJ1Y3Rpb25zLmxlbmd0aCkge1xuICAgIHN3aXRjaCAocGllY2UudHlwZSkge1xuICAgICAgY2FzZSAncGF3bic6XG4gICAgICAgIHJldHVybiBbLi4uZ2V0UGF3bkNhcHR1cmVzKG9yaWdpbiwgYm9hcmQpLCAuLi5wb3NzaWJsZU1vdmVzXTtcblxuICAgICAgY2FzZSAna2luZyc6XG4gICAgICAgIHJldHVybiByZW1vdmVQcm90ZWN0ZWRTcXVhcmVzKG9yaWdpbiwgcG9zc2libGVNb3ZlcywgYm9hcmQpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHBvc3NpYmxlTW92ZXM7XG4gICAgfVxuICB9XG5cbiAgbGV0IGxlZ2FsTW92ZXM6IE1vdmVzID0gW107XG4gIHN3aXRjaCAocGllY2UudHlwZSkge1xuICAgIGNhc2UgJ2tuaWdodCc6IHtcbiAgICAgIGxlZ2FsTW92ZXMgPSBwb3NzaWJsZU1vdmVzO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgJ3Bhd24nOiB7XG4gICAgICBjb25zdCBjYXB0dXJlc0F2YWlsYWJsZSA9IGdldFBhd25DYXB0dXJlcyhvcmlnaW4sIGJvYXJkKTtcbiAgICAgIGNvbnN0IHVub2JzdHJ1Y3RlZE1vdmVzID0gcmVtb3ZlTW92ZXNXaXRoUGllY2VzKFxuICAgICAgICByZW1vdmVPYnN0cnVjdGVkTW92ZXMob3JpZ2luLCBwb3NzaWJsZU1vdmVzLCBvYnN0cnVjdGlvbnMpLFxuICAgICAgICBib2FyZFxuICAgICAgKTtcbiAgICAgIGxlZ2FsTW92ZXMgPSBbLi4uY2FwdHVyZXNBdmFpbGFibGUsIC4uLnVub2JzdHJ1Y3RlZE1vdmVzXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlICdraW5nJzoge1xuICAgICAgbGVnYWxNb3ZlcyA9IHJlbW92ZVByb3RlY3RlZFNxdWFyZXMob3JpZ2luLCBwb3NzaWJsZU1vdmVzLCBib2FyZCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgbGVnYWxNb3ZlcyA9IHJlbW92ZU9ic3RydWN0ZWRNb3ZlcyhvcmlnaW4sIHBvc3NpYmxlTW92ZXMsIG9ic3RydWN0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlbW92ZU1vdmVzV2l0aFBpZWNlcyhsZWdhbE1vdmVzLCBib2FyZCwgcGllY2UuY29sb3IpO1xufVxuXG5mdW5jdGlvbiBnZXRMZWdhbE1vdmVzSW5DaGVjayhcbiAgb3JpZ2luOiBTcXVhcmUsXG4gIGJvYXJkOiBCb2FyZCxcbiAga2luZ1BvczogU3F1YXJlLFxuICBzcXVhcmVHaXZpbmdDaGVjazogU3F1YXJlXG4pIHtcbiAgY29uc3Qgc3F1YXJlc1RoYXREZWFsV2l0aENoZWNrID0gZ2V0U3F1YXJlc0JldHdlZW5LaW5nQW5kQ2hlY2soXG4gICAga2luZ1BvcyxcbiAgICBzcXVhcmVHaXZpbmdDaGVjayxcbiAgICBBcnJheS5mcm9tKGJvYXJkLmtleXMoKSlcbiAgKTtcbiAgY29uc3QgbW92ZXMgPSBnZXRMZWdhbE1vdmVzKG9yaWdpbiwgYm9hcmQpO1xuXG4gIHJldHVybiBtb3Zlcy5maWx0ZXIoKHMpID0+IHNxdWFyZXNUaGF0RGVhbFdpdGhDaGVjay5pbmNsdWRlcyhzKSk7XG59XG5cbmZ1bmN0aW9uIGdldEF0dGFja2luZ01vdmVzKG9yaWdpbjogU3F1YXJlLCBib2FyZDogQm9hcmQpOiBNb3ZlcyB7XG4gIGNvbnN0IHNxdWFyZSA9IGJvYXJkLmdldChvcmlnaW4pIGFzIFNxdWFyZU9iajtcblxuICBjb25zdCB7IHR5cGUsIGNvbG9yIH0gPSBzcXVhcmUucGllY2UgYXMgUGllY2VPYmo7XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAncGF3bic6IHtcbiAgICAgIGNvbnN0IHBpZWNlID0gUGllY2UoY29sb3IsICdwYXduJyk7XG4gICAgICByZXR1cm4gcGllY2UuZ2V0UGF3bkNhcHR1cmVzKG9yaWdpbikgYXMgTW92ZXM7XG4gICAgfVxuICAgIGNhc2UgJ2tpbmcnOiB7XG4gICAgICAvLyBuZWVkIHRvIGRvIHRoaXMgYmVjYXVzZSBnZXRMZWdhbE1vdmVzIHdpbGwgcmVjdXJzaXZlbHkgY2FsbCByZW1vdmVQcm90ZWN0ZWRTcXVhcmVzIG90aGVyd2lzZVxuICAgICAgY29uc3QgYXR0YWNraW5nTW92ZXMgPSByZW1vdmVNb3Zlc1dpdGhQaWVjZXMoXG4gICAgICAgIGdldFBvc3NpYmxlTW92ZXMob3JpZ2luLCBib2FyZCksXG4gICAgICAgIGJvYXJkLFxuICAgICAgICBjb2xvclxuICAgICAgKTtcbiAgICAgIHJldHVybiBhdHRhY2tpbmdNb3ZlcztcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBnZXRMZWdhbE1vdmVzKG9yaWdpbiwgYm9hcmQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEFsbE1vdmVzRm9yQ29sb3IoXG4gIGNvbG9yOiBDb2xvcixcbiAgYm9hcmQ6IEJvYXJkLFxuICBza2lwS2luZz86IGJvb2xlYW5cbik6IE1vdmVzIHtcbiAgY29uc3QgYWxsTW92ZXM6IE1vdmVzW10gPSBbXTtcbiAgZm9yIChjb25zdCBbc3F1YXJlLCB7IHBpZWNlIH1dIG9mIGJvYXJkLmVudHJpZXMoKSkge1xuICAgIGlmICghcGllY2UpIGNvbnRpbnVlO1xuICAgIGlmIChwaWVjZS5jb2xvciAhPT0gY29sb3IpIGNvbnRpbnVlO1xuICAgIGlmIChza2lwS2luZyAmJiBwaWVjZS50eXBlID09PSAna2luZycpIGNvbnRpbnVlO1xuXG4gICAgYWxsTW92ZXMucHVzaChnZXRMZWdhbE1vdmVzKHNxdWFyZSwgYm9hcmQpKTtcbiAgfVxuXG4gIHJldHVybiBhbGxNb3Zlcy5mbGF0KCk7XG59XG5cbmZ1bmN0aW9uIGdldEF0dGFja2luZ01vdmVzRm9yQ29sb3IoY29sb3I6IENvbG9yLCBib2FyZDogQm9hcmQpOiBNb3ZlcyB7XG4gIGNvbnN0IGFsbE1vdmVzOiBNb3Zlc1tdID0gW107XG4gIGZvciAoY29uc3QgW3NxdWFyZSwgeyBwaWVjZSB9XSBvZiBib2FyZC5lbnRyaWVzKCkpIHtcbiAgICBpZiAoIXBpZWNlKSBjb250aW51ZTtcbiAgICBpZiAocGllY2UuY29sb3IgIT09IGNvbG9yKSBjb250aW51ZTtcblxuICAgIGFsbE1vdmVzLnB1c2goZ2V0QXR0YWNraW5nTW92ZXMoc3F1YXJlLCBib2FyZCkpO1xuICB9XG5cbiAgcmV0dXJuIGFsbE1vdmVzLmZsYXQoKTtcbn1cblxuZnVuY3Rpb24gZ2V0UGF3bkNhcHR1cmVzKHBhd25TcXVhcmU6IFNxdWFyZSwgYm9hcmQ6IEJvYXJkKSB7XG4gIGNvbnN0IHsgY29sb3IgfSA9IGJvYXJkLmdldChwYXduU3F1YXJlKT8ucGllY2UgYXMgUGllY2VPYmo7XG4gIGNvbnN0IHBhd24gPSBQaWVjZShjb2xvciwgJ3Bhd24nKTtcblxuICBjb25zdCBjYXB0dXJlTW92ZXMgPSBwYXduLmdldFBhd25DYXB0dXJlcyhwYXduU3F1YXJlKTtcbiAgaWYgKCFjYXB0dXJlTW92ZXMpIHJldHVybiBbXTtcblxuICByZXR1cm4gY2FwdHVyZU1vdmVzLmZpbHRlcigocykgPT4ge1xuICAgIGNvbnN0IHNxdWFyZVZhbCA9IGJvYXJkLmdldChzKTtcbiAgICBpZiAoIXNxdWFyZVZhbCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgY29uc3QgcGllY2UgPSBzcXVhcmVWYWwucGllY2U7XG4gICAgY29uc3QgZW5QYXNzYW50OiBFblBhc3NhbnRPYmogfCB1bmRlZmluZWQgPSBzcXVhcmVWYWwuZW5QYXNzYW50O1xuXG4gICAgcmV0dXJuIChcbiAgICAgIChwaWVjZSAmJiBwaWVjZS5jb2xvciAhPT0gcGF3bi5jb2xvcikgfHxcbiAgICAgIChlblBhc3NhbnQgJiYgZW5QYXNzYW50LmNvbG9yICE9PSBwYXduLmNvbG9yKVxuICAgICk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRTcXVhcmVzQmV0d2VlbktpbmdBbmRDaGVjayhcbiAga2luZ1BvczogU3F1YXJlLFxuICBjaGVja1BvczogU3F1YXJlLFxuICBhbGxTcXVhcmVzOiBNb3Zlc1xuKSB7XG4gIC8vIGluY2x1ZGVzIGtpbmdQb3MgYW5kIGNoZWNrUG9zXG4gIGNvbnN0IHNxdWFyZXNBbG9uZ1ZlY3RvciA9IGdldE1vdmVzQWxvbmdWZWN0b3Ioa2luZ1BvcywgY2hlY2tQb3MsIGFsbFNxdWFyZXMpO1xuICBjb25zdCBzcXVhcmVzQmV0d2VlbktpbmdBbmRQaWVjZSA9IHJlbW92ZU1vdmVzQmVoaW5kVHdvU3F1YXJlcyhcbiAgICBraW5nUG9zLFxuICAgIGNoZWNrUG9zLFxuICAgIHNxdWFyZXNBbG9uZ1ZlY3RvclxuICApO1xuICByZXR1cm4gc3F1YXJlc0JldHdlZW5LaW5nQW5kUGllY2U7XG59XG5cbi8qIGZpbHRlciBtb3ZlcyAqL1xuXG5mdW5jdGlvbiByZW1vdmVNb3Zlc0JlaGluZFR3b1NxdWFyZXMoXG4gIHMxOiBTcXVhcmUsXG4gIHMyOiBTcXVhcmUsXG4gIHZlY3RvcjogTW92ZXNcbik6IE1vdmVzIHtcbiAgY29uc3Qgc29ydGVkID0gc29ydE1vdmVzQ2xvc2VzdFRvKGdldEJlZ2lubmluZ09mVmVjdG9yKHZlY3RvcikpKHZlY3Rvcik7XG4gIGxldCBmdXJ0aGVzdFNxdWFyZTtcbiAgbGV0IGNsb3Nlc3RTcXVhcmU7XG5cbiAgaWYgKHNvcnRlZC5pbmRleE9mKHMxKSA+IHNvcnRlZC5pbmRleE9mKHMyKSkge1xuICAgIGZ1cnRoZXN0U3F1YXJlID0gczE7XG4gICAgY2xvc2VzdFNxdWFyZSA9IHMyO1xuICB9IGVsc2Uge1xuICAgIGZ1cnRoZXN0U3F1YXJlID0gczI7XG4gICAgY2xvc2VzdFNxdWFyZSA9IHMxO1xuICB9XG4gIGNvbnN0IHJlbW92ZWRPbmVFbmQgPSByZW1vdmVNb3Zlc0JlaGluZFNxdWFyZShmdXJ0aGVzdFNxdWFyZSkoc29ydGVkKTtcbiAgY29uc3QgcmVtb3ZlZEJvdGhFbmRzID0gcmVtb3ZlTW92ZXNCZWhpbmRTcXVhcmUoY2xvc2VzdFNxdWFyZSkoXG4gICAgcmVtb3ZlZE9uZUVuZC5yZXZlcnNlKClcbiAgKTtcblxuICByZXR1cm4gcmVtb3ZlZEJvdGhFbmRzO1xufVxuXG5jb25zdCByZW1vdmVNb3Zlc0JlaGluZFNxdWFyZSA9XG4gIChzcXVhcmU6IFNxdWFyZSkgPT5cbiAgKG1vdmVzOiBNb3Zlcyk6IE1vdmVzID0+IHtcbiAgICBjb25zdCBjb3B5ID0gWy4uLm1vdmVzXTtcbiAgICBjb25zdCBpbmRleCA9IG1vdmVzLmluZGV4T2Yoc3F1YXJlKTtcblxuICAgIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiBbXTtcblxuICAgIGNvcHkuc3BsaWNlKGluZGV4ICsgMSk7XG5cbiAgICByZXR1cm4gY29weTtcbiAgfTtcblxuZnVuY3Rpb24gcmVtb3ZlT2JzdHJ1Y3RlZE1vdmVzKFxuICBzdGFydGluZ1NxdWFyZTogU3F1YXJlLFxuICBwb3NzaWJsZU1vdmVzOiBNb3ZlcyxcbiAgb2JzdHJ1Y3Rpb25zOiBNb3Zlc1xuKTogTW92ZXMge1xuICAvLyBhKSBzcGxpdCBwb3NzaWJsZSBtb3ZlcyBpbnRvIHZlY3RvcnMgKHVwLGRvd24sbGVmdCxyaWdodCwgYW5kL29yIGRpYWdvbmFscylcbiAgLy8gYikgc2VlIHdoaWNoIG9ic3RydWN0aW9ucyBiZWxvbmcgdG8gd2hpY2ggdmVjdG9yXG4gIC8vIGMpIGZpbmQgdGhlIGNsb3Nlc3Qgb2JzdHJ1Y3Rpb25cbiAgLy8gZCkgcmVtb3ZlIGFsbCB0aGUgbW92ZXMgYmVoaW5kIHRoYXQgb2JzdHJ1Y3Rpb25cblxuICBjb25zdCBmaWx0ZXJlZE1vdmVzOiBNb3Zlc1tdID0gW107XG5cbiAgY29uc3QgYWxsVmVjdG9ycyA9IHNwbGl0SW50b1ZlY3RvcnMocG9zc2libGVNb3Zlcywgc3RhcnRpbmdTcXVhcmUpO1xuICBjb25zdCBvYnN0cnVjdGlvblZlY3RvcnMgPSBzcGxpdEludG9WZWN0b3JzKG9ic3RydWN0aW9ucywgc3RhcnRpbmdTcXVhcmUpO1xuICBmb3IgKGNvbnN0IHZlY3RvciBpbiBhbGxWZWN0b3JzKSB7XG4gICAgaWYgKCFvYnN0cnVjdGlvblZlY3RvcnNbdmVjdG9yXSkge1xuICAgICAgLy8gbG9vayBmb3IgdmVjdG9yIG9ic3RydWN0aW9uIGlzIG9uXG4gICAgICBmaWx0ZXJlZE1vdmVzLnB1c2goYWxsVmVjdG9yc1t2ZWN0b3JdKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHNvcnRlZCA9IHNvcnRNb3Zlc0Nsb3Nlc3RUbyhzdGFydGluZ1NxdWFyZSkoYWxsVmVjdG9yc1t2ZWN0b3JdKTtcbiAgICBjb25zdCBjbG9zZXN0T2JzdHJ1Y3Rpb24gPSBzb3J0TW92ZXNDbG9zZXN0VG8oc3RhcnRpbmdTcXVhcmUpKFxuICAgICAgb2JzdHJ1Y3Rpb25WZWN0b3JzW3ZlY3Rvcl1cbiAgICApWzBdO1xuXG4gICAgZmlsdGVyZWRNb3Zlcy5wdXNoKHJlbW92ZU1vdmVzQmVoaW5kU3F1YXJlKGNsb3Nlc3RPYnN0cnVjdGlvbikoc29ydGVkKSk7XG4gIH1cblxuICByZXR1cm4gZmlsdGVyZWRNb3Zlcy5mbGF0KCk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVByb3RlY3RlZFNxdWFyZXMoXG4gIGtpbmdQb3M6IFNxdWFyZSxcbiAgcG9zc2libGVNb3ZlczogTW92ZXMsXG4gIGJvYXJkOiBCb2FyZFxuKTogTW92ZXMge1xuICBjb25zdCBraW5nID0gYm9hcmQuZ2V0KGtpbmdQb3MpPy5waWVjZSBhcyBQaWVjZU9iajtcbiAgY29uc3Qgb3BwQ29sb3IgPSBraW5nLmNvbG9yID09PSAnd2hpdGUnID8gJ2JsYWNrJyA6ICd3aGl0ZSc7XG5cbiAgY29uc3QgZW5lbXlQaWVjZXNJblZpY2luaXR5OiBTcXVhcmVbXSA9IHBvc3NpYmxlTW92ZXMuZmlsdGVyKFxuICAgIChzKSA9PiBib2FyZC5nZXQocyk/LnBpZWNlPy5jb2xvciA9PT0gb3BwQ29sb3JcbiAgKTtcbiAgY29uc3Qgc3F1YXJlc1Byb3RlY3RlZEJ5RW5lbXlJblZpY2luaXR5OiBTcXVhcmVbXSA9IGVuZW15UGllY2VzSW5WaWNpbml0eVxuICAgIC5tYXAoKHMpID0+IGdldEF0dGFja2luZ01vdmVzKHMsIGJvYXJkKSlcbiAgICAuZmxhdCgpO1xuICAvLyBiYyBraW5nIGNhbnQgbW92ZSBpZiBzcXVhcmUgaXMgcHJvdGVjdGVkXG4gIC8vIHNldCBraW5nIHBpZWNlIG9uIGVhY2ggc3F1YXJlIGluIHBvc3NpYmxlIG1vdmVzIHRvIGZpbmQgd2hpY2ggc3F1YXJlcyBhcmUgcHJvdGVjdGVkXG4gIGNvbnN0IGJvYXJkQ29weSA9IG5ldyBNYXAoYm9hcmQpO1xuICBwb3NzaWJsZU1vdmVzLmZvckVhY2goKHMpID0+IGJvYXJkQ29weS5zZXQocywgeyBwaWVjZToga2luZyB9KSk7XG5cbiAgY29uc3Qgc3F1YXJlc1Byb3RlY3RlZEJ5UmFuZ2UgPSBnZXRBdHRhY2tpbmdNb3Zlc0ZvckNvbG9yKFxuICAgIG9wcENvbG9yLFxuICAgIGJvYXJkQ29weVxuICApO1xuICByZXR1cm4gcG9zc2libGVNb3Zlcy5maWx0ZXIoKHMpID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgIXNxdWFyZXNQcm90ZWN0ZWRCeVJhbmdlLmluY2x1ZGVzKHMpICYmXG4gICAgICAhc3F1YXJlc1Byb3RlY3RlZEJ5RW5lbXlJblZpY2luaXR5LmluY2x1ZGVzKHMpXG4gICAgKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU1vdmVzV2l0aFBpZWNlcyhcbiAgbW92ZXM6IE1vdmVzLFxuICBib2FyZDogQm9hcmQsXG4gIGNvbG9yPzogQ29sb3Jcbik6IE1vdmVzIHtcbiAgcmV0dXJuIG1vdmVzLmZpbHRlcigocykgPT4ge1xuICAgIGNvbnN0IHNxdWFyZVZhbCA9IGJvYXJkLmdldChzKTtcbiAgICBpZiAoIXNxdWFyZVZhbCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKGNvbG9yKSByZXR1cm4gIXNxdWFyZVZhbC5waWVjZSB8fCBzcXVhcmVWYWwucGllY2UuY29sb3IgIT09IGNvbG9yO1xuICAgIGVsc2UgcmV0dXJuICFzcXVhcmVWYWwucGllY2U7XG4gIH0pO1xufVxuXG4vKiBnYW1lYm9hcmQgY2hlY2tzICovXG5cbmZ1bmN0aW9uIGdldERpc2NvdmVyZWRDaGVjayhcbiAga2luZ1BvczogU3F1YXJlLFxuICBraW5nQ29sb3I6IENvbG9yLFxuICB2YWNhdGVkOiBTcXVhcmUsXG4gIGJvYXJkOiBCb2FyZFxuKTogU3F1YXJlIHtcbiAgLy8gb3BlblNxdWFyZSBpcyBhIHNxdWFyZSBqdXN0IHZhY2F0ZWRcbiAgbGV0IHNxdWFyZXNBbG9uZ1ZlY3RvciA9IGdldE1vdmVzQWxvbmdWZWN0b3IoXG4gICAga2luZ1BvcyxcbiAgICB2YWNhdGVkLFxuICAgIEFycmF5LmZyb20oYm9hcmQua2V5cygpKVxuICApO1xuICBzcXVhcmVzQWxvbmdWZWN0b3IgPSBzcXVhcmVzQWxvbmdWZWN0b3IuZmlsdGVyKFxuICAgIChzKSA9PiBzICE9PSBraW5nUG9zICYmIHMgIT09IHZhY2F0ZWRcbiAgKTtcbiAgaWYgKCFzcXVhcmVzQWxvbmdWZWN0b3IubGVuZ3RoKSByZXR1cm4gJyc7XG5cbiAgZm9yIChjb25zdCBzcXVhcmUgb2Ygc3F1YXJlc0Fsb25nVmVjdG9yKSB7XG4gICAgY29uc3QgcGllY2UgPSBib2FyZC5nZXQoc3F1YXJlKT8ucGllY2U7XG4gICAgaWYgKCFwaWVjZSB8fCBwaWVjZS5jb2xvciA9PT0ga2luZ0NvbG9yKSBjb250aW51ZTtcblxuICAgIGNvbnN0IGxlZ2FsTW92ZXMgPSBnZXRMZWdhbE1vdmVzKHNxdWFyZSwgYm9hcmQpO1xuICAgIGlmIChsZWdhbE1vdmVzLmluY2x1ZGVzKGtpbmdQb3MpKSByZXR1cm4gc3F1YXJlO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBjYW5CbG9ja09yQ2FwdHVyZUNoZWNrKFxuICBraW5nUG9zOiBTcXVhcmUsXG4gIHNxdWFyZUdpdmluZ0NoZWNrOiBTcXVhcmUsXG4gIGJvYXJkOiBCb2FyZFxuKTogYm9vbGVhbiB7XG4gIGNvbnN0IGtpbmcgPSBib2FyZC5nZXQoa2luZ1Bvcyk/LnBpZWNlIGFzIFBpZWNlT2JqO1xuXG4gIGNvbnN0IGJsb2NrT3JDYXB0dXJlU3F1YXJlcyA9IGdldFNxdWFyZXNCZXR3ZWVuS2luZ0FuZENoZWNrKFxuICAgIGtpbmdQb3MsXG4gICAgc3F1YXJlR2l2aW5nQ2hlY2ssXG4gICAgQXJyYXkuZnJvbShib2FyZC5rZXlzKCkpXG4gICk7IC8vIGFsc28gaW5jbHVkZXMgY2hlY2sgc3F1YXJlXG5cbiAgY29uc3Qgb3duUGllY2VNb3ZlcyA9IGdldEFsbE1vdmVzRm9yQ29sb3Ioa2luZy5jb2xvciwgYm9hcmQsIHRydWUpO1xuICByZXR1cm4gb3duUGllY2VNb3Zlcy5zb21lKChtb3ZlKSA9PiBibG9ja09yQ2FwdHVyZVNxdWFyZXMuaW5jbHVkZXMobW92ZSkpO1xufVxuXG5mdW5jdGlvbiBnZXRQaWVjZXNXaXRoTW92ZShcbiAgYm9hcmQ6IEJvYXJkLFxuICBtb3ZlOiBTcXVhcmUsXG4gIHBpZWNlVHlwZTogUGllY2VUeXBlLFxuICBjb2xvcjogJ2JsYWNrJyB8ICd3aGl0ZSdcbikge1xuICBjb25zdCBwaWVjZVNxdWFyZXM6IE1vdmVzID0gW107XG4gIGZvciAoY29uc3QgW3NxdWFyZSwgeyBwaWVjZSB9XSBvZiBib2FyZC5lbnRyaWVzKCkpIHtcbiAgICBpZiAoIXBpZWNlKSBjb250aW51ZTtcbiAgICBpZiAocGllY2UuY29sb3IgIT09IGNvbG9yKSBjb250aW51ZTtcbiAgICBpZiAocGllY2UudHlwZSAhPT0gcGllY2VUeXBlKSBjb250aW51ZTtcbiAgfVxufVxuXG5leHBvcnQge1xuICBnZXRBdHRhY2tpbmdNb3Zlc0ZvckNvbG9yLFxuICBnZXRMZWdhbE1vdmVzLFxuICBnZXRMZWdhbE1vdmVzSW5DaGVjayxcbiAgZ2V0RGlzY292ZXJlZENoZWNrLFxuICBjYW5CbG9ja09yQ2FwdHVyZUNoZWNrXG59O1xuIiwiY29uc3QgZmlsZXMgPSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJywgJ2cnLCAnaCddO1xuY29uc3QgcmFua3MgPSBbMSwgMiwgMywgNCwgNSwgNiwgNywgOF07XG5cbmV4cG9ydCB7IGZpbGVzLCByYW5rcyB9O1xuIiwiaW1wb3J0IHsgQ2FzdGxlT2JqIH0gZnJvbSAnLi90eXBlcy9pbnRlcmZhY2VzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ2FzdGxlKFxuICB3aGl0ZUtpbmdzaWRlOiBib29sZWFuLFxuICB3aGl0ZVF1ZWVuc2lkZTogYm9vbGVhbixcbiAgYmxhY2tLaW5nc2lkZTogYm9vbGVhbixcbiAgYmxhY2tRdWVlbnNpZGU6IGJvb2xlYW5cbik6IENhc3RsZU9iaiB7XG4gIHJldHVybiB7XG4gICAgd2hpdGU6IHtcbiAgICAgIGtpbmdzaWRlOiB3aGl0ZUtpbmdzaWRlLFxuICAgICAgcXVlZW5zaWRlOiB3aGl0ZVF1ZWVuc2lkZVxuICAgIH0sXG4gICAgYmxhY2s6IHtcbiAgICAgIGtpbmdzaWRlOiBibGFja0tpbmdzaWRlLFxuICAgICAgcXVlZW5zaWRlOiBibGFja1F1ZWVuc2lkZVxuICAgIH1cbiAgfTtcbn1cbiIsImltcG9ydCB7IE1vdmVEZXRhaWxzSW50ZXJmYWNlIH0gZnJvbSAnLi90eXBlcy9pbnRlcmZhY2VzJztcbmltcG9ydCB7IFBpZWNlVHlwZSB9IGZyb20gJy4vdHlwZXMvdHlwZXMnO1xuXG5jb25zdCBtb3ZlTm90YXRpb24gPSAobm90YXRpb246IHN0cmluZykgPT4ge1xuICBmdW5jdGlvbiBjYXN0bGUoc2lkZTogJ2tpbmdzaWRlJyB8ICdxdWVlbnNpZGUnKSB7XG4gICAgbm90YXRpb24gPSBzaWRlID09PSAna2luZ3NpZGUnID8gJzAtMCcgOiAnMC0wLTAnO1xuICAgIHJldHVybiBub3RhdGlvbjtcbiAgfVxuXG4gIGNvbnN0IGFmZml4ID0ge1xuICAgIHBpZWNlTm90YXRpb246IChwaWVjZVR5cGU6IFBpZWNlVHlwZSwgZGlmZmVyZW50aWF0aW9uPzogc3RyaW5nKSA9PiB7XG4gICAgICBkaWZmZXJlbnRpYXRpb24gPSBkaWZmZXJlbnRpYXRpb24gfHwgJyc7XG5cbiAgICAgIHN3aXRjaCAocGllY2VUeXBlKSB7XG4gICAgICAgIGNhc2UgJ3Bhd24nOiB7XG4gICAgICAgICAgbm90YXRpb24gPSBkaWZmZXJlbnRpYXRpb24gKyBub3RhdGlvbjtcbiAgICAgICAgICByZXR1cm4gbm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAna2luZyc6IHtcbiAgICAgICAgICBub3RhdGlvbiA9ICdLJyArIG5vdGF0aW9uO1xuICAgICAgICAgIHJldHVybiBub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdrbmlnaHQnOiB7XG4gICAgICAgICAgbm90YXRpb24gPSAnTicgKyBkaWZmZXJlbnRpYXRpb24gKyBub3RhdGlvbjtcbiAgICAgICAgICByZXR1cm4gbm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIG5vdGF0aW9uID0gcGllY2VUeXBlWzBdLnRvVXBwZXJDYXNlKCkgKyBkaWZmZXJlbnRpYXRpb24gKyBub3RhdGlvbjtcbiAgICAgICAgICByZXR1cm4gbm90YXRpb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNhcHR1cmU6ICgpID0+IHtcbiAgICAgIG5vdGF0aW9uID0gYHgke25vdGF0aW9ufWA7XG4gICAgICByZXR1cm4gbm90YXRpb247XG4gICAgfSxcbiAgICBwcm9tb3RlOiAocGllY2VUeXBlOiBQaWVjZVR5cGUpID0+IHtcbiAgICAgIGNvbnN0IHN1ZmZpeCA9XG4gICAgICAgICc9JyArIHBpZWNlVHlwZSA9PT0gJ2tuaWdodCcgPyAnTicgOiBwaWVjZVR5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCk7XG4gICAgICBub3RhdGlvbiArPSAnPScgKyBzdWZmaXg7XG4gICAgICByZXR1cm4gbm90YXRpb247XG4gICAgfSxcbiAgICBjaGVjazogKCkgPT4ge1xuICAgICAgbm90YXRpb24gKz0gJysnO1xuICAgICAgcmV0dXJuIG5vdGF0aW9uO1xuICAgIH0sXG4gICAgY2hlY2ttYXRlOiAoKSA9PiB7XG4gICAgICBub3RhdGlvbiArPSAnIyc7XG4gICAgICByZXR1cm4gbm90YXRpb247XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGdldChtb3ZlRGV0YWlsczogTW92ZURldGFpbHNJbnRlcmZhY2UpIHtcbiAgICBjb25zdCB7XG4gICAgICBjYXB0dXJlLFxuICAgICAgY2FzdGxlOiBjYXN0bGVTaWRlLFxuICAgICAgcHJvbW90ZSxcbiAgICAgIGNoZWNrLFxuICAgICAgY2hlY2ttYXRlLFxuICAgICAgcGllY2VUeXBlLFxuICAgICAgZGlmZmVyZW50aWF0aW9uXG4gICAgfSA9IG1vdmVEZXRhaWxzO1xuXG4gICAgaWYgKGNhc3RsZVNpZGUpIHJldHVybiBjYXN0bGUoY2FzdGxlU2lkZSk7XG5cbiAgICBpZiAoY2FwdHVyZSkgYWZmaXguY2FwdHVyZSgpO1xuICAgIGFmZml4LnBpZWNlTm90YXRpb24ocGllY2VUeXBlIGFzIFBpZWNlVHlwZSwgZGlmZmVyZW50aWF0aW9uKTtcbiAgICBpZiAocHJvbW90ZSkgYWZmaXgucHJvbW90ZShwcm9tb3RlKTtcblxuICAgIGlmIChjaGVja21hdGUpIGFmZml4LmNoZWNrbWF0ZSgpO1xuICAgIGVsc2UgaWYgKGNoZWNrKSBhZmZpeC5jaGVjaygpO1xuXG4gICAgcmV0dXJuIG5vdGF0aW9uO1xuICB9XG4gIHJldHVybiB7XG4gICAgZ2V0XG4gIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBtb3ZlTm90YXRpb247XG4iLCJpbXBvcnQge1xuICBnZXRMZWdhbE1vdmVzLFxuICBnZXREaXNjb3ZlcmVkQ2hlY2ssXG4gIGNhbkJsb2NrT3JDYXB0dXJlQ2hlY2ssXG4gIGdldEF0dGFja2luZ01vdmVzRm9yQ29sb3IsXG4gIGdldExlZ2FsTW92ZXNJbkNoZWNrXG59IGZyb20gJy4vdXRpbHMvbW92ZXMnO1xuaW1wb3J0IHsgdG9YWSwgZnJvbVhZLCBwYXJzZU5vdGF0aW9uIH0gZnJvbSAnLi91dGlscy9oZWxwZXJzJztcbmltcG9ydCB7IHJhbmtzLCBmaWxlcyB9IGZyb20gJy4vcmFua3NBbmRGaWxlcyc7XG5pbXBvcnQge1xuICBDb2xvcixcbiAgU3F1YXJlLFxuICBCb2FyZCxcbiAgUGllY2VUeXBlLFxuICBNb3ZlcyxcbiAgQ2FzdGxlU3F1YXJlc1R5cGUsXG4gIEhpc3RvcnlUeXBlXG59IGZyb20gJy4vdHlwZXMvdHlwZXMnO1xuaW1wb3J0IHtcbiAgQWxsUGllY2VNYXAsXG4gIENhc3RsZU9iaixcbiAgRW5QYXNzYW50T2JqLFxuICBHYW1lYm9hcmRPYmosXG4gIE1vdmVEZXRhaWxzSW50ZXJmYWNlLFxuICBQaWVjZU1hcCxcbiAgUGllY2VPYmpcbn0gZnJvbSAnLi90eXBlcy9pbnRlcmZhY2VzJztcbmltcG9ydCBDYXN0bGUgZnJvbSAnLi9DYXN0bGUnO1xuaW1wb3J0IHsgc3RhcnRpbmdQb3NpdGlvbnMgfSBmcm9tICcuL21haW4nO1xuaW1wb3J0IG1vdmVOb3RhdGlvbiBmcm9tICcuL21vdmVOb3RhdGlvbic7XG5pbXBvcnQgUGllY2UgZnJvbSAnLi9QaWVjZSc7XG5cbmZ1bmN0aW9uIGNyZWF0ZUJvYXJkKCk6IEJvYXJkIHtcbiAgcmV0dXJuIGZpbGVzLnJlZHVjZSgoYWNjLCBmaWxlKSA9PiB7XG4gICAgcmFua3MuZm9yRWFjaCgocmFuaykgPT4ge1xuICAgICAgY29uc3Qgc3F1YXJlID0gZmlsZS5jb25jYXQocmFuay50b1N0cmluZygpKTtcbiAgICAgIGFjYy5zZXQoc3F1YXJlLCB7IHBpZWNlOiBudWxsIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIG5ldyBNYXAoKSk7XG59XG5cbmNvbnN0IEdhbWVib2FyZCA9IChcbiAgYm9hcmQgPSBjcmVhdGVCb2FyZCgpLFxuICBzcXVhcmVzR2l2aW5nQ2hlY2s/OiBNb3ZlcyxcbiAgQ2FzdGxlUmlnaHRzPzogQ2FzdGxlT2JqXG4pOiBHYW1lYm9hcmRPYmogPT4ge1xuICBib2FyZCA9IG5ldyBNYXAoYm9hcmQpO1xuXG4gIGZ1bmN0aW9uIHBsYWNlUGllY2VzKHBpZWNlTWFwOiBBbGxQaWVjZU1hcCwgYm9hcmRNYXAgPSBib2FyZCkge1xuICAgIGxldCBjb2xvcjoga2V5b2YgdHlwZW9mIHBpZWNlTWFwO1xuICAgIGZvciAoY29sb3IgaW4gcGllY2VNYXApIHtcbiAgICAgIGNvbnN0IG1hcCA9IHBpZWNlTWFwW2NvbG9yXTtcblxuICAgICAgbGV0IHBpZWNlVHlwZToga2V5b2YgdHlwZW9mIG1hcDtcbiAgICAgIGZvciAocGllY2VUeXBlIGluIG1hcCkge1xuICAgICAgICBjb25zdCBzcXVhcmVzID0gbWFwW3BpZWNlVHlwZV07XG4gICAgICAgIHNxdWFyZXMuZm9yRWFjaCgocykgPT5cbiAgICAgICAgICBhdChzLCBib2FyZE1hcCkucGxhY2UoeyB0eXBlOiBwaWVjZVR5cGUsIGNvbG9yOiBjb2xvciB9KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VNb3ZlKFxuICAgIHMxOiBTcXVhcmUsXG4gICAgczI6IFNxdWFyZSxcbiAgICBwcm9tb3RlPzogUGllY2VUeXBlXG4gICk6IEJvYXJkIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBwaWVjZSA9IGF0KHMxKS5waWVjZTtcblxuICAgIC8vIHZhbGlkYXRlIG1vdmVcbiAgICBpZiAoIXBpZWNlKSByZXR1cm47XG4gICAgaWYgKCF2YWxpZGF0ZS5tb3ZlKHMxLCBzMikpIHJldHVybjtcbiAgICBpZiAocHJvbW90ZSAmJiAhdmFsaWRhdGUucHJvbW90aW9uKHMxLCBzMikpIHJldHVybjtcblxuICAgIHN3aXRjaCAocGllY2UudHlwZSkge1xuICAgICAgY2FzZSAncGF3bic6IHtcbiAgICAgICAgaWYgKHByb21vdGUpIHtcbiAgICAgICAgICBhdChzMSkucHJvbW90ZShwcm9tb3RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlblBhc3NhbnQuaXNDYXB0dXJlKHMxLCBzMikpIHtcbiAgICAgICAgICBlblBhc3NhbnQuY2FwdHVyZShzMik7XG4gICAgICAgIH1cblxuICAgICAgICBlblBhc3NhbnQucmVtb3ZlKCk7XG4gICAgICAgIGlmIChlblBhc3NhbnQuY2hlY2tUb2dnbGUoczEsIHMyKSkge1xuICAgICAgICAgIGVuUGFzc2FudC50b2dnbGUocGllY2UuY29sb3IsIHMyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZyb20oczEpLnRvKHMyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgJ2tpbmcnOiB7XG4gICAgICAgIC8vIGNoZWNrIGlmIG1vdmUgaXMgY2FzdGxlXG4gICAgICAgIGNvbnN0IGNhc3RsZVNpZGUgPSBnZXQuY2FzdGxlU2lkZShwaWVjZS5jb2xvciwgczIpO1xuICAgICAgICBpZiAoY2FzdGxlU2lkZSkgY2FzdGxlKHBpZWNlLmNvbG9yLCBjYXN0bGVTaWRlKTtcbiAgICAgICAgZWxzZSBmcm9tKHMxKS50byhzMik7XG5cbiAgICAgICAgZW5QYXNzYW50LnJlbW92ZSgpO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBmcm9tKHMxKS50byhzMik7XG4gICAgICAgIGVuUGFzc2FudC5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYm9hcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBjYXN0bGUoXG4gICAgY29sb3I6IENvbG9yLFxuICAgIHNpZGU6ICdraW5nc2lkZScgfCAncXVlZW5zaWRlJyxcbiAgICBib2FyZE1hcCA9IGJvYXJkXG4gICk6IHZvaWQge1xuICAgIGNvbnN0IGNhc3RsZVNxdWFyZXMgPSBnZXQuY2FzdGxlU3F1YXJlcyhjb2xvcilbc2lkZV07XG5cbiAgICBjb25zdCBraW5nUG9zID0gZ2V0LmtpbmdQb3NpdGlvbihjb2xvciwgYm9hcmRNYXApIGFzIFNxdWFyZTtcbiAgICBjb25zdCByb29rUG9zID0gZ2V0Um9va1BvcygpIGFzIFNxdWFyZTtcblxuICAgIGZyb20ocm9va1BvcywgYm9hcmRNYXApLnRvKGNhc3RsZVNxdWFyZXNbMF0pO1xuICAgIGZyb20oa2luZ1BvcywgYm9hcmRNYXApLnRvKGNhc3RsZVNxdWFyZXNbMV0pO1xuXG4gICAgZnVuY3Rpb24gZ2V0Um9va1BvcygpIHtcbiAgICAgIGNvbnN0IHBpZWNlTWFwID0gZ2V0LnBpZWNlTWFwKGJvYXJkTWFwKTtcbiAgICAgIGNvbnN0IHJvb2tQb3MgPSBwaWVjZU1hcFtjb2xvcl0ucm9vay5maW5kKChzcXVhcmUpID0+IHtcbiAgICAgICAgY29uc3QgZmlsZSA9IHNxdWFyZS5zcGxpdCgnJylbMF07XG4gICAgICAgIHJldHVybiBzaWRlID09PSAna2luZ3NpZGUnXG4gICAgICAgICAgPyBmaWxlcy5pbmRleE9mKGZpbGUpID4gM1xuICAgICAgICAgIDogZmlsZXMuaW5kZXhPZihmaWxlKSA8IDM7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHJvb2tQb3M7XG4gICAgfVxuICAgIC8vIG5lZWQgdG8gZ2V0IGtpbmcgcG9zaXRpb25cbiAgICAvLyBuZWVkIHRvIGdldCBjYXN0bGUgc3F1YXJlc1xuICAgIC8vIG5lZWQgdG8gZmluZCByb29rXG4gIH1cblxuICBjb25zdCBlblBhc3NhbnQgPSAoKCkgPT4ge1xuICAgIGZ1bmN0aW9uIGdldFNxdWFyZShjdXJyZW50OiBTcXVhcmUsIGNvbG9yOiBDb2xvcik6IFNxdWFyZSB7XG4gICAgICBjb25zdCB7IHgsIHkgfSA9IHRvWFkoY3VycmVudCk7XG4gICAgICBjb25zdCBuZXdZID0gY29sb3IgPT09ICd3aGl0ZScgPyB5IC0gMSA6IHkgKyAxO1xuICAgICAgcmV0dXJuIGZyb21YWSh7IHgsIHk6IG5ld1kgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNoZWNrVG9nZ2xlOiAoZnJvbTogU3F1YXJlLCB0bzogU3F1YXJlKTogYm9vbGVhbiA9PiB7XG4gICAgICAgIGNvbnN0IHsgeTogeTEgfSA9IHRvWFkoZnJvbSk7XG4gICAgICAgIGNvbnN0IHsgeTogeTIgfSA9IHRvWFkodG8pO1xuXG4gICAgICAgIHJldHVybiBNYXRoLmFicyh5MSAtIHkyKSA9PT0gMjtcbiAgICAgIH0sXG4gICAgICB0b2dnbGU6IChjb2xvcjogQ29sb3IsIGN1cnJlbnQ6IFNxdWFyZSwgYm9hcmRNYXAgPSBib2FyZCk6IHZvaWQgPT4ge1xuICAgICAgICBjb25zdCBlblBhc3NhbnRTcXVhcmUgPSBnZXRTcXVhcmUoY3VycmVudCwgY29sb3IpO1xuICAgICAgICBhdChlblBhc3NhbnRTcXVhcmUsIGJvYXJkTWFwKS5zZXRFblBhc3NhbnQoY29sb3IsIGN1cnJlbnQpO1xuICAgICAgfSxcbiAgICAgIHJlbW92ZTogKGJvYXJkTWFwID0gYm9hcmQpOiB2b2lkID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBzcXVhcmVPYmogb2YgYm9hcmRNYXAudmFsdWVzKCkpIHtcbiAgICAgICAgICBpZiAoc3F1YXJlT2JqLmVuUGFzc2FudCkgcmV0dXJuIChzcXVhcmVPYmouZW5QYXNzYW50ID0gdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGlzQ2FwdHVyZTogKGZyb206IFNxdWFyZSwgdG86IFNxdWFyZSwgYm9hcmRNYXAgPSBib2FyZCk6IGJvb2xlYW4gPT4ge1xuICAgICAgICBjb25zdCBwaWVjZSA9IGF0KGZyb20sIGJvYXJkTWFwKS5waWVjZTtcbiAgICAgICAgY29uc3QgZW5QYXNzYW50ID0gYm9hcmRNYXAuZ2V0KHRvKT8uZW5QYXNzYW50O1xuICAgICAgICBpZiAoIXBpZWNlIHx8IHBpZWNlLnR5cGUgIT09ICdwYXduJykgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWVuUGFzc2FudCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZW5QYXNzYW50LmNvbG9yID09PSBwaWVjZS5jb2xvcikgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICBjYXB0dXJlOiAodG86IFNxdWFyZSwgYm9hcmRNYXAgPSBib2FyZCkgPT4ge1xuICAgICAgICBjb25zdCBlblBhc3NhbnQgPSBib2FyZE1hcC5nZXQodG8pPy5lblBhc3NhbnQgYXMgRW5QYXNzYW50T2JqO1xuXG4gICAgICAgIGF0KGVuUGFzc2FudC5jdXJyZW50LCBib2FyZE1hcCkucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSkoKTtcblxuICBjb25zdCBhdCA9IChzcXVhcmU6IFNxdWFyZSwgYm9hcmRNYXAgPSBib2FyZCkgPT4gKHtcbiAgICBwbGFjZTogKHBpZWNlOiBQaWVjZU9iaik6IHZvaWQgPT4ge1xuICAgICAgaWYgKCFib2FyZE1hcC5nZXQoc3F1YXJlKSkgcmV0dXJuO1xuXG4gICAgICBib2FyZE1hcC5zZXQoc3F1YXJlLCB7IHBpZWNlIH0pO1xuICAgIH0sXG4gICAgcmVtb3ZlOiAoKTogdm9pZCA9PiB7XG4gICAgICBpZiAoIWJvYXJkTWFwLmdldChzcXVhcmUpKSByZXR1cm47XG5cbiAgICAgIGJvYXJkTWFwLnNldChzcXVhcmUsIHsgcGllY2U6IG51bGwgfSk7XG4gICAgfSxcbiAgICBwcm9tb3RlOiAocGllY2VUeXBlOiBQaWVjZVR5cGUpOiB2b2lkID0+IHtcbiAgICAgIGNvbnN0IHNxdWFyZVZhbCA9IGJvYXJkTWFwLmdldChzcXVhcmUpO1xuICAgICAgY29uc3QgcGllY2UgPSBzcXVhcmVWYWw/LnBpZWNlO1xuICAgICAgaWYgKCFwaWVjZSkgcmV0dXJuO1xuXG4gICAgICBib2FyZE1hcC5zZXQoc3F1YXJlLCB7XG4gICAgICAgIC4uLnNxdWFyZVZhbCxcbiAgICAgICAgcGllY2U6IHsgLi4ucGllY2UsIHR5cGU6IHBpZWNlVHlwZSB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHNldEVuUGFzc2FudDogKGNvbG9yOiBDb2xvciwgY3VycmVudDogU3F1YXJlKTogdm9pZCA9PiB7XG4gICAgICBpZiAoIWJvYXJkTWFwLmdldChzcXVhcmUpKSByZXR1cm47XG5cbiAgICAgIGJvYXJkTWFwLnNldChzcXVhcmUsIHtcbiAgICAgICAgcGllY2U6IG51bGwsXG4gICAgICAgIGVuUGFzc2FudDoge1xuICAgICAgICAgIGN1cnJlbnQgLyogc3F1YXJlIHBhd24gaXMgb24gKi8sXG4gICAgICAgICAgY29sb3JcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXQgcGllY2UoKSB7XG4gICAgICByZXR1cm4gYm9hcmRNYXAuZ2V0KHNxdWFyZSk/LnBpZWNlO1xuICAgIH0sXG4gICAgZ2V0TGVnYWxNb3ZlczogKGNoZWNrcyA9IHNxdWFyZXNHaXZpbmdDaGVjayB8fCBbXSk6IE1vdmVzID0+IHtcbiAgICAgIGNvbnN0IHsgdHlwZSwgY29sb3IgfSA9IGF0KHNxdWFyZSwgYm9hcmRNYXApLnBpZWNlIGFzIFBpZWNlT2JqO1xuXG4gICAgICBzd2l0Y2ggKGNoZWNrcy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgaWYgKHR5cGUgIT09ICdraW5nJykgcmV0dXJuIFtdO1xuICAgICAgICAgIHJldHVybiBnZXRMZWdhbE1vdmVzKHNxdWFyZSwgYm9hcmRNYXApO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMToge1xuICAgICAgICAgIGlmICh0eXBlID09PSAna2luZycpIHJldHVybiBnZXRMZWdhbE1vdmVzKHNxdWFyZSwgYm9hcmRNYXApO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBnZXRMZWdhbE1vdmVzSW5DaGVjayhcbiAgICAgICAgICAgICAgc3F1YXJlLFxuICAgICAgICAgICAgICBib2FyZE1hcCxcbiAgICAgICAgICAgICAgZ2V0LmtpbmdQb3NpdGlvbihjb2xvcikgYXMgU3F1YXJlLFxuICAgICAgICAgICAgICBjaGVja3NbMF1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGlmICh0eXBlID09PSAna2luZycpIHtcbiAgICAgICAgICAgIGxldCBsZWdhbE1vdmVzID0gZ2V0TGVnYWxNb3ZlcyhzcXVhcmUsIGJvYXJkTWFwKTtcbiAgICAgICAgICAgIGlmIChnZXQuY2FuQ2FzdGxlKGNvbG9yLCAna2luZ3NpZGUnKSlcbiAgICAgICAgICAgICAgbGVnYWxNb3ZlcyA9IFtcbiAgICAgICAgICAgICAgICAuLi5sZWdhbE1vdmVzLFxuICAgICAgICAgICAgICAgIC4uLmdldC5jYXN0bGVTcXVhcmVzKGNvbG9yKS5raW5nc2lkZVxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgaWYgKGdldC5jYW5DYXN0bGUoY29sb3IsICdxdWVlbnNpZGUnKSlcbiAgICAgICAgICAgICAgbGVnYWxNb3ZlcyA9IFtcbiAgICAgICAgICAgICAgICAuLi5sZWdhbE1vdmVzLFxuICAgICAgICAgICAgICAgIC4uLmdldC5jYXN0bGVTcXVhcmVzKGNvbG9yKS5xdWVlbnNpZGVcbiAgICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgcmV0dXJuIGxlZ2FsTW92ZXM7XG4gICAgICAgICAgfSBlbHNlIHJldHVybiBnZXRMZWdhbE1vdmVzKHNxdWFyZSwgYm9hcmRNYXApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBjb25zdCBmcm9tID0gKHMxOiBTcXVhcmUsIGJvYXJkTWFwID0gYm9hcmQpID0+ICh7XG4gICAgdG86IChzMjogU3F1YXJlKTogdm9pZCA9PiB7XG4gICAgICBjb25zdCBwaWVjZSA9IGF0KHMxLCBib2FyZE1hcCkucGllY2U7XG4gICAgICBpZiAoIXBpZWNlKSByZXR1cm47XG5cbiAgICAgIC8vIG1vdmUgcGllY2VcbiAgICAgIGF0KHMxLCBib2FyZE1hcCkucmVtb3ZlKCk7XG4gICAgICBhdChzMiwgYm9hcmRNYXApLnBsYWNlKHBpZWNlKTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IGdldCA9IHtcbiAgICBraW5nUG9zaXRpb246IChjb2xvcjogQ29sb3IsIGJvYXJkTWFwID0gYm9hcmQpOiBTcXVhcmUgfCB1bmRlZmluZWQgPT4ge1xuICAgICAgZm9yIChjb25zdCBbc3F1YXJlLCB2YWx1ZV0gb2YgYm9hcmRNYXAuZW50cmllcygpKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB2YWx1ZS5waWVjZSAmJlxuICAgICAgICAgIHZhbHVlLnBpZWNlLnR5cGUgPT09ICdraW5nJyAmJlxuICAgICAgICAgIHZhbHVlLnBpZWNlLmNvbG9yID09PSBjb2xvclxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIHNxdWFyZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHBpZWNlTWFwOiAoYm9hcmRNYXAgPSBib2FyZCk6IEFsbFBpZWNlTWFwID0+IHtcbiAgICAgIGNvbnN0IHBpZWNlTWFwID0geyB3aGl0ZToge30gYXMgUGllY2VNYXAsIGJsYWNrOiB7fSBhcyBQaWVjZU1hcCB9O1xuICAgICAgZm9yIChjb25zdCBbc3F1YXJlLCB2YWx1ZV0gb2YgYm9hcmRNYXAuZW50cmllcygpKSB7XG4gICAgICAgIGNvbnN0IHsgcGllY2UgfSA9IHZhbHVlO1xuICAgICAgICBpZiAoIXBpZWNlKSBjb250aW51ZTtcblxuICAgICAgICBjb25zdCB7IHR5cGUsIGNvbG9yIH0gPSBwaWVjZTtcbiAgICAgICAgcGllY2VNYXBbY29sb3JdW3R5cGVdID0gcGllY2VNYXBbY29sb3JdW3R5cGVdXG4gICAgICAgICAgPyBbLi4ucGllY2VNYXBbY29sb3JdW3R5cGVdLCBzcXVhcmVdXG4gICAgICAgICAgOiBbc3F1YXJlXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwaWVjZU1hcDtcbiAgICB9LFxuICAgIHBpZWNlc1RoYXRIaXRTcXVhcmU6IChcbiAgICAgIGNvbG9yOiBDb2xvcixcbiAgICAgIHBpZWNlVHlwZTogUGllY2VUeXBlLFxuICAgICAgc3F1YXJlOiBTcXVhcmUsXG4gICAgICBib2FyZE1hcCA9IGJvYXJkXG4gICAgKTogU3F1YXJlW10gPT4ge1xuICAgICAgY29uc3QgcGllY2VNYXAgPSBnZXQucGllY2VNYXAoYm9hcmRNYXApO1xuICAgICAgaWYgKHBpZWNlTWFwW2NvbG9yXVtwaWVjZVR5cGVdLmluY2x1ZGVzKHNxdWFyZSkpIHJldHVybiBbXTtcblxuICAgICAgY29uc3QgcGllY2VzOiBTcXVhcmVbXSA9IFtdO1xuICAgICAgaWYgKHBpZWNlTWFwW2NvbG9yXVtwaWVjZVR5cGVdLmxlbmd0aCA8PSAxKSByZXR1cm4gW107XG4gICAgICBwaWVjZU1hcFtjb2xvcl1bcGllY2VUeXBlXS5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgIGlmIChhdChzLCBib2FyZE1hcCkuZ2V0TGVnYWxNb3ZlcygpLmluY2x1ZGVzKHNxdWFyZSkpIHBpZWNlcy5wdXNoKHMpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcGllY2VzO1xuICAgIH0sXG4gICAgc3F1YXJlc0dpdmluZ0NoZWNrQWZ0ZXJNb3ZlOiAoZnJvbTogU3F1YXJlLCBlbmQ6IFNxdWFyZSk6IFNxdWFyZVtdID0+IHtcbiAgICAgIGNvbnN0IHNxdWFyZXNHaXZpbmdDaGVjazogc3RyaW5nW10gPSBbXTtcblxuICAgICAgY29uc3QgcGllY2UgPSBib2FyZC5nZXQoZW5kKT8ucGllY2UgYXMgUGllY2VPYmo7XG4gICAgICBjb25zdCBvcHBDb2xvciA9IHBpZWNlLmNvbG9yID09PSAnd2hpdGUnID8gJ2JsYWNrJyA6ICd3aGl0ZSc7XG4gICAgICBjb25zdCBraW5nUG9zaXRpb24gPSBnZXQua2luZ1Bvc2l0aW9uKG9wcENvbG9yKSBhcyBTcXVhcmU7XG5cbiAgICAgIGNvbnN0IHBpZWNlSGl0c0tpbmcgPSBnZXRMZWdhbE1vdmVzKGVuZCwgYm9hcmQpLmluY2x1ZGVzKGtpbmdQb3NpdGlvbik7XG4gICAgICBpZiAocGllY2VIaXRzS2luZykgc3F1YXJlc0dpdmluZ0NoZWNrLnB1c2goZW5kKTtcblxuICAgICAgY29uc3QgZGlzY292ZXJlZENoZWNrID0gZ2V0RGlzY292ZXJlZENoZWNrKFxuICAgICAgICBraW5nUG9zaXRpb24sXG4gICAgICAgIG9wcENvbG9yLFxuICAgICAgICBmcm9tLFxuICAgICAgICBib2FyZFxuICAgICAgKTtcbiAgICAgIGlmIChkaXNjb3ZlcmVkQ2hlY2sgJiYgZGlzY292ZXJlZENoZWNrICE9PSBlbmQpXG4gICAgICAgIHNxdWFyZXNHaXZpbmdDaGVjay5wdXNoKGRpc2NvdmVyZWRDaGVjayk7XG5cbiAgICAgIHJldHVybiBzcXVhcmVzR2l2aW5nQ2hlY2s7XG4gICAgfSxcbiAgICBpc0NoZWNrbWF0ZTogKFxuICAgICAgY29sb3JPZktpbmc6IENvbG9yLFxuICAgICAgc3F1YXJlc0dpdmluZ0NoZWNrOiBzdHJpbmdbXSxcbiAgICAgIGJvYXJkTWFwID0gYm9hcmRcbiAgICApOiBib29sZWFuID0+IHtcbiAgICAgIGNvbnN0IGtpbmdQb3MgPSBnZXQua2luZ1Bvc2l0aW9uKGNvbG9yT2ZLaW5nLCBib2FyZE1hcCkgYXMgU3F1YXJlO1xuICAgICAgY29uc3QgbGVnYWxNb3ZlcyA9IGF0KGtpbmdQb3MsIGJvYXJkTWFwKS5nZXRMZWdhbE1vdmVzKCk7XG4gICAgICAvLyBjaGVjayBpZiBjaGVjayBjYW4gYmUgYmxvY2tlZFxuICAgICAgaWYgKHNxdWFyZXNHaXZpbmdDaGVjay5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKGNhbkJsb2NrT3JDYXB0dXJlQ2hlY2soa2luZ1Bvcywgc3F1YXJlc0dpdmluZ0NoZWNrWzBdLCBib2FyZE1hcCkpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGxlZ2FsTW92ZXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGNhc3RsZVNxdWFyZXMoY29sb3I6IENvbG9yKTogQ2FzdGxlU3F1YXJlc1R5cGUge1xuICAgICAgY29uc3QgcmFuayA9IGNvbG9yID09PSAnd2hpdGUnID8gMSA6IDg7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBraW5nc2lkZTogW2BmJHtyYW5rfWAsIGBnJHtyYW5rfWBdLFxuICAgICAgICBxdWVlbnNpZGU6IFtgZCR7cmFua31gLCBgYyR7cmFua31gXVxuICAgICAgfTtcbiAgICB9LFxuICAgIGNhc3RsZVNpZGUoY29sb3I6IENvbG9yLCB0bzogU3F1YXJlKTogJycgfCAncXVlZW5zaWRlJyB8ICdraW5nc2lkZScge1xuICAgICAgbGV0IGNhc3RsZVNpZGU6ICcnIHwgJ3F1ZWVuc2lkZScgfCAna2luZ3NpZGUnID0gJyc7XG4gICAgICBjb25zdCBjYXN0bGVTcXVhcmVzID0gZ2V0LmNhc3RsZVNxdWFyZXMoY29sb3IpO1xuXG4gICAgICBmb3IgKGNvbnN0IFtzaWRlLCBzcXVhcmVzXSBvZiBPYmplY3QuZW50cmllcyhjYXN0bGVTcXVhcmVzKSkge1xuICAgICAgICBpZiAoc3F1YXJlc1sxXSA9PT0gdG8pIGNhc3RsZVNpZGUgPSBzaWRlIGFzICdraW5nc2lkZScgfCAncXVlZW5zaWRlJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYXN0bGVTaWRlO1xuICAgIH0sXG4gICAgY2FzdGxlUmlnaHRzQWZ0ZXJNb3ZlOiAoc3F1YXJlOiBTcXVhcmUsIGJvYXJkTWFwID0gYm9hcmQpOiBDYXN0bGVPYmogPT4ge1xuICAgICAgY29uc3QgcGllY2UgPSBhdChzcXVhcmUsIGJvYXJkTWFwKS5waWVjZSBhcyBQaWVjZU9iajtcblxuICAgICAgY29uc3QgY2FzdGxlUmlnaHRzID0gQ2FzdGxlUmlnaHRzIHx8IENhc3RsZSh0cnVlLCB0cnVlLCB0cnVlLCB0cnVlKTtcblxuICAgICAgaWYgKFxuICAgICAgICBjYXN0bGVSaWdodHNbcGllY2UuY29sb3JdLmtpbmdzaWRlIHx8XG4gICAgICAgIGNhc3RsZVJpZ2h0c1twaWVjZS5jb2xvcl0ucXVlZW5zaWRlXG4gICAgICApIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgaSBuZWVkIHRvIGNoYW5nZSBjYXN0bGluZyByaWdodHNcbiAgICAgICAgaWYgKHBpZWNlLnR5cGUgPT09ICdraW5nJykge1xuICAgICAgICAgIGNhc3RsZVJpZ2h0c1twaWVjZS5jb2xvcl0ua2luZ3NpZGUgPSBmYWxzZTtcbiAgICAgICAgICBjYXN0bGVSaWdodHNbcGllY2UuY29sb3JdLnF1ZWVuc2lkZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBpZWNlLnR5cGUgPT09ICdyb29rJykge1xuICAgICAgICAgIC8vIG5lZWQgdG8gZmluZCBpZiBpdCBpcyBraW5nc2lkZSBvciBxdWVlbnNpZGUgcm9va1xuICAgICAgICAgIGNvbnN0IFtmaWxlXSA9IHNxdWFyZS5zcGxpdCgnJyk7XG4gICAgICAgICAgY29uc3Qga2luZ3NpZGUgPSBmaWxlcy5pbmRleE9mKGZpbGUpID4gMztcbiAgICAgICAgICBpZiAoa2luZ3NpZGUpIGNhc3RsZVJpZ2h0c1twaWVjZS5jb2xvcl0ua2luZ3NpZGUgPSBmYWxzZTtcbiAgICAgICAgICBlbHNlIGNhc3RsZVJpZ2h0c1twaWVjZS5jb2xvcl0ucXVlZW5zaWRlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNhc3RsZVJpZ2h0cztcbiAgICB9LFxuICAgIGNhbkNhc3RsZTogKFxuICAgICAgY29sb3I6IENvbG9yLFxuICAgICAgc2lkZTogJ2tpbmdzaWRlJyB8ICdxdWVlbnNpZGUnLFxuICAgICAgYm9hcmRNYXAgPSBib2FyZFxuICAgICk6IGJvb2xlYW4gPT4ge1xuICAgICAgaWYgKENhc3RsZVJpZ2h0cyAmJiAhQ2FzdGxlUmlnaHRzW2NvbG9yXVtzaWRlXSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBjaGVjayBpZiByb29rIHN0aWxsIGV4aXN0c1xuICAgICAgaWYgKCFjaGVja0lmUm9va0V4aXN0cygpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGNvbnN0IG9wcENvbG9yID0gY29sb3IgPT09ICd3aGl0ZScgPyAnYmxhY2snIDogJ3doaXRlJztcbiAgICAgIGNvbnN0IG9wcE1vdmVzID0gZ2V0QXR0YWNraW5nTW92ZXNGb3JDb2xvcihvcHBDb2xvciwgYm9hcmRNYXApO1xuXG4gICAgICBjb25zdCBjYXN0bGVTcXVhcmVzID0gZ2V0LmNhc3RsZVNxdWFyZXMoY29sb3IpW3NpZGVdO1xuICAgICAgZm9yIChjb25zdCBzcXVhcmUgb2YgY2FzdGxlU3F1YXJlcykge1xuICAgICAgICAvLyBjaGVjayBpZiBjYXN0bGUgc3F1YXJlIGlzIGNsZWFyZWRcbiAgICAgICAgaWYgKGF0KHNxdWFyZSwgYm9hcmRNYXApLnBpZWNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSBjYXN0bGUgc3F1YXJlIGlzbnQgYXR0YWNrZWRcbiAgICAgICAgaWYgKG9wcE1vdmVzLmluY2x1ZGVzKHNxdWFyZSkpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIGZ1bmN0aW9uIGNoZWNrSWZSb29rRXhpc3RzKCk6IGJvb2xlYW4ge1xuICAgICAgICBsZXQgcm9va0V4aXN0cyA9IGZhbHNlO1xuICAgICAgICBjb25zdCByYW5rID0gY29sb3IgPT09ICd3aGl0ZScgPyAxIDogODtcbiAgICAgICAgY29uc3QgbG9vcFN0YXJ0ID1cbiAgICAgICAgICBzaWRlID09PSAncXVlZW5zaWRlJyA/IGZpbGVzLmluZGV4T2YoJ2EnKSA6IGZpbGVzLmluZGV4T2YoJ2QnKTtcbiAgICAgICAgY29uc3QgbG9vcEVuZCA9XG4gICAgICAgICAgc2lkZSA9PT0gJ3F1ZWVuc2lkZScgPyBmaWxlcy5pbmRleE9mKCdlJykgOiBmaWxlcy5pbmRleE9mKCdoJyk7XG4gICAgICAgIGZvciAobGV0IGkgPSBsb29wU3RhcnQ7IGkgPD0gbG9vcEVuZDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qgc3F1YXJlID0gZmlsZXNbaV0gKyByYW5rO1xuXG4gICAgICAgICAgY29uc3QgcGllY2UgPSBhdChzcXVhcmUsIGJvYXJkTWFwKS5waWVjZTtcbiAgICAgICAgICBpZiAoIXBpZWNlKSBjb250aW51ZTtcblxuICAgICAgICAgIGlmIChwaWVjZS50eXBlID09PSAncm9vaycpIHJvb2tFeGlzdHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb29rRXhpc3RzO1xuICAgICAgfVxuICAgIH0sXG4gICAgYm9hcmRTdGF0ZUZyb21IaXN0b3J5OiAoaGlzdG9yeTogSGlzdG9yeVR5cGUpOiBCb2FyZFtdID0+IHtcbiAgICAgIGNvbnN0IGJvYXJkU3RhdGVzOiBCb2FyZFtdID0gW107XG5cbiAgICAgIGNvbnN0IGJvYXJkTWFwID0gY3JlYXRlQm9hcmQoKTtcbiAgICAgIHBsYWNlUGllY2VzKHN0YXJ0aW5nUG9zaXRpb25zLnN0YW5kYXJkLCBib2FyZE1hcCk7XG4gICAgICBsZXQgcGllY2VNYXAgPSBzdGFydGluZ1Bvc2l0aW9ucy5zdGFuZGFyZDtcblxuICAgICAgLy8gaGlzdG9yeSBpcyAyZCBhcnJheVxuICAgICAgY29uc3QgZmxhdCA9IGhpc3RvcnkuZmxhdCgpO1xuXG4gICAgICAvKiBpdGVyYXRlIG92ZXIgaGlzdG9yeSAqL1xuICAgICAgZm9yIChjb25zdCBbaSwgbV0gb2YgZmxhdC5lbnRyaWVzKCkpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VOb3RhdGlvbihtKTtcbiAgICAgICAgY29uc3QgY29sb3IgPSBpICUgMiA9PT0gMCA/ICd3aGl0ZScgOiAnYmxhY2snO1xuXG4gICAgICAgIGlmIChwYXJzZWQuY2FzdGxlKSB7XG4gICAgICAgICAgY2FzdGxlKGNvbG9yLCBwYXJzZWQuY2FzdGxlLCBib2FyZE1hcCk7XG4gICAgICAgICAgcGllY2VNYXAgPSBnZXQucGllY2VNYXAoYm9hcmRNYXApO1xuICAgICAgICAgIGJvYXJkU3RhdGVzLnB1c2gobmV3IE1hcChib2FyZE1hcCkpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcG9zc2libGVQaWVjZXMgPSBwaWVjZU1hcFtjb2xvcl1bcGFyc2VkLnBpZWNlVHlwZV0uZmlsdGVyKChzKSA9PlxuICAgICAgICAgIGdldExlZ2FsTW92ZXMocywgYm9hcmRNYXApLmluY2x1ZGVzKHBhcnNlZC50bylcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBnZXQgJ2Zyb20nIHNxdWFyZVxuICAgICAgICBsZXQgczE6IFNxdWFyZTtcbiAgICAgICAgaWYgKHBhcnNlZC5mcm9tKSB7XG4gICAgICAgICAgY29uc3Qgbm90YXRpb24gPSBwYXJzZWQuZnJvbTtcbiAgICAgICAgICBpZiAobm90YXRpb24ubGVuZ3RoID09PSAyKSBzMSA9IG5vdGF0aW9uO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgczEgPVxuICAgICAgICAgICAgICBwb3NzaWJsZVBpZWNlcy5maW5kKChzKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gaWYgbm90YXRpb24gaXMgYSBudW1iZXIsIHRoYXQgbWVhbnMgcGllY2UgaXMgb24gdGhlIHJhbmsgPT09IG5vdGF0aW9uLCBpZiBub3QsIHNhbWUgZmlsZVxuICAgICAgICAgICAgICAgIHJldHVybiBpc05hTihOdW1iZXIobm90YXRpb24pKVxuICAgICAgICAgICAgICAgICAgPyBzWzBdID09PSBub3RhdGlvblxuICAgICAgICAgICAgICAgICAgOiBzWzFdID09PSBub3RhdGlvbjtcbiAgICAgICAgICAgICAgfSkgfHwgJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgczEgPSBwb3NzaWJsZVBpZWNlc1swXTtcblxuICAgICAgICBjb25zdCBwaWVjZSA9IGF0KHMxLCBib2FyZE1hcCkucGllY2U7XG4gICAgICAgIGlmICghczEgfHwgIXBpZWNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYWtlIG1vdmVcbiAgICAgICAgaWYgKHBpZWNlLnR5cGUgPT09ICdwYXduJykge1xuICAgICAgICAgIGlmIChlblBhc3NhbnQuaXNDYXB0dXJlKHMxLCBwYXJzZWQudG8sIGJvYXJkTWFwKSkge1xuICAgICAgICAgICAgZW5QYXNzYW50LmNhcHR1cmUocGFyc2VkLnRvLCBib2FyZE1hcCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZW5QYXNzYW50LnJlbW92ZShib2FyZE1hcCk7XG5cbiAgICAgICAgICBpZiAoZW5QYXNzYW50LmNoZWNrVG9nZ2xlKHMxLCBwYXJzZWQudG8pKVxuICAgICAgICAgICAgZW5QYXNzYW50LnRvZ2dsZShjb2xvciwgcGFyc2VkLnRvLCBib2FyZE1hcCk7XG5cbiAgICAgICAgICBpZiAocGFyc2VkLnByb21vdGUpIHtcbiAgICAgICAgICAgIGF0KHMxLCBib2FyZE1hcCkucHJvbW90ZShwYXJzZWQucHJvbW90ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgZW5QYXNzYW50LnJlbW92ZShib2FyZE1hcCk7XG5cbiAgICAgICAgZnJvbShzMSwgYm9hcmRNYXApLnRvKHBhcnNlZC50byk7XG4gICAgICAgIHBpZWNlTWFwID0gZ2V0LnBpZWNlTWFwKGJvYXJkTWFwKTtcbiAgICAgICAgYm9hcmRTdGF0ZXMucHVzaChuZXcgTWFwKGJvYXJkTWFwKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBib2FyZFN0YXRlcztcbiAgICB9LFxuICAgIG1vdmVOb3RhdGlvbihcbiAgICAgIGZyb206IFNxdWFyZSxcbiAgICAgIHRvOiBTcXVhcmUsXG4gICAgICBwcm9tb3RlPzogUGllY2VUeXBlLFxuICAgICAgY2hlY2s/OiBib29sZWFuLFxuICAgICAgY2hlY2ttYXRlPzogYm9vbGVhbixcbiAgICAgIGJvYXJkTWFwID0gYm9hcmRcbiAgICApOiBzdHJpbmcge1xuICAgICAgY29uc3QgbW92ZURldGFpbHM6IE1vdmVEZXRhaWxzSW50ZXJmYWNlID0ge307XG5cbiAgICAgIGNvbnN0IHsgdHlwZSwgY29sb3IgfSA9IGF0KGZyb20sIGJvYXJkTWFwKS5waWVjZSBhcyBQaWVjZU9iajtcbiAgICAgIG1vdmVEZXRhaWxzLnBpZWNlVHlwZSA9IHR5cGU7XG5cbiAgICAgIGlmIChjaGVja21hdGUpIG1vdmVEZXRhaWxzLmNoZWNrbWF0ZSA9IGNoZWNrbWF0ZTtcbiAgICAgIGVsc2UgaWYgKGNoZWNrKSBtb3ZlRGV0YWlscy5jaGVjayA9IGNoZWNrO1xuXG4gICAgICBsZXQgY2FwdHVyZSA9IGZhbHNlO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ3Bhd24nOiB7XG4gICAgICAgICAgY2FwdHVyZSA9IFBpZWNlKGNvbG9yLCB0eXBlKVxuICAgICAgICAgICAgLmdldFBhd25DYXB0dXJlcyhmcm9tKVxuICAgICAgICAgICAgPy5pbmNsdWRlcyh0bykgYXMgYm9vbGVhbjtcbiAgICAgICAgICBtb3ZlRGV0YWlscy5jYXB0dXJlID0gY2FwdHVyZTtcbiAgICAgICAgICBpZiAoY2FwdHVyZSkgbW92ZURldGFpbHMuZGlmZmVyZW50aWF0aW9uID0gZnJvbVswXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY2FwdHVyZSA9ICEhYXQodG8sIGJvYXJkTWFwKS5waWVjZTtcbiAgICAgICAgICBtb3ZlRGV0YWlscy5jYXB0dXJlID0gY2FwdHVyZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocHJvbW90ZSkgbW92ZURldGFpbHMucHJvbW90ZSA9IHByb21vdGU7XG5cbiAgICAgIC8vIGdldCBkaWZmZXJlbnRpYXRpb24gaWUuIHdoZW4gbXVsdGlwbGUgcGllY2VzIGhpdCB0aGUgc2FtZSBzcXVhcmVcbiAgICAgIGNvbnN0IHBpZWNlc1RoYXRIaXRTcXVhcmUgPSBnZXQucGllY2VzVGhhdEhpdFNxdWFyZShcbiAgICAgICAgY29sb3IsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHRvLFxuICAgICAgICBib2FyZE1hcFxuICAgICAgKTtcbiAgICAgIHN3aXRjaCAocGllY2VzVGhhdEhpdFNxdWFyZS5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIG1vdmVEZXRhaWxzLmRpZmZlcmVudGlhdGlvbiA9IGZyb207XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgIC8vIG5lZWQgdG8gZmluZCBpZiBvbiBzYW1lIGZpbGUgb3IgcmFua1xuICAgICAgICAgIGNvbnN0IG90aGVyUGllY2UgPSBwaWVjZXNUaGF0SGl0U3F1YXJlLmZpbmQoXG4gICAgICAgICAgICAocykgPT4gcyAhPT0gZnJvbVxuICAgICAgICAgICkgYXMgU3F1YXJlO1xuICAgICAgICAgIG1vdmVEZXRhaWxzLmRpZmZlcmVudGlhdGlvbiA9XG4gICAgICAgICAgICBvdGhlclBpZWNlWzBdID09PSBmcm9tWzBdID8gZnJvbVsxXSA6IGZyb21bMF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1vdmVOb3RhdGlvbih0bykuZ2V0KG1vdmVEZXRhaWxzKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgdmFsaWRhdGUgPSB7XG4gICAgbW92ZTogKGZyb206IFNxdWFyZSwgdG86IFNxdWFyZSwgYm9hcmRNYXAgPSBib2FyZCk6IGJvb2xlYW4gPT4ge1xuICAgICAgY29uc3QgcGllY2UgPSBhdChmcm9tLCBib2FyZE1hcCkucGllY2U7XG4gICAgICBpZiAoIXBpZWNlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGlmICghYXQoZnJvbSwgYm9hcmRNYXApLmdldExlZ2FsTW92ZXMoKS5pbmNsdWRlcyh0bykpIHJldHVybiBmYWxzZTtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBwcm9tb3Rpb246IChmcm9tOiBTcXVhcmUsIHRvOiBTcXVhcmUsIGJvYXJkTWFwID0gYm9hcmQpOiBib29sZWFuID0+IHtcbiAgICAgIGNvbnN0IHBpZWNlID0gYXQoZnJvbSwgYm9hcmRNYXApLnBpZWNlO1xuXG4gICAgICBpZiAocGllY2U/LnR5cGUgIT09ICdwYXduJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBjb25zdCBlbmRPZkJvYXJkID0gcGllY2UuY29sb3IgPT09ICd3aGl0ZScgPyA4IDogMTtcbiAgICAgIGNvbnN0IFssIHJhbmtdID0gdG8uc3BsaXQoJycpO1xuICAgICAgaWYgKCtyYW5rICE9PSBlbmRPZkJvYXJkKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGNyZWF0ZUJvYXJkLFxuICAgIHBsYWNlUGllY2VzLFxuICAgIGNhc3RsZSxcbiAgICBlblBhc3NhbnQsXG4gICAgYXQsXG4gICAgZnJvbSxcbiAgICBnZXQsXG4gICAgdmFsaWRhdGUsXG4gICAgbWFrZU1vdmUsXG4gICAgZ2V0IGJvYXJkKCkge1xuICAgICAgcmV0dXJuIGJvYXJkO1xuICAgIH1cbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEdhbWVib2FyZDtcbiIsImltcG9ydCB7IEhpc3RvcnlPYmogfSBmcm9tICcuL3R5cGVzL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgSGlzdG9yeVR5cGUgfSBmcm9tICcuL3R5cGVzL3R5cGVzJztcbmltcG9ydCB7IGRlZXBDb3B5MmRBcnJheSB9IGZyb20gJy4vdXRpbHMvaGVscGVycyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhpc3RvcnkocHJldkhpc3Rvcnk6IEhpc3RvcnlUeXBlKTogSGlzdG9yeU9iaiB7XG4gIGNvbnN0IGhpc3Rvcnk6IEhpc3RvcnlUeXBlID0gZGVlcENvcHkyZEFycmF5KHByZXZIaXN0b3J5KSB8fCBbXTtcblxuICByZXR1cm4ge1xuICAgIGluc2VydE1vdmU6IChub3RhdGlvbjogc3RyaW5nKSA9PiB7XG4gICAgICBjb25zdCBsYXN0UGFpciA9IGhpc3RvcnlbaGlzdG9yeS5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChsYXN0UGFpciAmJiBsYXN0UGFpci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgbGFzdFBhaXIucHVzaChub3RhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBuZXdQYWlyID0gW25vdGF0aW9uXTtcbiAgICAgICAgaGlzdG9yeS5wdXNoKG5ld1BhaXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGlzdG9yeTtcbiAgICB9XG4gIH07XG59XG4iLCJpbXBvcnQgeyBBbGxQaWVjZU1hcCB9IGZyb20gJy4vdHlwZXMvaW50ZXJmYWNlcyc7XG5cbmNvbnN0IHN0YW5kYXJkOiBBbGxQaWVjZU1hcCA9IHtcbiAgd2hpdGU6IHtcbiAgICByb29rOiBbJ2ExJywgJ2gxJ10sXG4gICAga25pZ2h0OiBbJ2cxJywgJ2IxJ10sXG4gICAgYmlzaG9wOiBbJ2YxJywgJ2MxJ10sXG4gICAga2luZzogWydlMSddLFxuICAgIHF1ZWVuOiBbJ2QxJ10sXG4gICAgcGF3bjogWydhMicsICdiMicsICdjMicsICdkMicsICdlMicsICdmMicsICdnMicsICdoMiddXG4gIH0sXG4gIGJsYWNrOiB7XG4gICAgcm9vazogWydhOCcsICdoOCddLFxuICAgIGtuaWdodDogWydnOCcsICdiOCddLFxuICAgIGJpc2hvcDogWydmOCcsICdjOCddLFxuICAgIGtpbmc6IFsnZTgnXSxcbiAgICBxdWVlbjogWydkOCddLFxuICAgIHBhd246IFsnYTcnLCAnYjcnLCAnYzcnLCAnZDcnLCAnZTcnLCAnZjcnLCAnZzcnLCAnaDcnXVxuICB9XG59O1xuXG5leHBvcnQgeyBzdGFuZGFyZCB9O1xuIiwiaW1wb3J0IEdhbWVib2FyZCBmcm9tICcuL0dhbWVib2FyZCc7XG5pbXBvcnQgSGlzdG9yeSBmcm9tICcuL0hpc3RvcnknO1xuaW1wb3J0IENhc3RsZSBmcm9tICcuL0Nhc3RsZSc7XG5pbXBvcnQgKiBhcyBzdGFydGluZ1Bvc2l0aW9ucyBmcm9tICcuL3N0YXJ0aW5nUG9zaXRpb25zJztcbmltcG9ydCB7IHJhbmtzLCBmaWxlcyB9IGZyb20gJy4vcmFua3NBbmRGaWxlcyc7XG5cbmV4cG9ydCB7IEdhbWVib2FyZCwgSGlzdG9yeSwgQ2FzdGxlLCBzdGFydGluZ1Bvc2l0aW9ucywgcmFua3MsIGZpbGVzIH07XG4iXSwibmFtZXMiOlsidG9YWSIsInNxdWFyZSIsIngiLCJ5Iiwic3BsaXQiLCJpbmRleE9mIiwidG9Mb3dlckNhc2UiLCJOdW1iZXIiLCJmcm9tWFkiLCJjb29yZCIsImNvbCIsImNvbmNhdCIsInRvU3RyaW5nIiwiY2FsY0Rpc3RhbmNlIiwic3F1YXJlT25lIiwic3F1YXJlVHdvIiwieDEiLCJ5MSIsIngyIiwieTIiLCJ4RGlmZiIsInlEaWZmIiwiZ2V0UGllY2VGcm9tQWJiciIsImFiYnIiLCJwYXJzZU5vdGF0aW9uIiwibm90YXRpb24iLCJtb3ZlIiwicmVwbGFjZWQiLCJyZXBsYWNlIiwiY2FzdGxlIiwibGVuZ3RoIiwidG9VcHBlckNhc2UiLCJwaWVjZVR5cGUiLCJ0byIsInNsaWNlIiwiZnJvbSIsImluY2x1ZGVzIiwicHJvbW90ZSIsInByb21vdGVOb3RlSW5kZXgiLCJub1Byb21vdGVOb3RhdGlvbiIsImRlZXBDb3B5MmRBcnJheSIsImFyciIsIm1hcCIsIm4iLCJtb3ZlcyIsIlBpZWNlIiwiY29sb3IiLCJ0eXBlIiwiaGFzTW92ZSIsIm9uZVNxdWFyZVZlcnQiLCJ5QnlOIiwieEJ5TiIsIm9uZVNxdWFyZUxhdGVyYWwiLCJvbmVTcXVhcmVEaWFnb25hbGx5IiwiZGlhZ29uYWwiLCJ2ZXJ0QW5kTGF0ZXJhbCIsIm9ubHlNb3Zlc0luRnJvbnQiLCJyZWd1bGFyTW92ZSIsImZpcnN0TW92ZSIsImp1bXBUd28iLCJnZXRQYXduQ2FwdHVyZXMiLCJvcmlnaW4iLCJuZXdZIiwiY2FwdHVyZU9uZSIsImNhcHR1cmVUd28iLCJNYXRoIiwiYWJzIiwibnVtIiwic3BsaXRJbnRvVmVjdG9ycyIsImFycmF5T2ZNb3ZlcyIsInN0YXJ0IiwicmVkdWNlIiwiYWNjIiwiY3VyciIsInZlY3RvciIsImNoYXJBdCIsInB1c2giLCJnZXRCZWdpbm5pbmdPZlZlY3RvciIsImFjY0lzQmVnaW5uaW5nIiwiZ2V0TW92ZXNBbG9uZ1ZlY3RvciIsInMxIiwiczIiLCJhbGxTcXVhcmVzIiwibGllc1NhbWVWZXJ0T3JMYXQiLCJsaWVzU2FtZURpYWdvbmFsbHkiLCJsaWVzT25TYW1lTGluZSIsIm1hdGNoaW5nVmVjdG9yIiwic3F1YXJlc0Fsb25nVmVjdG9yIiwiZmlsdGVyIiwicyIsInNvcnRNb3Zlc0Nsb3Nlc3RUbyIsInNvcnQiLCJhIiwiYiIsIngxRGlmZiIsInkxRGlmZiIsImFEaWZmIiwieDJEaWZmIiwieTJEaWZmIiwiYkRpZmYiLCJnZXRQb3NzaWJsZU1vdmVzIiwiYm9hcmQiLCJBcnJheSIsImtleXMiLCJnZXQiLCJwaWVjZSIsImdldExlZ2FsTW92ZXMiLCJwb3NzaWJsZU1vdmVzIiwib2JzdHJ1Y3Rpb25zIiwiX2EiLCJyZW1vdmVQcm90ZWN0ZWRTcXVhcmVzIiwibGVnYWxNb3ZlcyIsImNhcHR1cmVzQXZhaWxhYmxlIiwidW5vYnN0cnVjdGVkTW92ZXMiLCJyZW1vdmVNb3Zlc1dpdGhQaWVjZXMiLCJyZW1vdmVPYnN0cnVjdGVkTW92ZXMiLCJnZXRMZWdhbE1vdmVzSW5DaGVjayIsImtpbmdQb3MiLCJzcXVhcmVHaXZpbmdDaGVjayIsInNxdWFyZXNUaGF0RGVhbFdpdGhDaGVjayIsImdldFNxdWFyZXNCZXR3ZWVuS2luZ0FuZENoZWNrIiwiZ2V0QXR0YWNraW5nTW92ZXMiLCJhdHRhY2tpbmdNb3ZlcyIsImdldEFsbE1vdmVzRm9yQ29sb3IiLCJza2lwS2luZyIsImFsbE1vdmVzIiwiZW50cmllcyIsImZsYXQiLCJnZXRBdHRhY2tpbmdNb3Zlc0ZvckNvbG9yIiwicGF3blNxdWFyZSIsInBhd24iLCJjYXB0dXJlTW92ZXMiLCJzcXVhcmVWYWwiLCJlblBhc3NhbnQiLCJjaGVja1BvcyIsInNxdWFyZXNCZXR3ZWVuS2luZ0FuZFBpZWNlIiwicmVtb3ZlTW92ZXNCZWhpbmRUd29TcXVhcmVzIiwic29ydGVkIiwiZnVydGhlc3RTcXVhcmUiLCJjbG9zZXN0U3F1YXJlIiwicmVtb3ZlZE9uZUVuZCIsInJlbW92ZU1vdmVzQmVoaW5kU3F1YXJlIiwicmVtb3ZlZEJvdGhFbmRzIiwicmV2ZXJzZSIsImNvcHkiLCJpbmRleCIsInNwbGljZSIsInN0YXJ0aW5nU3F1YXJlIiwiZmlsdGVyZWRNb3ZlcyIsImFsbFZlY3RvcnMiLCJvYnN0cnVjdGlvblZlY3RvcnMiLCJjbG9zZXN0T2JzdHJ1Y3Rpb24iLCJraW5nIiwib3BwQ29sb3IiLCJlbmVteVBpZWNlc0luVmljaW5pdHkiLCJfYiIsInNxdWFyZXNQcm90ZWN0ZWRCeUVuZW15SW5WaWNpbml0eSIsImJvYXJkQ29weSIsIk1hcCIsImZvckVhY2giLCJzZXQiLCJzcXVhcmVzUHJvdGVjdGVkQnlSYW5nZSIsImdldERpc2NvdmVyZWRDaGVjayIsImtpbmdDb2xvciIsInZhY2F0ZWQiLCJjYW5CbG9ja09yQ2FwdHVyZUNoZWNrIiwiYmxvY2tPckNhcHR1cmVTcXVhcmVzIiwib3duUGllY2VNb3ZlcyIsInNvbWUiLCJnZXRQaWVjZXNXaXRoTW92ZSIsInBpZWNlU3F1YXJlcyIsImZpbGVzIiwicmFua3MiLCJDYXN0bGUiLCJ3aGl0ZUtpbmdzaWRlIiwid2hpdGVRdWVlbnNpZGUiLCJibGFja0tpbmdzaWRlIiwiYmxhY2tRdWVlbnNpZGUiLCJ3aGl0ZSIsImtpbmdzaWRlIiwicXVlZW5zaWRlIiwiYmxhY2siLCJtb3ZlTm90YXRpb24iLCJzaWRlIiwiYWZmaXgiLCJwaWVjZU5vdGF0aW9uIiwiZGlmZmVyZW50aWF0aW9uIiwiY2FwdHVyZSIsInN1ZmZpeCIsImNoZWNrIiwiY2hlY2ttYXRlIiwibW92ZURldGFpbHMiLCJjYXN0bGVTaWRlIiwic3RhcnRpbmdQb3NpdGlvbnMiLCJjcmVhdGVCb2FyZCIsImZpbGUiLCJyYW5rIiwiR2FtZWJvYXJkIiwic3F1YXJlc0dpdmluZ0NoZWNrIiwiQ2FzdGxlUmlnaHRzIiwicGxhY2VQaWVjZXMiLCJwaWVjZU1hcCIsImJvYXJkTWFwIiwic3F1YXJlcyIsImF0IiwicGxhY2UiLCJtYWtlTW92ZSIsInZhbGlkYXRlIiwicHJvbW90aW9uIiwiaXNDYXB0dXJlIiwicmVtb3ZlIiwiY2hlY2tUb2dnbGUiLCJ0b2dnbGUiLCJjYXN0bGVTcXVhcmVzIiwia2luZ1Bvc2l0aW9uIiwicm9va1BvcyIsImdldFJvb2tQb3MiLCJyb29rIiwiZmluZCIsImdldFNxdWFyZSIsImN1cnJlbnQiLCJlblBhc3NhbnRTcXVhcmUiLCJzZXRFblBhc3NhbnQiLCJzcXVhcmVPYmoiLCJ2YWx1ZXMiLCJ1bmRlZmluZWQiLCJPYmplY3QiLCJjaGVja3MiLCJjYW5DYXN0bGUiLCJ2YWx1ZSIsInBpZWNlc1RoYXRIaXRTcXVhcmUiLCJwaWVjZXMiLCJzcXVhcmVzR2l2aW5nQ2hlY2tBZnRlck1vdmUiLCJlbmQiLCJwaWVjZUhpdHNLaW5nIiwiZGlzY292ZXJlZENoZWNrIiwiaXNDaGVja21hdGUiLCJjb2xvck9mS2luZyIsImNhc3RsZVJpZ2h0c0FmdGVyTW92ZSIsImNhc3RsZVJpZ2h0cyIsImNoZWNrSWZSb29rRXhpc3RzIiwib3BwTW92ZXMiLCJyb29rRXhpc3RzIiwibG9vcFN0YXJ0IiwibG9vcEVuZCIsImkiLCJib2FyZFN0YXRlRnJvbUhpc3RvcnkiLCJoaXN0b3J5IiwiYm9hcmRTdGF0ZXMiLCJzdGFuZGFyZCIsIm0iLCJwYXJzZWQiLCJwb3NzaWJsZVBpZWNlcyIsImlzTmFOIiwib3RoZXJQaWVjZSIsImVuZE9mQm9hcmQiLCJIaXN0b3J5IiwicHJldkhpc3RvcnkiLCJpbnNlcnRNb3ZlIiwibGFzdFBhaXIiLCJuZXdQYWlyIiwia25pZ2h0IiwiYmlzaG9wIiwicXVlZW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///327\n")}},__webpack_require__={d:(Q,F)=>{for(var B in F)__webpack_require__.o(F,B)&&!__webpack_require__.o(Q,B)&&Object.defineProperty(Q,B,{enumerable:!0,get:F[B]})},o:(Q,F)=>Object.prototype.hasOwnProperty.call(Q,F),r:Q=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})}},__webpack_exports__={};return __webpack_modules__[327](0,__webpack_exports__,__webpack_require__),__webpack_exports__})()));