!function(Q,F){"object"==typeof exports&&"object"==typeof module?module.exports=F():"function"==typeof define&&define.amd?define([],F):"object"==typeof exports?exports.croChess=F():Q.croChess=F()}(this,(function(){return(()=>{"use strict";var __webpack_modules__={708:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"Castle\": () => (/* reexport */ Castle),\n  \"Gameboard\": () => (/* reexport */ src_Gameboard),\n  \"History\": () => (/* reexport */ History),\n  \"files\": () => (/* reexport */ files),\n  \"ranks\": () => (/* reexport */ ranks),\n  \"startingPositions\": () => (/* reexport */ startingPositions_namespaceObject)\n});\n\n// NAMESPACE OBJECT: ./src/startingPositions.ts\nvar startingPositions_namespaceObject = {};\n__webpack_require__.r(startingPositions_namespaceObject);\n__webpack_require__.d(startingPositions_namespaceObject, {\n  \"standard\": () => (standard)\n});\n\n;// CONCATENATED MODULE: ./src/utils/helpers.ts\nfunction toXY(square) {\n  const [x, y] = square.split('');\n  return {\n    x: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'].indexOf(x.toLowerCase()),\n    y: Number(y)\n  };\n}\n\nfunction fromXY(coord) {\n  const {\n    x,\n    y\n  } = coord;\n  const col = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'][x];\n  if (!col) return '';\n  return col.concat(y.toString());\n}\n\nconst calcDistance = squareOne => squareTwo => {\n  const {\n    x: x1,\n    y: y1\n  } = toXY(squareOne);\n  const {\n    x: x2,\n    y: y2\n  } = toXY(squareTwo);\n  const xDiff = x1 - x2;\n  const yDiff = y1 - y2;\n  return {\n    xDiff,\n    yDiff\n  };\n};\n\n\n;// CONCATENATED MODULE: ./src/Piece.ts\n\n\n\nconst Piece = (color, type) => {\n  function hasMove(from, to) {\n    switch (type) {\n      case 'king':\n        {\n          const oneSquareVert = utils_moves.yByN(1)(from)(to) && utils_moves.xByN(0)(from)(to);\n          const oneSquareLateral = utils_moves.xByN(1)(from)(to) && utils_moves.yByN(0)(from)(to);\n          const oneSquareDiagonally = utils_moves.yByN(1)(from)(to) && utils_moves.xByN(1)(from)(to);\n          return from !== to && (oneSquareDiagonally || oneSquareVert || oneSquareLateral);\n        }\n\n      case 'queen':\n        {\n          return from !== to && (utils_moves.diagonal(from)(to) || utils_moves.vertAndLateral(from)(to));\n        }\n\n      case 'bishop':\n        {\n          return from !== to && utils_moves.diagonal(from)(to);\n        }\n\n      case 'knight':\n        {\n          return from !== to && (utils_moves.xByN(1)(from)(to) && utils_moves.yByN(2)(from)(to) || utils_moves.xByN(2)(from)(to) && utils_moves.yByN(1)(from)(to));\n        }\n\n      case 'rook':\n        {\n          return from !== to && utils_moves.vertAndLateral(to)(from);\n        }\n\n      case 'pawn':\n        {\n          const {\n            x: x1,\n            y: y1\n          } = toXY(from);\n          const {\n            x: x2,\n            y: y2\n          } = toXY(to);\n          const onlyMovesInFront = color === 'white' ? y1 < y2 : y1 > y2;\n          const regularMove = utils_moves.yByN(1)(from)(to) && x1 === x2;\n          const firstMove = color === 'white' ? y1 === 2 : y1 === 7;\n          const jumpTwo = utils_moves.yByN(2)(from)(to) && x1 === x2;\n          return from !== to && onlyMovesInFront && (regularMove || firstMove && jumpTwo);\n        }\n    }\n  }\n\n  function getPawnCaptures(origin) {\n    if (type !== 'pawn') return;\n    const {\n      x,\n      y\n    } = toXY(origin);\n    const newY = color === 'white' ? y + 1 : y - 1;\n    const captureOne = {\n      x: x + 1,\n      y: newY\n    };\n    const captureTwo = {\n      x: x - 1,\n      y: newY\n    };\n    return [fromXY(captureOne), fromXY(captureTwo)];\n  }\n\n  return {\n    hasMove,\n    getPawnCaptures,\n\n    get type() {\n      return type;\n    },\n\n    get color() {\n      return color;\n    }\n\n  };\n};\n\n/* harmony default export */ const src_Piece = (Piece);\n;// CONCATENATED MODULE: ./src/utils/moves.ts\n\n\nconst moves = {\n  vertAndLateral: from => to => {\n    const [x1, y1] = from.split('');\n    const [x2, y2] = to.split('');\n    return x1 === x2 || y1 === y2;\n  },\n  diagonal: from => to => {\n    const {\n      x: x1,\n      y: y1\n    } = toXY(from);\n    const {\n      x: x2,\n      y: y2\n    } = toXY(to);\n    return Math.abs(x2 - x1) === Math.abs(y2 - y1);\n  },\n  xByN: num => from => to => {\n    const {\n      x: x1\n    } = toXY(from);\n    const {\n      x: x2\n    } = toXY(to);\n    return Math.abs(x1 - x2) === num;\n  },\n  yByN: num => from => to => {\n    const {\n      y: y1\n    } = toXY(from);\n    const {\n      y: y2\n    } = toXY(to);\n    return Math.abs(y1 - y2) === num;\n  }\n};\n/* harmony default export */ const utils_moves = (moves);\n/* dealing with move vectors */\n\nfunction splitIntoVectors(arrayOfMoves, start) {\n  return arrayOfMoves.reduce((acc, curr) => {\n    const {\n      xDiff,\n      yDiff\n    } = calcDistance(start)(curr);\n    let vector = '';\n    if (yDiff !== 0) vector = yDiff < 0 ? 'up' : 'down';\n    if (xDiff !== 0) vector += xDiff < 0 ? 'Right' : 'Left'; // normalize vector name\n\n    vector = vector.charAt(0).toLowerCase() + vector.slice(1);\n    acc[vector] = acc[vector] || [];\n    acc[vector].push(curr);\n    return acc;\n  }, {});\n}\n\nfunction getBeginningOfVector(vector) {\n  if (vector.length === 0) return '';\n  return vector.reduce((acc, curr) => {\n    const {\n      x: x1,\n      y: y1\n    } = toXY(acc);\n    const {\n      x: x2,\n      y: y2\n    } = toXY(curr);\n    const accIsBeginning = x1 === x2 ? y1 < y2 : x1 < x2;\n    return accIsBeginning ? acc : curr;\n  });\n}\n\nconst getMovesAlongVector = (s1, s2, allSquares) => {\n  const liesSameVertOrLat = moves.vertAndLateral(s1)(s2);\n  const liesSameDiagonally = moves.diagonal(s1)(s2);\n  const liesOnSameLine = liesSameVertOrLat || liesSameDiagonally;\n  if (!liesOnSameLine) return [];\n  const matchingVector = liesSameDiagonally ? 'diagonal' : 'vertAndLateral';\n  const squaresAlongVector = allSquares.filter(s => moves[matchingVector](s1)(s) && moves[matchingVector](s2)(s));\n  return squaresAlongVector;\n};\n/* sort moves */\n\n\nconst sortMovesClosestTo = square => moves => {\n  return [...moves].sort((a, b) => {\n    const {\n      xDiff: x1Diff,\n      yDiff: y1Diff\n    } = calcDistance(square)(a);\n    const aDiff = Math.abs(x1Diff) + Math.abs(y1Diff);\n    const {\n      xDiff: x2Diff,\n      yDiff: y2Diff\n    } = calcDistance(square)(b);\n    const bDiff = Math.abs(x2Diff) + Math.abs(y2Diff);\n    return aDiff - bDiff;\n  });\n};\n/* get moves */\n\n\nfunction getPossibleMoves(origin, board) {\n  // get all moves that can happen if no other pieces were on the board\n  const allSquares = Array.from(board.keys());\n  const square = board.get(origin);\n  const {\n    type,\n    color\n  } = square.piece;\n  const piece = src_Piece(color, type);\n  return allSquares.filter(s => piece.hasMove(origin, s));\n}\n\nfunction getLegalMoves(origin, board) {\n  // get moves regardless of whether or not there is check\n  const square = board.get(origin);\n  const piece = square.piece;\n  const possibleMoves = getPossibleMoves(origin, board);\n  const obstructions = possibleMoves.filter(s => {\n    var _a;\n\n    return (_a = board.get(s)) === null || _a === void 0 ? void 0 : _a.piece;\n  });\n\n  if (!obstructions.length) {\n    if (piece.type === 'pawn') return [...getPawnCaptures(origin, board), ...possibleMoves];\n    return possibleMoves;\n  }\n\n  let legalMoves = [];\n\n  switch (piece.type) {\n    case 'knight':\n      {\n        legalMoves = possibleMoves;\n        break;\n      }\n\n    case 'pawn':\n      {\n        const capturesAvailable = getPawnCaptures(origin, board);\n        const unobstructedMoves = removeMovesWithPieces(removeObstructedMoves(origin, possibleMoves, obstructions), board);\n        legalMoves = [...capturesAvailable, ...unobstructedMoves];\n        break;\n      }\n\n    case 'king':\n      {\n        legalMoves = removeProtectedSquares(piece, possibleMoves, board);\n        break;\n      }\n\n    default:\n      {\n        legalMoves = removeObstructedMoves(origin, possibleMoves, obstructions);\n      }\n  }\n\n  return removeMovesWithPieces(legalMoves, board, piece.color);\n}\n\nfunction getLegalMovesInCheck(origin, board, kingPos, squareGivingCheck) {\n  const squaresThatDealWithCheck = getSquaresBetweenKingAndCheck(kingPos, squareGivingCheck, Array.from(board.keys()));\n  const moves = getLegalMoves(origin, board);\n  return moves.filter(s => squaresThatDealWithCheck.includes(s));\n}\n\nfunction getAttackingMoves(origin, board) {\n  // for when you need to check for if squares are protected\n  const square = board.get(origin);\n  const {\n    type,\n    color\n  } = square.piece;\n\n  switch (type) {\n    case 'pawn':\n      {\n        const piece = src_Piece(color, 'pawn');\n        return piece.getPawnCaptures(origin);\n      }\n\n    default:\n      return getLegalMoves(origin, board);\n  }\n}\n\nfunction getAllMovesForColor(color, board) {\n  const allMoves = [];\n\n  for (const [square, {\n    piece\n  }] of board.entries()) {\n    if (!piece) continue;\n    if (piece.color !== color) continue;\n    allMoves.push(getLegalMoves(square, board));\n  }\n\n  return allMoves.flat();\n}\n\nfunction getAttackingMovesForColor(color, board) {\n  const allMoves = [];\n\n  for (const [square, {\n    piece\n  }] of board.entries()) {\n    if (!piece) continue;\n    if (piece.color !== color) continue;\n    allMoves.push(getAttackingMoves(square, board));\n  }\n\n  return allMoves.flat();\n}\n\nfunction getPawnCaptures(pawnSquare, board) {\n  var _a;\n\n  const {\n    color\n  } = (_a = board.get(pawnSquare)) === null || _a === void 0 ? void 0 : _a.piece;\n  const pawn = src_Piece(color, 'pawn');\n  const captureMoves = pawn.getPawnCaptures(pawnSquare);\n  if (!captureMoves) return [];\n  return captureMoves.filter(s => {\n    const squareVal = board.get(s);\n    if (!squareVal) return false;\n    const piece = squareVal.piece;\n    const enPassant = squareVal.enPassant;\n    return piece && piece.color !== pawn.color || enPassant && enPassant.color !== pawn.color;\n  });\n}\n\nfunction getSquaresBetweenKingAndCheck(kingPos, checkPos, allSquares) {\n  // includes kingPos and checkPos\n  const squaresAlongVector = getMovesAlongVector(kingPos, checkPos, allSquares);\n  const squaresBetweenKingAndPiece = removeMovesBehindTwoSquares(kingPos, checkPos, squaresAlongVector);\n  return squaresBetweenKingAndPiece;\n}\n/* filter moves */\n\n\nfunction removeMovesBehindTwoSquares(s1, s2, vector) {\n  const sorted = sortMovesClosestTo(getBeginningOfVector(vector))(vector);\n  let furthestSquare;\n  let closestSquare;\n\n  if (sorted.indexOf(s1) > sorted.indexOf(s2)) {\n    furthestSquare = s1;\n    closestSquare = s2;\n  } else {\n    furthestSquare = s2;\n    closestSquare = s1;\n  }\n\n  const removedOneEnd = removeMovesBehindSquare(furthestSquare)(sorted);\n  const removedBothEnds = removeMovesBehindSquare(closestSquare)(removedOneEnd.reverse());\n  return removedBothEnds;\n}\n\nconst removeMovesBehindSquare = square => moves => {\n  const copy = [...moves];\n  const index = moves.indexOf(square);\n  if (index === -1) return [];\n  copy.splice(index + 1);\n  return copy;\n};\n\nfunction removeObstructedMoves(startingSquare, possibleMoves, obstructions) {\n  // a) split possible moves into vectors (up,down,left,right, and/or diagonals)\n  // b) see which obstructions belong to which vector\n  // c) find the closest obstruction\n  // d) remove all the moves behind that obstruction\n  const filteredMoves = [];\n  const allVectors = splitIntoVectors(possibleMoves, startingSquare);\n  const obstructionVectors = splitIntoVectors(obstructions, startingSquare);\n\n  for (const vector in allVectors) {\n    if (!obstructionVectors[vector]) {\n      // look for vector obstruction is on\n      filteredMoves.push(allVectors[vector]);\n      continue;\n    }\n\n    const sorted = sortMovesClosestTo(startingSquare)(allVectors[vector]);\n    const closestObstruction = sortMovesClosestTo(startingSquare)(obstructionVectors[vector])[0];\n    filteredMoves.push(removeMovesBehindSquare(closestObstruction)(sorted));\n  }\n\n  return filteredMoves.flat();\n}\n\nfunction removeProtectedSquares(king, possibleMoves, board) {\n  // bc king cant move if square is protected\n  const oppColor = king.color === 'white' ? 'black' : 'white';\n  const allEnemyMoves = getAttackingMovesForColor(oppColor, board);\n  return possibleMoves.filter(s => {\n    return !allEnemyMoves.includes(s);\n  });\n}\n\nfunction removeMovesWithPieces(moves, board, color) {\n  return moves.filter(s => {\n    const squareVal = board.get(s);\n    if (!squareVal) return false;\n    if (color) return !squareVal.piece || squareVal.piece.color !== color;else return !squareVal.piece;\n  });\n}\n/* gameboard checks */\n\n\nfunction getDiscoveredCheck(kingPos, kingColor, vacated, board) {\n  var _a; // openSquare is a square just vacated\n\n\n  let squaresAlongVector = getMovesAlongVector(kingPos, vacated, Array.from(board.keys()));\n  squaresAlongVector = squaresAlongVector.filter(s => s !== kingPos && s !== vacated);\n  if (!squaresAlongVector.length) return '';\n\n  for (const square of squaresAlongVector) {\n    const piece = (_a = board.get(square)) === null || _a === void 0 ? void 0 : _a.piece;\n    if (!piece || piece.color === kingColor) continue;\n    const legalMoves = getLegalMoves(square, board);\n    if (legalMoves.includes(kingPos)) return square;\n  }\n\n  return '';\n}\n\nfunction canBlockOrCaptureCheck(kingPos, squareGivingCheck, board) {\n  var _a;\n\n  const king = (_a = board.get(kingPos)) === null || _a === void 0 ? void 0 : _a.piece;\n  const blockOrCaptureSquares = getSquaresBetweenKingAndCheck(kingPos, squareGivingCheck, Array.from(board.keys())); // also includes check square\n\n  const ownPieceMoves = getAllMovesForColor(king.color, board);\n  return ownPieceMoves.some(move => blockOrCaptureSquares.includes(move));\n}\n\n\n;// CONCATENATED MODULE: ./src/ranksAndFiles.ts\nconst files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];\nconst ranks = [1, 2, 3, 4, 5, 6, 7, 8];\n\n;// CONCATENATED MODULE: ./src/Castle.ts\nfunction Castle(whiteKingside, whiteQueenside, blackKingside, blackQueenside) {\n  return {\n    white: {\n      kingside: whiteKingside,\n      queenside: whiteQueenside\n    },\n    black: {\n      kingside: blackKingside,\n      queenside: blackQueenside\n    }\n  };\n}\n;// CONCATENATED MODULE: ./src/Gameboard.ts\n\n\n\n\n\nfunction createBoard() {\n  return files.reduce((acc, file) => {\n    ranks.forEach(rank => {\n      const square = file.concat(rank.toString());\n      acc.set(square, {\n        piece: null\n      });\n    });\n    return acc;\n  }, new Map());\n}\n\nconst Gameboard = (board = createBoard(), squaresGivingCheck, CastleRights) => {\n  function makeMove(s1, s2, promote) {\n    const piece = at(s1).piece;\n    if (!piece) return;\n    if (!validate.move(s1, s2)) return;\n\n    switch (piece.type) {\n      case 'pawn':\n        {\n          // promotion stuff\n          if (promote) {\n            if (!validate.promotion(s1, s2)) return;\n            from(s1).to(s2);\n            at(s2).promote(promote);\n          }\n\n          if (enPassant.checkToggle(s1, s2)) {\n            enPassant.toggle(s2);\n          }\n\n          from(s1).to(s2);\n          break;\n        }\n\n      case 'king':\n        {\n          // check if move is castle\n          let castleSide = '';\n          const castleSquares = get.castleSquares(piece.color);\n\n          for (const [side, squares] of Object.entries(castleSquares)) {\n            if (squares[1] === s2) castleSide = side;\n          }\n\n          if (castleSide) castling.castle(piece.color, castleSide);else from(s1).to(s2);\n          break;\n        }\n\n      default:\n        from(s1).to(s2);\n    }\n\n    enPassant.remove();\n    return board;\n  }\n\n  const castling = {\n    canCastle: (color, side) => {\n      if (CastleRights && !CastleRights[color][side]) return false; // check if rook still exists\n\n      if (!checkIfRookExists()) return false;\n      const oppColor = color === 'white' ? 'black' : 'white';\n      const oppMoves = getAttackingMovesForColor(oppColor, board);\n      const castleSquares = get.castleSquares(color)[side];\n\n      for (const square of castleSquares) {\n        // check if castle square is cleared\n        if (at(square).piece) return false; // make sure castle square isnt attacked\n\n        if (oppMoves.includes(square)) return false;\n      }\n\n      return true;\n\n      function checkIfRookExists() {\n        let rookExists = false;\n        const rank = color === 'white' ? 1 : 8;\n        const loopStart = side === 'queenside' ? files.indexOf('a') : files.indexOf('d');\n        const loopEnd = side === 'queenside' ? files.indexOf('e') : files.indexOf('h');\n\n        for (let i = loopStart; i <= loopEnd; i++) {\n          const square = files[i] + rank;\n          const piece = at(square).piece;\n          if (!piece) continue;\n          if (piece.type === 'rook') rookExists = true;\n        }\n\n        return rookExists;\n      }\n    },\n    castle: (color, side) => {\n      const castleSquares = get.castleSquares(color)[side];\n      const kingPos = get.kingPosition(color);\n      const rookPos = getRookPos();\n      from(rookPos).to(castleSquares[0]);\n      from(kingPos).to(castleSquares[1]);\n\n      function getRookPos() {\n        const pieceMap = get.pieceMap();\n        const rookPos = pieceMap[color].rook.find(square => {\n          const file = square.split('')[0];\n          return side === 'kingside' ? files.indexOf(file) > 3 : files.indexOf(file) < 3;\n        });\n        return rookPos;\n      } // need to get king position\n      // need to get castle squares\n      // need to find rook\n\n    },\n    getRightsAfterMove: square => {\n      const piece = at(square).piece;\n      const castleRights = CastleRights || Castle(true, true, true, true);\n\n      if (castleRights[piece.color].kingside || castleRights[piece.color].queenside) {\n        // check if i need to change castling rights\n        if (piece.type === 'king') {\n          castleRights[piece.color].kingside = false;\n          castleRights[piece.color].queenside = false;\n        }\n\n        if (piece.type === 'rook') {\n          // need to find if it is kingside or queenside rook\n          const [file] = square.split('');\n          const kingside = files.indexOf(file) > 3;\n          if (kingside) castleRights[piece.color].kingside = false;else castleRights[piece.color].queenside = false;\n        }\n      }\n\n      return castleRights;\n    }\n  };\n\n  const enPassant = (() => {\n    function getSquare(current, color) {\n      const {\n        x,\n        y\n      } = toXY(current);\n      const newY = color === 'white' ? y - 1 : y + 1;\n      return fromXY({\n        x,\n        y: newY\n      });\n    }\n\n    return {\n      checkToggle: (from, to) => {\n        const {\n          y: y1\n        } = toXY(from);\n        const {\n          y: y2\n        } = toXY(to);\n        return Math.abs(y1 - y2) === 2;\n      },\n      toggle: current => {\n        const {\n          color\n        } = at(current).piece;\n        const enPassantSquare = getSquare(current, color);\n        at(enPassantSquare).setEnPassant(color, current);\n      },\n      remove: () => {\n        for (const squareObj of board.values()) {\n          if (squareObj.enPassant) return squareObj.enPassant = undefined;\n        }\n      }\n    };\n  })();\n\n  const at = square => ({\n    place: piece => {\n      if (!board.get(square)) return;\n      board.set(square, {\n        piece\n      });\n    },\n    remove: () => {\n      if (!board.get(square)) return;\n      board.set(square, {\n        piece: null\n      });\n    },\n    promote: pieceType => {\n      const squareVal = board.get(square);\n      const piece = squareVal === null || squareVal === void 0 ? void 0 : squareVal.piece;\n      if (!piece) return;\n      board.set(square, Object.assign(Object.assign({}, squareVal), {\n        piece: Object.assign(Object.assign({}, piece), {\n          type: pieceType\n        })\n      }));\n    },\n    setEnPassant: (color, current) => {\n      if (!board.get(square)) return;\n      board.set(square, {\n        piece: null,\n        enPassant: {\n          current\n          /* square pawn is on */\n          ,\n          color: color\n        }\n      });\n    },\n\n    get piece() {\n      var _a;\n\n      return (_a = board.get(square)) === null || _a === void 0 ? void 0 : _a.piece;\n    },\n\n    getLegalMoves: () => {\n      squaresGivingCheck = squaresGivingCheck || [];\n      const {\n        type,\n        color\n      } = at(square).piece;\n\n      switch (squaresGivingCheck.length) {\n        case 2:\n          {\n            if (type !== 'king') return [];\n            return getLegalMoves(square, board);\n          }\n\n        case 1:\n          {\n            return getLegalMovesInCheck(origin, board, get.kingPosition(color), squaresGivingCheck[0]);\n          }\n\n        default:\n          {\n            if (type === 'king') {\n              let legalMoves = getLegalMoves(square, board);\n              if (castling.canCastle(color, 'kingside')) legalMoves = [...legalMoves, ...get.castleSquares(color).kingside];\n              if (castling.canCastle(color, 'queenside')) legalMoves = [...legalMoves, ...get.castleSquares(color).queenside];\n              return legalMoves;\n            } else return getLegalMoves(square, board);\n          }\n      }\n    }\n  });\n\n  const from = s1 => ({\n    to: s2 => {\n      const piece = at(s1).piece;\n      if (!piece) return; // move piece\n\n      at(s1).remove();\n      at(s2).place(piece);\n    }\n  });\n\n  const get = {\n    kingPosition: color => {\n      for (const [square, value] of board.entries()) {\n        if (value.piece && value.piece.type === 'king' && value.piece.color === color) return square;\n      }\n    },\n    pieceMap: () => {\n      const pieceMap = {\n        white: {},\n        black: {}\n      };\n\n      for (const [square, value] of board.entries()) {\n        const {\n          piece\n        } = value;\n        if (!piece) continue;\n        const {\n          type,\n          color\n        } = piece;\n        pieceMap[color][type] = pieceMap[color][type] ? [...pieceMap[color][type], square] : [square];\n      }\n\n      return pieceMap;\n    },\n    squaresGivingCheckAfterMove: (from, end) => {\n      var _a;\n\n      const squaresGivingCheck = [];\n      const piece = (_a = board.get(end)) === null || _a === void 0 ? void 0 : _a.piece;\n      const oppColor = piece.color === 'white' ? 'black' : 'white';\n      const kingPosition = get.kingPosition(oppColor);\n      const pieceHitsKing = getLegalMoves(end, board).includes(kingPosition);\n      if (pieceHitsKing) squaresGivingCheck.push(end);\n      const discoveredCheck = getDiscoveredCheck(kingPosition, oppColor, from, board);\n      if (discoveredCheck) squaresGivingCheck.push(discoveredCheck);\n      return squaresGivingCheck;\n    },\n    isCheckmate: (color, squaresGivingCheck) => {\n      const kingPos = get.kingPosition(color);\n      const legalMoves = at(kingPos).getLegalMoves(); // check if check can be blocked\n\n      if (squaresGivingCheck.length === 1) {\n        if (canBlockOrCaptureCheck(kingPos, squaresGivingCheck[0], board)) return false;\n      }\n\n      if (!legalMoves || !legalMoves.length) return true;\n      return false;\n    },\n\n    castleSquares(color) {\n      const rank = color === 'white' ? 1 : 8;\n      return {\n        kingside: [`f${rank}`, `g${rank}`],\n        queenside: [`d${rank}`, `c${rank}`]\n      };\n    }\n\n  };\n  const validate = {\n    move: (from, to) => {\n      const piece = at(from).piece;\n      if (!piece) return false;\n      if (!at(from).getLegalMoves().includes(to)) return false;\n      return true;\n    },\n    promotion: (from, to) => {\n      const piece = at(from).piece;\n      if ((piece === null || piece === void 0 ? void 0 : piece.type) !== 'pawn') return false;\n      const endOfBoard = piece.color === 'white' ? 8 : 1;\n      const [, rank] = to.split('');\n      if (+rank === endOfBoard) return true;\n      return false;\n    }\n  };\n  return {\n    createBoard,\n    castling,\n    enPassant,\n    at,\n    from,\n    get,\n    validate,\n    makeMove,\n\n    get board() {\n      return board;\n    }\n\n  };\n};\n\n/* harmony default export */ const src_Gameboard = (Gameboard);\n;// CONCATENATED MODULE: ./src/History.ts\n// should output history object that holds move history in 2d array\n// for each move needs to attach piece Type to beginning of move if not pawn\n// should further specify square of piece if, say both rooks, can move to same square\n\nfunction History(prevHistory, board, pieceMap) {\n  const history = prevHistory || [];\n  const get = {\n    piecePrefix: (from, to) => {\n      var _a;\n\n      const {\n        type,\n        color\n      } = (_a = board.get(to)) === null || _a === void 0 ? void 0 : _a.piece;\n\n      switch (type) {\n        case 'pawn':\n          return '';\n\n        case 'knight':\n        case 'rook':\n          {\n            let prefix = type === 'rook' ? 'R' : 'N';\n\n            if (pieceMap[color][type].length !== 1) {\n              // look for piece of same type that couldve also went to the square\n              pieceMap[color][type].forEach(s => {\n                if (s === to) return;\n                const boardCopy = new Map(board);\n                boardCopy.set(to, {\n                  piece: null\n                });\n\n                if (getLegalMoves(s, boardCopy).includes(to)) {\n                  const [x1, y1] = from.split('');\n                  const [x2] = s.split('');\n                  const sameFile = x1 === x2;\n                  prefix = sameFile ? prefix + y1 : prefix + x1;\n                }\n              });\n            }\n\n            return prefix;\n          }\n\n        default:\n          {\n            const prefix = type.charAt(0).toUpperCase();\n            return prefix;\n          }\n      }\n    },\n    castleNotation: side => {\n      return side === 'kingside' ? 'O-O' : 'O-O-O';\n    }\n  };\n  const affix = {\n    capture: (move, prefix) => {\n      return `${prefix}x${move}`;\n    },\n    promote: (move, pieceType) => {\n      const suffix = pieceType === 'knight' ? 'N' : pieceType.charAt(0).toUpperCase();\n      return `${move}=${suffix}`;\n    },\n    check: notation => {\n      return `${notation}+`;\n    },\n    checkmate: notation => {\n      return `${notation}#`;\n    }\n  };\n  return {\n    get,\n    affix,\n    insertMove: notation => {\n      const lastMovePair = history[history.length - 1];\n\n      if (lastMovePair.length === 1) {\n        lastMovePair.push(notation);\n      } else {\n        const newMovePair = [notation];\n        history.push(newMovePair);\n      }\n    }\n  };\n}\n;// CONCATENATED MODULE: ./src/startingPositions.ts\nconst standard = {\n  white: {\n    rook: ['a1', 'h1'],\n    knight: ['g1', 'b1'],\n    bishop: ['f1', 'c1'],\n    king: ['e1'],\n    queen: ['d1'],\n    pawn: ['a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2']\n  },\n  black: {\n    rook: ['a8', 'h8'],\n    knight: ['g8', 'b8'],\n    bishop: ['f8', 'c8'],\n    king: ['e8'],\n    queen: ['d8'],\n    pawn: ['a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7']\n  }\n};\n\n;// CONCATENATED MODULE: ./src/main.ts\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LElBQVAsQ0FERDtBQUVMdUMsVUFBTSxFQUFFLENBQUMsSUFBRCxFQUFPLElBQVAsQ0FGSDtBQUdMQyxVQUFNLEVBQUUsQ0FBQyxJQUFELEVBQU8sSUFBUCxDQUhIO0FBSUxqRyxRQUFJLEVBQUUsQ0FBQyxJQUFELENBSkQ7QUFLTGtHLFNBQUssRUFBRSxDQUFDLElBQUQsQ0FMRjtBQU1MeEgsUUFBSSxFQUFFLENBQUMsSUFBRCxFQUFPLElBQVAsRUFBYSxJQUFiLEVBQW1CLElBQW5CLEVBQXlCLElBQXpCLEVBQStCLElBQS9CLEVBQXFDLElBQXJDLEVBQTJDLElBQTNDO0FBTkQsR0FEcUI7QUFTNUIyQyxPQUFLLEVBQUU7QUFDTG9DLFFBQUksRUFBRSxDQUFDLElBQUQsRUFBTyxJQUFQLENBREQ7QUFFTHVDLFVBQU0sRUFBRSxDQUFDLElBQUQsRUFBTyxJQUFQLENBRkg7QUFHTEMsVUFBTSxFQUFFLENBQUMsSUFBRCxFQUFPLElBQVAsQ0FISDtBQUlMakcsUUFBSSxFQUFFLENBQUMsSUFBRCxDQUpEO0FBS0xrRyxTQUFLLEVBQUUsQ0FBQyxJQUFELENBTEY7QUFNTHhILFFBQUksRUFBRSxDQUFDLElBQUQsRUFBTyxJQUFQLEVBQWEsSUFBYixFQUFtQixJQUFuQixFQUF5QixJQUF6QixFQUErQixJQUEvQixFQUFxQyxJQUFyQyxFQUEyQyxJQUEzQztBQU5EO0FBVHFCLENBQTlCOzs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3JvQ2hlc3MvLi9zcmMvdXRpbHMvaGVscGVycy50cz8yOGYzIiwid2VicGFjazovL2Nyb0NoZXNzLy4vc3JjL1BpZWNlLnRzPzJlYjgiLCJ3ZWJwYWNrOi8vY3JvQ2hlc3MvLi9zcmMvdXRpbHMvbW92ZXMudHM/NTBmYiIsIndlYnBhY2s6Ly9jcm9DaGVzcy8uL3NyYy9yYW5rc0FuZEZpbGVzLnRzP2U2MjEiLCJ3ZWJwYWNrOi8vY3JvQ2hlc3MvLi9zcmMvQ2FzdGxlLnRzPzFjZWEiLCJ3ZWJwYWNrOi8vY3JvQ2hlc3MvLi9zcmMvR2FtZWJvYXJkLnRzPzU3ZTMiLCJ3ZWJwYWNrOi8vY3JvQ2hlc3MvLi9zcmMvSGlzdG9yeS50cz80YzIxIiwid2VicGFjazovL2Nyb0NoZXNzLy4vc3JjL3N0YXJ0aW5nUG9zaXRpb25zLnRzPzNiYmMiLCJ3ZWJwYWNrOi8vY3JvQ2hlc3MvLi9zcmMvbWFpbi50cz9jZDQ5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvb3JkIH0gZnJvbSAnLi4vdHlwZXMvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBTcXVhcmUgfSBmcm9tICcuLi90eXBlcy90eXBlcyc7XG5cbmZ1bmN0aW9uIHRvWFkoc3F1YXJlOiBTcXVhcmUpOiBDb29yZCB7XG4gIGNvbnN0IFt4LCB5XSA9IHNxdWFyZS5zcGxpdCgnJyk7XG4gIHJldHVybiB7XG4gICAgeDogWydhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJywgJ2gnXS5pbmRleE9mKHgudG9Mb3dlckNhc2UoKSksXG4gICAgeTogTnVtYmVyKHkpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGZyb21YWShjb29yZDogQ29vcmQpOiBTcXVhcmUge1xuICBjb25zdCB7IHgsIHkgfSA9IGNvb3JkO1xuICBjb25zdCBjb2wgPSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJywgJ2cnLCAnaCddW3hdO1xuICBpZiAoIWNvbCkgcmV0dXJuICcnO1xuICByZXR1cm4gY29sLmNvbmNhdCh5LnRvU3RyaW5nKCkpO1xufVxuXG5jb25zdCBjYWxjRGlzdGFuY2UgPSAoc3F1YXJlT25lOiBzdHJpbmcpID0+IChzcXVhcmVUd286IHN0cmluZykgPT4ge1xuICBjb25zdCB7IHg6IHgxLCB5OiB5MSB9ID0gdG9YWShzcXVhcmVPbmUpO1xuICBjb25zdCB7IHg6IHgyLCB5OiB5MiB9ID0gdG9YWShzcXVhcmVUd28pO1xuXG4gIGNvbnN0IHhEaWZmID0geDEgLSB4MjtcbiAgY29uc3QgeURpZmYgPSB5MSAtIHkyO1xuICByZXR1cm4ge1xuICAgIHhEaWZmLFxuICAgIHlEaWZmXG4gIH07XG59O1xuXG5leHBvcnQgeyB0b1hZLCBmcm9tWFksIGNhbGNEaXN0YW5jZSB9O1xuIiwiaW1wb3J0IG1vdmVzIGZyb20gJy4vdXRpbHMvbW92ZXMnO1xuaW1wb3J0IHsgdG9YWSwgZnJvbVhZIH0gZnJvbSAnLi91dGlscy9oZWxwZXJzJztcblxuaW1wb3J0IHsgQ29sb3IsIFNxdWFyZSwgUGllY2VUeXBlIH0gZnJvbSAnLi90eXBlcy90eXBlcyc7XG5cbmNvbnN0IFBpZWNlID0gKGNvbG9yOiBDb2xvciwgdHlwZTogUGllY2VUeXBlKSA9PiB7XG4gIGZ1bmN0aW9uIGhhc01vdmUoZnJvbTogU3F1YXJlLCB0bzogU3F1YXJlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdraW5nJzoge1xuICAgICAgICBjb25zdCBvbmVTcXVhcmVWZXJ0ID1cbiAgICAgICAgICBtb3Zlcy55QnlOKDEpKGZyb20pKHRvKSAmJiBtb3Zlcy54QnlOKDApKGZyb20pKHRvKTtcbiAgICAgICAgY29uc3Qgb25lU3F1YXJlTGF0ZXJhbCA9XG4gICAgICAgICAgbW92ZXMueEJ5TigxKShmcm9tKSh0bykgJiYgbW92ZXMueUJ5TigwKShmcm9tKSh0byk7XG4gICAgICAgIGNvbnN0IG9uZVNxdWFyZURpYWdvbmFsbHkgPVxuICAgICAgICAgIG1vdmVzLnlCeU4oMSkoZnJvbSkodG8pICYmIG1vdmVzLnhCeU4oMSkoZnJvbSkodG8pO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgZnJvbSAhPT0gdG8gJiZcbiAgICAgICAgICAob25lU3F1YXJlRGlhZ29uYWxseSB8fCBvbmVTcXVhcmVWZXJ0IHx8IG9uZVNxdWFyZUxhdGVyYWwpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjYXNlICdxdWVlbic6IHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBmcm9tICE9PSB0byAmJlxuICAgICAgICAgIChtb3Zlcy5kaWFnb25hbChmcm9tKSh0bykgfHwgbW92ZXMudmVydEFuZExhdGVyYWwoZnJvbSkodG8pKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2FzZSAnYmlzaG9wJzoge1xuICAgICAgICByZXR1cm4gZnJvbSAhPT0gdG8gJiYgbW92ZXMuZGlhZ29uYWwoZnJvbSkodG8pO1xuICAgICAgfVxuICAgICAgY2FzZSAna25pZ2h0Jzoge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGZyb20gIT09IHRvICYmXG4gICAgICAgICAgKChtb3Zlcy54QnlOKDEpKGZyb20pKHRvKSAmJiBtb3Zlcy55QnlOKDIpKGZyb20pKHRvKSkgfHxcbiAgICAgICAgICAgIChtb3Zlcy54QnlOKDIpKGZyb20pKHRvKSAmJiBtb3Zlcy55QnlOKDEpKGZyb20pKHRvKSkpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjYXNlICdyb29rJzoge1xuICAgICAgICByZXR1cm4gZnJvbSAhPT0gdG8gJiYgbW92ZXMudmVydEFuZExhdGVyYWwodG8pKGZyb20pO1xuICAgICAgfVxuICAgICAgY2FzZSAncGF3bic6IHtcbiAgICAgICAgY29uc3QgeyB4OiB4MSwgeTogeTEgfSA9IHRvWFkoZnJvbSk7XG4gICAgICAgIGNvbnN0IHsgeDogeDIsIHk6IHkyIH0gPSB0b1hZKHRvKTtcblxuICAgICAgICBjb25zdCBvbmx5TW92ZXNJbkZyb250ID0gY29sb3IgPT09ICd3aGl0ZScgPyB5MSA8IHkyIDogeTEgPiB5MjtcbiAgICAgICAgY29uc3QgcmVndWxhck1vdmUgPSBtb3Zlcy55QnlOKDEpKGZyb20pKHRvKSAmJiB4MSA9PT0geDI7XG5cbiAgICAgICAgY29uc3QgZmlyc3RNb3ZlID0gY29sb3IgPT09ICd3aGl0ZScgPyB5MSA9PT0gMiA6IHkxID09PSA3O1xuICAgICAgICBjb25zdCBqdW1wVHdvID0gbW92ZXMueUJ5TigyKShmcm9tKSh0bykgJiYgeDEgPT09IHgyO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgZnJvbSAhPT0gdG8gJiZcbiAgICAgICAgICBvbmx5TW92ZXNJbkZyb250ICYmXG4gICAgICAgICAgKHJlZ3VsYXJNb3ZlIHx8IChmaXJzdE1vdmUgJiYganVtcFR3bykpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UGF3bkNhcHR1cmVzKG9yaWdpbjogU3F1YXJlKSB7XG4gICAgaWYgKHR5cGUgIT09ICdwYXduJykgcmV0dXJuO1xuXG4gICAgY29uc3QgeyB4LCB5IH0gPSB0b1hZKG9yaWdpbik7XG5cbiAgICBjb25zdCBuZXdZID0gY29sb3IgPT09ICd3aGl0ZScgPyB5ICsgMSA6IHkgLSAxO1xuXG4gICAgY29uc3QgY2FwdHVyZU9uZSA9IHsgeDogeCArIDEsIHk6IG5ld1kgfTtcbiAgICBjb25zdCBjYXB0dXJlVHdvID0geyB4OiB4IC0gMSwgeTogbmV3WSB9O1xuXG4gICAgcmV0dXJuIFtmcm9tWFkoY2FwdHVyZU9uZSksIGZyb21YWShjYXB0dXJlVHdvKV07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGhhc01vdmUsXG4gICAgZ2V0UGF3bkNhcHR1cmVzLFxuICAgIGdldCB0eXBlKCkge1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfSxcbiAgICBnZXQgY29sb3IoKSB7XG4gICAgICByZXR1cm4gY29sb3I7XG4gICAgfVxuICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgUGllY2U7XG4iLCJpbXBvcnQgeyBjYWxjRGlzdGFuY2UsIHRvWFkgfSBmcm9tICcuL2hlbHBlcnMnO1xuaW1wb3J0IHtcbiAgUGllY2VJbnRlcmZhY2UsXG4gIFNxdWFyZU9iaixcbiAgUGllY2VPYmosXG4gIEVuUGFzc2FudE9ialxufSBmcm9tICcuLi90eXBlcy9pbnRlcmZhY2VzJztcbmltcG9ydCB7IE1vdmVzLCBCb2FyZCwgU3F1YXJlLCBDb2xvciB9IGZyb20gJy4uL3R5cGVzL3R5cGVzJztcbmltcG9ydCBQaWVjZSBmcm9tICcuLi9QaWVjZSc7XG5cbmNvbnN0IG1vdmVzID0ge1xuICB2ZXJ0QW5kTGF0ZXJhbDogKGZyb206IFNxdWFyZSkgPT4gKHRvOiBTcXVhcmUpID0+IHtcbiAgICBjb25zdCBbeDEsIHkxXSA9IGZyb20uc3BsaXQoJycpO1xuICAgIGNvbnN0IFt4MiwgeTJdID0gdG8uc3BsaXQoJycpO1xuICAgIHJldHVybiB4MSA9PT0geDIgfHwgeTEgPT09IHkyO1xuICB9LFxuICBkaWFnb25hbDogKGZyb206IFNxdWFyZSkgPT4gKHRvOiBTcXVhcmUpID0+IHtcbiAgICBjb25zdCB7IHg6IHgxLCB5OiB5MSB9ID0gdG9YWShmcm9tKTtcbiAgICBjb25zdCB7IHg6IHgyLCB5OiB5MiB9ID0gdG9YWSh0byk7XG4gICAgcmV0dXJuIE1hdGguYWJzKHgyIC0geDEpID09PSBNYXRoLmFicyh5MiAtIHkxKTtcbiAgfSxcbiAgeEJ5TjogKG51bTogbnVtYmVyKSA9PiAoZnJvbTogU3F1YXJlKSA9PiAodG86IFNxdWFyZSkgPT4ge1xuICAgIGNvbnN0IHsgeDogeDEgfSA9IHRvWFkoZnJvbSk7XG4gICAgY29uc3QgeyB4OiB4MiB9ID0gdG9YWSh0byk7XG4gICAgcmV0dXJuIE1hdGguYWJzKHgxIC0geDIpID09PSBudW07XG4gIH0sXG4gIHlCeU46IChudW06IG51bWJlcikgPT4gKGZyb206IFNxdWFyZSkgPT4gKHRvOiBTcXVhcmUpID0+IHtcbiAgICBjb25zdCB7IHk6IHkxIH0gPSB0b1hZKGZyb20pO1xuICAgIGNvbnN0IHsgeTogeTIgfSA9IHRvWFkodG8pO1xuICAgIHJldHVybiBNYXRoLmFicyh5MSAtIHkyKSA9PT0gbnVtO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBtb3ZlcztcblxuLyogZGVhbGluZyB3aXRoIG1vdmUgdmVjdG9ycyAqL1xuXG5mdW5jdGlvbiBzcGxpdEludG9WZWN0b3JzKGFycmF5T2ZNb3ZlczogTW92ZXMsIHN0YXJ0OiBTcXVhcmUpIHtcbiAgaW50ZXJmYWNlIFZlY3RvcnMge1xuICAgIFtrZXk6IHN0cmluZ106IHN0cmluZ1tdO1xuICB9XG4gIHJldHVybiBhcnJheU9mTW92ZXMucmVkdWNlKChhY2M6IFZlY3RvcnMsIGN1cnI6IFNxdWFyZSkgPT4ge1xuICAgIGNvbnN0IHsgeERpZmYsIHlEaWZmIH0gPSBjYWxjRGlzdGFuY2Uoc3RhcnQpKGN1cnIpO1xuXG4gICAgbGV0IHZlY3RvciA9ICcnO1xuICAgIGlmICh5RGlmZiAhPT0gMCkgdmVjdG9yID0geURpZmYgPCAwID8gJ3VwJyA6ICdkb3duJztcbiAgICBpZiAoeERpZmYgIT09IDApIHZlY3RvciArPSB4RGlmZiA8IDAgPyAnUmlnaHQnIDogJ0xlZnQnO1xuXG4gICAgLy8gbm9ybWFsaXplIHZlY3RvciBuYW1lXG4gICAgdmVjdG9yID0gdmVjdG9yLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgdmVjdG9yLnNsaWNlKDEpO1xuXG4gICAgYWNjW3ZlY3Rvcl0gPSBhY2NbdmVjdG9yXSB8fCBbXTtcbiAgICBhY2NbdmVjdG9yXS5wdXNoKGN1cnIpO1xuXG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufVxuXG5mdW5jdGlvbiBnZXRCZWdpbm5pbmdPZlZlY3Rvcih2ZWN0b3I6IE1vdmVzKSB7XG4gIGlmICh2ZWN0b3IubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG5cbiAgcmV0dXJuIHZlY3Rvci5yZWR1Y2UoKGFjYywgY3VycikgPT4ge1xuICAgIGNvbnN0IHsgeDogeDEsIHk6IHkxIH0gPSB0b1hZKGFjYyk7XG4gICAgY29uc3QgeyB4OiB4MiwgeTogeTIgfSA9IHRvWFkoY3Vycik7XG5cbiAgICBjb25zdCBhY2NJc0JlZ2lubmluZyA9IHgxID09PSB4MiA/IHkxIDwgeTIgOiB4MSA8IHgyO1xuICAgIHJldHVybiBhY2NJc0JlZ2lubmluZyA/IGFjYyA6IGN1cnI7XG4gIH0pO1xufVxuXG5jb25zdCBnZXRNb3Zlc0Fsb25nVmVjdG9yID0gKFxuICBzMTogU3F1YXJlLFxuICBzMjogU3F1YXJlLFxuICBhbGxTcXVhcmVzOiBNb3Zlc1xuKTogTW92ZXMgPT4ge1xuICBjb25zdCBsaWVzU2FtZVZlcnRPckxhdCA9IG1vdmVzLnZlcnRBbmRMYXRlcmFsKHMxKShzMik7XG4gIGNvbnN0IGxpZXNTYW1lRGlhZ29uYWxseSA9IG1vdmVzLmRpYWdvbmFsKHMxKShzMik7XG5cbiAgY29uc3QgbGllc09uU2FtZUxpbmUgPSBsaWVzU2FtZVZlcnRPckxhdCB8fCBsaWVzU2FtZURpYWdvbmFsbHk7XG4gIGlmICghbGllc09uU2FtZUxpbmUpIHJldHVybiBbXTtcblxuICBjb25zdCBtYXRjaGluZ1ZlY3RvciA9IGxpZXNTYW1lRGlhZ29uYWxseSA/ICdkaWFnb25hbCcgOiAndmVydEFuZExhdGVyYWwnO1xuXG4gIGNvbnN0IHNxdWFyZXNBbG9uZ1ZlY3RvciA9IGFsbFNxdWFyZXMuZmlsdGVyKFxuICAgIChzKSA9PiBtb3Zlc1ttYXRjaGluZ1ZlY3Rvcl0oczEpKHMpICYmIG1vdmVzW21hdGNoaW5nVmVjdG9yXShzMikocylcbiAgKTtcbiAgcmV0dXJuIHNxdWFyZXNBbG9uZ1ZlY3Rvcjtcbn07XG5cbi8qIHNvcnQgbW92ZXMgKi9cblxuY29uc3Qgc29ydE1vdmVzQ2xvc2VzdFRvID1cbiAgKHNxdWFyZTogU3F1YXJlKSA9PlxuICAobW92ZXM6IE1vdmVzKTogTW92ZXMgPT4ge1xuICAgIHJldHVybiBbLi4ubW92ZXNdLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGNvbnN0IHsgeERpZmY6IHgxRGlmZiwgeURpZmY6IHkxRGlmZiB9ID0gY2FsY0Rpc3RhbmNlKHNxdWFyZSkoYSk7XG4gICAgICBjb25zdCBhRGlmZiA9IE1hdGguYWJzKHgxRGlmZikgKyBNYXRoLmFicyh5MURpZmYpO1xuXG4gICAgICBjb25zdCB7IHhEaWZmOiB4MkRpZmYsIHlEaWZmOiB5MkRpZmYgfSA9IGNhbGNEaXN0YW5jZShzcXVhcmUpKGIpO1xuICAgICAgY29uc3QgYkRpZmYgPSBNYXRoLmFicyh4MkRpZmYpICsgTWF0aC5hYnMoeTJEaWZmKTtcblxuICAgICAgcmV0dXJuIGFEaWZmIC0gYkRpZmY7XG4gICAgfSk7XG4gIH07XG5cbi8qIGdldCBtb3ZlcyAqL1xuXG5mdW5jdGlvbiBnZXRQb3NzaWJsZU1vdmVzKG9yaWdpbjogU3F1YXJlLCBib2FyZDogQm9hcmQpIHtcbiAgLy8gZ2V0IGFsbCBtb3ZlcyB0aGF0IGNhbiBoYXBwZW4gaWYgbm8gb3RoZXIgcGllY2VzIHdlcmUgb24gdGhlIGJvYXJkXG4gIGNvbnN0IGFsbFNxdWFyZXMgPSBBcnJheS5mcm9tKGJvYXJkLmtleXMoKSk7XG5cbiAgY29uc3Qgc3F1YXJlID0gYm9hcmQuZ2V0KG9yaWdpbikgYXMgU3F1YXJlT2JqO1xuXG4gIGNvbnN0IHsgdHlwZSwgY29sb3IgfSA9IHNxdWFyZS5waWVjZSBhcyBQaWVjZU9iajtcbiAgY29uc3QgcGllY2UgPSBQaWVjZShjb2xvciwgdHlwZSk7XG5cbiAgcmV0dXJuIGFsbFNxdWFyZXMuZmlsdGVyKChzKSA9PiBwaWVjZS5oYXNNb3ZlKG9yaWdpbiwgcykpO1xufVxuXG5mdW5jdGlvbiBnZXRMZWdhbE1vdmVzKG9yaWdpbjogU3F1YXJlLCBib2FyZDogQm9hcmQpIHtcbiAgLy8gZ2V0IG1vdmVzIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciBvciBub3QgdGhlcmUgaXMgY2hlY2tcblxuICBjb25zdCBzcXVhcmUgPSBib2FyZC5nZXQob3JpZ2luKSBhcyBTcXVhcmVPYmo7XG5cbiAgY29uc3QgcGllY2UgPSBzcXVhcmUucGllY2UgYXMgUGllY2VPYmo7XG5cbiAgY29uc3QgcG9zc2libGVNb3ZlcyA9IGdldFBvc3NpYmxlTW92ZXMob3JpZ2luLCBib2FyZCk7XG5cbiAgY29uc3Qgb2JzdHJ1Y3Rpb25zID0gcG9zc2libGVNb3Zlcy5maWx0ZXIoKHMpID0+IGJvYXJkLmdldChzKT8ucGllY2UpO1xuICBpZiAoIW9ic3RydWN0aW9ucy5sZW5ndGgpIHtcbiAgICBpZiAocGllY2UudHlwZSA9PT0gJ3Bhd24nKVxuICAgICAgcmV0dXJuIFsuLi5nZXRQYXduQ2FwdHVyZXMob3JpZ2luLCBib2FyZCksIC4uLnBvc3NpYmxlTW92ZXNdO1xuICAgIHJldHVybiBwb3NzaWJsZU1vdmVzO1xuICB9XG5cbiAgbGV0IGxlZ2FsTW92ZXM6IE1vdmVzID0gW107XG4gIHN3aXRjaCAocGllY2UudHlwZSkge1xuICAgIGNhc2UgJ2tuaWdodCc6IHtcbiAgICAgIGxlZ2FsTW92ZXMgPSBwb3NzaWJsZU1vdmVzO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgJ3Bhd24nOiB7XG4gICAgICBjb25zdCBjYXB0dXJlc0F2YWlsYWJsZSA9IGdldFBhd25DYXB0dXJlcyhvcmlnaW4sIGJvYXJkKTtcbiAgICAgIGNvbnN0IHVub2JzdHJ1Y3RlZE1vdmVzID0gcmVtb3ZlTW92ZXNXaXRoUGllY2VzKFxuICAgICAgICByZW1vdmVPYnN0cnVjdGVkTW92ZXMob3JpZ2luLCBwb3NzaWJsZU1vdmVzLCBvYnN0cnVjdGlvbnMpLFxuICAgICAgICBib2FyZFxuICAgICAgKTtcbiAgICAgIGxlZ2FsTW92ZXMgPSBbLi4uY2FwdHVyZXNBdmFpbGFibGUsIC4uLnVub2JzdHJ1Y3RlZE1vdmVzXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlICdraW5nJzoge1xuICAgICAgbGVnYWxNb3ZlcyA9IHJlbW92ZVByb3RlY3RlZFNxdWFyZXMocGllY2UsIHBvc3NpYmxlTW92ZXMsIGJvYXJkKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBsZWdhbE1vdmVzID0gcmVtb3ZlT2JzdHJ1Y3RlZE1vdmVzKG9yaWdpbiwgcG9zc2libGVNb3Zlcywgb2JzdHJ1Y3Rpb25zKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVtb3ZlTW92ZXNXaXRoUGllY2VzKGxlZ2FsTW92ZXMsIGJvYXJkLCBwaWVjZS5jb2xvcik7XG59XG5cbmZ1bmN0aW9uIGdldExlZ2FsTW92ZXNJbkNoZWNrKFxuICBvcmlnaW46IFNxdWFyZSxcbiAgYm9hcmQ6IEJvYXJkLFxuICBraW5nUG9zOiBTcXVhcmUsXG4gIHNxdWFyZUdpdmluZ0NoZWNrOiBTcXVhcmVcbikge1xuICBjb25zdCBzcXVhcmVzVGhhdERlYWxXaXRoQ2hlY2sgPSBnZXRTcXVhcmVzQmV0d2VlbktpbmdBbmRDaGVjayhcbiAgICBraW5nUG9zLFxuICAgIHNxdWFyZUdpdmluZ0NoZWNrLFxuICAgIEFycmF5LmZyb20oYm9hcmQua2V5cygpKVxuICApO1xuXG4gIGNvbnN0IG1vdmVzID0gZ2V0TGVnYWxNb3ZlcyhvcmlnaW4sIGJvYXJkKTtcblxuICByZXR1cm4gbW92ZXMuZmlsdGVyKChzKSA9PiBzcXVhcmVzVGhhdERlYWxXaXRoQ2hlY2suaW5jbHVkZXMocykpO1xufVxuXG5mdW5jdGlvbiBnZXRBdHRhY2tpbmdNb3ZlcyhvcmlnaW46IFNxdWFyZSwgYm9hcmQ6IEJvYXJkKSB7XG4gIC8vIGZvciB3aGVuIHlvdSBuZWVkIHRvIGNoZWNrIGZvciBpZiBzcXVhcmVzIGFyZSBwcm90ZWN0ZWRcbiAgY29uc3Qgc3F1YXJlID0gYm9hcmQuZ2V0KG9yaWdpbikgYXMgU3F1YXJlT2JqO1xuXG4gIGNvbnN0IHsgdHlwZSwgY29sb3IgfSA9IHNxdWFyZS5waWVjZSBhcyBQaWVjZU9iajtcblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdwYXduJzoge1xuICAgICAgY29uc3QgcGllY2UgPSBQaWVjZShjb2xvciwgJ3Bhd24nKTtcbiAgICAgIHJldHVybiBwaWVjZS5nZXRQYXduQ2FwdHVyZXMob3JpZ2luKSBhcyBNb3ZlcztcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBnZXRMZWdhbE1vdmVzKG9yaWdpbiwgYm9hcmQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEFsbE1vdmVzRm9yQ29sb3IoY29sb3I6IENvbG9yLCBib2FyZDogQm9hcmQpOiBNb3ZlcyB7XG4gIGNvbnN0IGFsbE1vdmVzOiBNb3Zlc1tdID0gW107XG4gIGZvciAoY29uc3QgW3NxdWFyZSwgeyBwaWVjZSB9XSBvZiBib2FyZC5lbnRyaWVzKCkpIHtcbiAgICBpZiAoIXBpZWNlKSBjb250aW51ZTtcbiAgICBpZiAocGllY2UuY29sb3IgIT09IGNvbG9yKSBjb250aW51ZTtcblxuICAgIGFsbE1vdmVzLnB1c2goZ2V0TGVnYWxNb3ZlcyhzcXVhcmUsIGJvYXJkKSk7XG4gIH1cblxuICByZXR1cm4gYWxsTW92ZXMuZmxhdCgpO1xufVxuXG5mdW5jdGlvbiBnZXRBdHRhY2tpbmdNb3Zlc0ZvckNvbG9yKGNvbG9yOiBDb2xvciwgYm9hcmQ6IEJvYXJkKTogTW92ZXMge1xuICBjb25zdCBhbGxNb3ZlczogTW92ZXNbXSA9IFtdO1xuICBmb3IgKGNvbnN0IFtzcXVhcmUsIHsgcGllY2UgfV0gb2YgYm9hcmQuZW50cmllcygpKSB7XG4gICAgaWYgKCFwaWVjZSkgY29udGludWU7XG4gICAgaWYgKHBpZWNlLmNvbG9yICE9PSBjb2xvcikgY29udGludWU7XG5cbiAgICBhbGxNb3Zlcy5wdXNoKGdldEF0dGFja2luZ01vdmVzKHNxdWFyZSwgYm9hcmQpKTtcbiAgfVxuXG4gIHJldHVybiBhbGxNb3Zlcy5mbGF0KCk7XG59XG5cbmZ1bmN0aW9uIGdldFBhd25DYXB0dXJlcyhwYXduU3F1YXJlOiBTcXVhcmUsIGJvYXJkOiBCb2FyZCkge1xuICBjb25zdCB7IGNvbG9yIH0gPSBib2FyZC5nZXQocGF3blNxdWFyZSk/LnBpZWNlIGFzIFBpZWNlT2JqO1xuICBjb25zdCBwYXduID0gUGllY2UoY29sb3IsICdwYXduJyk7XG5cbiAgY29uc3QgY2FwdHVyZU1vdmVzID0gcGF3bi5nZXRQYXduQ2FwdHVyZXMocGF3blNxdWFyZSk7XG4gIGlmICghY2FwdHVyZU1vdmVzKSByZXR1cm4gW107XG5cbiAgcmV0dXJuIGNhcHR1cmVNb3Zlcy5maWx0ZXIoKHMpID0+IHtcbiAgICBjb25zdCBzcXVhcmVWYWwgPSBib2FyZC5nZXQocyk7XG4gICAgaWYgKCFzcXVhcmVWYWwpIHJldHVybiBmYWxzZTtcblxuICAgIGNvbnN0IHBpZWNlID0gc3F1YXJlVmFsLnBpZWNlO1xuICAgIGNvbnN0IGVuUGFzc2FudDogRW5QYXNzYW50T2JqIHwgdW5kZWZpbmVkID0gc3F1YXJlVmFsLmVuUGFzc2FudDtcblxuICAgIHJldHVybiAoXG4gICAgICAocGllY2UgJiYgcGllY2UuY29sb3IgIT09IHBhd24uY29sb3IpIHx8XG4gICAgICAoZW5QYXNzYW50ICYmIGVuUGFzc2FudC5jb2xvciAhPT0gcGF3bi5jb2xvcilcbiAgICApO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0U3F1YXJlc0JldHdlZW5LaW5nQW5kQ2hlY2soXG4gIGtpbmdQb3M6IFNxdWFyZSxcbiAgY2hlY2tQb3M6IFNxdWFyZSxcbiAgYWxsU3F1YXJlczogTW92ZXNcbikge1xuICAvLyBpbmNsdWRlcyBraW5nUG9zIGFuZCBjaGVja1Bvc1xuICBjb25zdCBzcXVhcmVzQWxvbmdWZWN0b3IgPSBnZXRNb3Zlc0Fsb25nVmVjdG9yKGtpbmdQb3MsIGNoZWNrUG9zLCBhbGxTcXVhcmVzKTtcbiAgY29uc3Qgc3F1YXJlc0JldHdlZW5LaW5nQW5kUGllY2UgPSByZW1vdmVNb3Zlc0JlaGluZFR3b1NxdWFyZXMoXG4gICAga2luZ1BvcyxcbiAgICBjaGVja1BvcyxcbiAgICBzcXVhcmVzQWxvbmdWZWN0b3JcbiAgKTtcbiAgcmV0dXJuIHNxdWFyZXNCZXR3ZWVuS2luZ0FuZFBpZWNlO1xufVxuXG4vKiBmaWx0ZXIgbW92ZXMgKi9cblxuZnVuY3Rpb24gcmVtb3ZlTW92ZXNCZWhpbmRUd29TcXVhcmVzKFxuICBzMTogU3F1YXJlLFxuICBzMjogU3F1YXJlLFxuICB2ZWN0b3I6IE1vdmVzXG4pOiBNb3ZlcyB7XG4gIGNvbnN0IHNvcnRlZCA9IHNvcnRNb3Zlc0Nsb3Nlc3RUbyhnZXRCZWdpbm5pbmdPZlZlY3Rvcih2ZWN0b3IpKSh2ZWN0b3IpO1xuICBsZXQgZnVydGhlc3RTcXVhcmU7XG4gIGxldCBjbG9zZXN0U3F1YXJlO1xuXG4gIGlmIChzb3J0ZWQuaW5kZXhPZihzMSkgPiBzb3J0ZWQuaW5kZXhPZihzMikpIHtcbiAgICBmdXJ0aGVzdFNxdWFyZSA9IHMxO1xuICAgIGNsb3Nlc3RTcXVhcmUgPSBzMjtcbiAgfSBlbHNlIHtcbiAgICBmdXJ0aGVzdFNxdWFyZSA9IHMyO1xuICAgIGNsb3Nlc3RTcXVhcmUgPSBzMTtcbiAgfVxuICBjb25zdCByZW1vdmVkT25lRW5kID0gcmVtb3ZlTW92ZXNCZWhpbmRTcXVhcmUoZnVydGhlc3RTcXVhcmUpKHNvcnRlZCk7XG4gIGNvbnN0IHJlbW92ZWRCb3RoRW5kcyA9IHJlbW92ZU1vdmVzQmVoaW5kU3F1YXJlKGNsb3Nlc3RTcXVhcmUpKFxuICAgIHJlbW92ZWRPbmVFbmQucmV2ZXJzZSgpXG4gICk7XG5cbiAgcmV0dXJuIHJlbW92ZWRCb3RoRW5kcztcbn1cblxuY29uc3QgcmVtb3ZlTW92ZXNCZWhpbmRTcXVhcmUgPVxuICAoc3F1YXJlOiBTcXVhcmUpID0+XG4gIChtb3ZlczogTW92ZXMpOiBNb3ZlcyA9PiB7XG4gICAgY29uc3QgY29weSA9IFsuLi5tb3Zlc107XG4gICAgY29uc3QgaW5kZXggPSBtb3Zlcy5pbmRleE9mKHNxdWFyZSk7XG5cbiAgICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gW107XG5cbiAgICBjb3B5LnNwbGljZShpbmRleCArIDEpO1xuXG4gICAgcmV0dXJuIGNvcHk7XG4gIH07XG5cbmZ1bmN0aW9uIHJlbW92ZU9ic3RydWN0ZWRNb3ZlcyhcbiAgc3RhcnRpbmdTcXVhcmU6IFNxdWFyZSxcbiAgcG9zc2libGVNb3ZlczogTW92ZXMsXG4gIG9ic3RydWN0aW9uczogTW92ZXNcbik6IE1vdmVzIHtcbiAgLy8gYSkgc3BsaXQgcG9zc2libGUgbW92ZXMgaW50byB2ZWN0b3JzICh1cCxkb3duLGxlZnQscmlnaHQsIGFuZC9vciBkaWFnb25hbHMpXG4gIC8vIGIpIHNlZSB3aGljaCBvYnN0cnVjdGlvbnMgYmVsb25nIHRvIHdoaWNoIHZlY3RvclxuICAvLyBjKSBmaW5kIHRoZSBjbG9zZXN0IG9ic3RydWN0aW9uXG4gIC8vIGQpIHJlbW92ZSBhbGwgdGhlIG1vdmVzIGJlaGluZCB0aGF0IG9ic3RydWN0aW9uXG5cbiAgY29uc3QgZmlsdGVyZWRNb3ZlczogTW92ZXNbXSA9IFtdO1xuXG4gIGNvbnN0IGFsbFZlY3RvcnMgPSBzcGxpdEludG9WZWN0b3JzKHBvc3NpYmxlTW92ZXMsIHN0YXJ0aW5nU3F1YXJlKTtcbiAgY29uc3Qgb2JzdHJ1Y3Rpb25WZWN0b3JzID0gc3BsaXRJbnRvVmVjdG9ycyhvYnN0cnVjdGlvbnMsIHN0YXJ0aW5nU3F1YXJlKTtcbiAgZm9yIChjb25zdCB2ZWN0b3IgaW4gYWxsVmVjdG9ycykge1xuICAgIGlmICghb2JzdHJ1Y3Rpb25WZWN0b3JzW3ZlY3Rvcl0pIHtcbiAgICAgIC8vIGxvb2sgZm9yIHZlY3RvciBvYnN0cnVjdGlvbiBpcyBvblxuICAgICAgZmlsdGVyZWRNb3Zlcy5wdXNoKGFsbFZlY3RvcnNbdmVjdG9yXSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBzb3J0ZWQgPSBzb3J0TW92ZXNDbG9zZXN0VG8oc3RhcnRpbmdTcXVhcmUpKGFsbFZlY3RvcnNbdmVjdG9yXSk7XG4gICAgY29uc3QgY2xvc2VzdE9ic3RydWN0aW9uID0gc29ydE1vdmVzQ2xvc2VzdFRvKHN0YXJ0aW5nU3F1YXJlKShcbiAgICAgIG9ic3RydWN0aW9uVmVjdG9yc1t2ZWN0b3JdXG4gICAgKVswXTtcblxuICAgIGZpbHRlcmVkTW92ZXMucHVzaChyZW1vdmVNb3Zlc0JlaGluZFNxdWFyZShjbG9zZXN0T2JzdHJ1Y3Rpb24pKHNvcnRlZCkpO1xuICB9XG5cbiAgcmV0dXJuIGZpbHRlcmVkTW92ZXMuZmxhdCgpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVQcm90ZWN0ZWRTcXVhcmVzKFxuICBraW5nOiBQaWVjZU9iaixcbiAgcG9zc2libGVNb3ZlczogTW92ZXMsXG4gIGJvYXJkOiBCb2FyZFxuKTogTW92ZXMge1xuICAvLyBiYyBraW5nIGNhbnQgbW92ZSBpZiBzcXVhcmUgaXMgcHJvdGVjdGVkXG4gIGNvbnN0IG9wcENvbG9yID0ga2luZy5jb2xvciA9PT0gJ3doaXRlJyA/ICdibGFjaycgOiAnd2hpdGUnO1xuXG4gIGNvbnN0IGFsbEVuZW15TW92ZXMgPSBnZXRBdHRhY2tpbmdNb3Zlc0ZvckNvbG9yKG9wcENvbG9yLCBib2FyZCk7XG4gIHJldHVybiBwb3NzaWJsZU1vdmVzLmZpbHRlcigocykgPT4ge1xuICAgIHJldHVybiAhYWxsRW5lbXlNb3Zlcy5pbmNsdWRlcyhzKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU1vdmVzV2l0aFBpZWNlcyhcbiAgbW92ZXM6IE1vdmVzLFxuICBib2FyZDogQm9hcmQsXG4gIGNvbG9yPzogQ29sb3Jcbik6IE1vdmVzIHtcbiAgcmV0dXJuIG1vdmVzLmZpbHRlcigocykgPT4ge1xuICAgIGNvbnN0IHNxdWFyZVZhbCA9IGJvYXJkLmdldChzKTtcbiAgICBpZiAoIXNxdWFyZVZhbCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKGNvbG9yKSByZXR1cm4gIXNxdWFyZVZhbC5waWVjZSB8fCBzcXVhcmVWYWwucGllY2UuY29sb3IgIT09IGNvbG9yO1xuICAgIGVsc2UgcmV0dXJuICFzcXVhcmVWYWwucGllY2U7XG4gIH0pO1xufVxuXG4vKiBnYW1lYm9hcmQgY2hlY2tzICovXG5cbmZ1bmN0aW9uIGdldERpc2NvdmVyZWRDaGVjayhcbiAga2luZ1BvczogU3F1YXJlLFxuICBraW5nQ29sb3I6IENvbG9yLFxuICB2YWNhdGVkOiBTcXVhcmUsXG4gIGJvYXJkOiBCb2FyZFxuKTogU3F1YXJlIHtcbiAgLy8gb3BlblNxdWFyZSBpcyBhIHNxdWFyZSBqdXN0IHZhY2F0ZWRcbiAgbGV0IHNxdWFyZXNBbG9uZ1ZlY3RvciA9IGdldE1vdmVzQWxvbmdWZWN0b3IoXG4gICAga2luZ1BvcyxcbiAgICB2YWNhdGVkLFxuICAgIEFycmF5LmZyb20oYm9hcmQua2V5cygpKVxuICApO1xuICBzcXVhcmVzQWxvbmdWZWN0b3IgPSBzcXVhcmVzQWxvbmdWZWN0b3IuZmlsdGVyKFxuICAgIChzKSA9PiBzICE9PSBraW5nUG9zICYmIHMgIT09IHZhY2F0ZWRcbiAgKTtcbiAgaWYgKCFzcXVhcmVzQWxvbmdWZWN0b3IubGVuZ3RoKSByZXR1cm4gJyc7XG5cbiAgZm9yIChjb25zdCBzcXVhcmUgb2Ygc3F1YXJlc0Fsb25nVmVjdG9yKSB7XG4gICAgY29uc3QgcGllY2UgPSBib2FyZC5nZXQoc3F1YXJlKT8ucGllY2U7XG4gICAgaWYgKCFwaWVjZSB8fCBwaWVjZS5jb2xvciA9PT0ga2luZ0NvbG9yKSBjb250aW51ZTtcblxuICAgIGNvbnN0IGxlZ2FsTW92ZXMgPSBnZXRMZWdhbE1vdmVzKHNxdWFyZSwgYm9hcmQpO1xuICAgIGlmIChsZWdhbE1vdmVzLmluY2x1ZGVzKGtpbmdQb3MpKSByZXR1cm4gc3F1YXJlO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBjYW5CbG9ja09yQ2FwdHVyZUNoZWNrKFxuICBraW5nUG9zOiBTcXVhcmUsXG4gIHNxdWFyZUdpdmluZ0NoZWNrOiBTcXVhcmUsXG4gIGJvYXJkOiBCb2FyZFxuKTogYm9vbGVhbiB7XG4gIGNvbnN0IGtpbmcgPSBib2FyZC5nZXQoa2luZ1Bvcyk/LnBpZWNlIGFzIFBpZWNlT2JqO1xuXG4gIGNvbnN0IGJsb2NrT3JDYXB0dXJlU3F1YXJlcyA9IGdldFNxdWFyZXNCZXR3ZWVuS2luZ0FuZENoZWNrKFxuICAgIGtpbmdQb3MsXG4gICAgc3F1YXJlR2l2aW5nQ2hlY2ssXG4gICAgQXJyYXkuZnJvbShib2FyZC5rZXlzKCkpXG4gICk7IC8vIGFsc28gaW5jbHVkZXMgY2hlY2sgc3F1YXJlXG5cbiAgY29uc3Qgb3duUGllY2VNb3ZlcyA9IGdldEFsbE1vdmVzRm9yQ29sb3Ioa2luZy5jb2xvciwgYm9hcmQpO1xuICByZXR1cm4gb3duUGllY2VNb3Zlcy5zb21lKChtb3ZlKSA9PiBibG9ja09yQ2FwdHVyZVNxdWFyZXMuaW5jbHVkZXMobW92ZSkpO1xufVxuXG5leHBvcnQge1xuICBnZXRBdHRhY2tpbmdNb3Zlc0ZvckNvbG9yLFxuICBnZXRMZWdhbE1vdmVzLFxuICBnZXRMZWdhbE1vdmVzSW5DaGVjayxcbiAgZ2V0RGlzY292ZXJlZENoZWNrLFxuICBjYW5CbG9ja09yQ2FwdHVyZUNoZWNrXG59O1xuIiwiY29uc3QgZmlsZXMgPSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJywgJ2cnLCAnaCddO1xuY29uc3QgcmFua3MgPSBbMSwgMiwgMywgNCwgNSwgNiwgNywgOF07XG5cbmV4cG9ydCB7IGZpbGVzLCByYW5rcyB9O1xuIiwiaW1wb3J0IHsgQ2FzdGxlT2JqIH0gZnJvbSAnLi90eXBlcy9pbnRlcmZhY2VzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ2FzdGxlKFxuICB3aGl0ZUtpbmdzaWRlOiBib29sZWFuLFxuICB3aGl0ZVF1ZWVuc2lkZTogYm9vbGVhbixcbiAgYmxhY2tLaW5nc2lkZTogYm9vbGVhbixcbiAgYmxhY2tRdWVlbnNpZGU6IGJvb2xlYW5cbik6IENhc3RsZU9iaiB7XG4gIHJldHVybiB7XG4gICAgd2hpdGU6IHtcbiAgICAgIGtpbmdzaWRlOiB3aGl0ZUtpbmdzaWRlLFxuICAgICAgcXVlZW5zaWRlOiB3aGl0ZVF1ZWVuc2lkZVxuICAgIH0sXG4gICAgYmxhY2s6IHtcbiAgICAgIGtpbmdzaWRlOiBibGFja0tpbmdzaWRlLFxuICAgICAgcXVlZW5zaWRlOiBibGFja1F1ZWVuc2lkZVxuICAgIH1cbiAgfTtcbn1cbiIsImltcG9ydCB7XG4gIGdldExlZ2FsTW92ZXMsXG4gIGdldERpc2NvdmVyZWRDaGVjayxcbiAgY2FuQmxvY2tPckNhcHR1cmVDaGVjayxcbiAgZ2V0QXR0YWNraW5nTW92ZXNGb3JDb2xvcixcbiAgZ2V0TGVnYWxNb3Zlc0luQ2hlY2tcbn0gZnJvbSAnLi91dGlscy9tb3Zlcyc7XG5pbXBvcnQgeyB0b1hZLCBmcm9tWFkgfSBmcm9tICcuL3V0aWxzL2hlbHBlcnMnO1xuaW1wb3J0IHsgcmFua3MsIGZpbGVzIH0gZnJvbSAnLi9yYW5rc0FuZEZpbGVzJztcbmltcG9ydCB7XG4gIENvbG9yLFxuICBTcXVhcmUsXG4gIEJvYXJkLFxuICBQaWVjZVR5cGUsXG4gIE1vdmVzLFxuICBDYXN0bGVTcXVhcmVzVHlwZVxufSBmcm9tICcuL3R5cGVzL3R5cGVzJztcbmltcG9ydCB7XG4gIEFsbFBpZWNlTWFwLFxuICBDYXN0bGVPYmosXG4gIEdhbWVib2FyZE9iaixcbiAgUGllY2VNYXAsXG4gIFBpZWNlT2JqXG59IGZyb20gJy4vdHlwZXMvaW50ZXJmYWNlcyc7XG5pbXBvcnQgQ2FzdGxlIGZyb20gJy4vQ2FzdGxlJztcblxuZnVuY3Rpb24gY3JlYXRlQm9hcmQoKTogQm9hcmQge1xuICByZXR1cm4gZmlsZXMucmVkdWNlKChhY2MsIGZpbGUpID0+IHtcbiAgICByYW5rcy5mb3JFYWNoKChyYW5rKSA9PiB7XG4gICAgICBjb25zdCBzcXVhcmUgPSBmaWxlLmNvbmNhdChyYW5rLnRvU3RyaW5nKCkpO1xuICAgICAgYWNjLnNldChzcXVhcmUsIHsgcGllY2U6IG51bGwgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwgbmV3IE1hcCgpKTtcbn1cblxuY29uc3QgR2FtZWJvYXJkID0gKFxuICBib2FyZCA9IGNyZWF0ZUJvYXJkKCksXG4gIHNxdWFyZXNHaXZpbmdDaGVjaz86IE1vdmVzLFxuICBDYXN0bGVSaWdodHM/OiBDYXN0bGVPYmpcbik6IEdhbWVib2FyZE9iaiA9PiB7XG4gIGZ1bmN0aW9uIG1ha2VNb3ZlKFxuICAgIHMxOiBTcXVhcmUsXG4gICAgczI6IFNxdWFyZSxcbiAgICBwcm9tb3RlPzogUGllY2VUeXBlXG4gICk6IEJvYXJkIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBwaWVjZSA9IGF0KHMxKS5waWVjZTtcbiAgICBpZiAoIXBpZWNlKSByZXR1cm47XG5cbiAgICBpZiAoIXZhbGlkYXRlLm1vdmUoczEsIHMyKSkgcmV0dXJuO1xuXG4gICAgc3dpdGNoIChwaWVjZS50eXBlKSB7XG4gICAgICBjYXNlICdwYXduJzoge1xuICAgICAgICAvLyBwcm9tb3Rpb24gc3R1ZmZcbiAgICAgICAgaWYgKHByb21vdGUpIHtcbiAgICAgICAgICBpZiAoIXZhbGlkYXRlLnByb21vdGlvbihzMSwgczIpKSByZXR1cm47XG5cbiAgICAgICAgICBmcm9tKHMxKS50byhzMik7XG4gICAgICAgICAgYXQoczIpLnByb21vdGUocHJvbW90ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5QYXNzYW50LmNoZWNrVG9nZ2xlKHMxLCBzMikpIHtcbiAgICAgICAgICBlblBhc3NhbnQudG9nZ2xlKHMyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZyb20oczEpLnRvKHMyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgJ2tpbmcnOiB7XG4gICAgICAgIC8vIGNoZWNrIGlmIG1vdmUgaXMgY2FzdGxlXG4gICAgICAgIGxldCBjYXN0bGVTaWRlOiAnJyB8ICdxdWVlbnNpZGUnIHwgJ2tpbmdzaWRlJyA9ICcnO1xuICAgICAgICBjb25zdCBjYXN0bGVTcXVhcmVzID0gZ2V0LmNhc3RsZVNxdWFyZXMocGllY2UuY29sb3IpO1xuXG4gICAgICAgIGZvciAoY29uc3QgW3NpZGUsIHNxdWFyZXNdIG9mIE9iamVjdC5lbnRyaWVzKGNhc3RsZVNxdWFyZXMpKSB7XG4gICAgICAgICAgaWYgKHNxdWFyZXNbMV0gPT09IHMyKSBjYXN0bGVTaWRlID0gc2lkZSBhcyAna2luZ3NpZGUnIHwgJ3F1ZWVuc2lkZSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2FzdGxlU2lkZSkgY2FzdGxpbmcuY2FzdGxlKHBpZWNlLmNvbG9yLCBjYXN0bGVTaWRlKTtcbiAgICAgICAgZWxzZSBmcm9tKHMxKS50byhzMik7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGZyb20oczEpLnRvKHMyKTtcbiAgICB9XG5cbiAgICBlblBhc3NhbnQucmVtb3ZlKCk7XG4gICAgcmV0dXJuIGJvYXJkO1xuICB9XG5cbiAgY29uc3QgY2FzdGxpbmcgPSB7XG4gICAgY2FuQ2FzdGxlOiAoY29sb3I6IENvbG9yLCBzaWRlOiAna2luZ3NpZGUnIHwgJ3F1ZWVuc2lkZScpOiBib29sZWFuID0+IHtcbiAgICAgIGlmIChDYXN0bGVSaWdodHMgJiYgIUNhc3RsZVJpZ2h0c1tjb2xvcl1bc2lkZV0pIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gY2hlY2sgaWYgcm9vayBzdGlsbCBleGlzdHNcbiAgICAgIGlmICghY2hlY2tJZlJvb2tFeGlzdHMoKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBjb25zdCBvcHBDb2xvciA9IGNvbG9yID09PSAnd2hpdGUnID8gJ2JsYWNrJyA6ICd3aGl0ZSc7XG4gICAgICBjb25zdCBvcHBNb3ZlcyA9IGdldEF0dGFja2luZ01vdmVzRm9yQ29sb3Iob3BwQ29sb3IsIGJvYXJkKTtcblxuICAgICAgY29uc3QgY2FzdGxlU3F1YXJlcyA9IGdldC5jYXN0bGVTcXVhcmVzKGNvbG9yKVtzaWRlXTtcbiAgICAgIGZvciAoY29uc3Qgc3F1YXJlIG9mIGNhc3RsZVNxdWFyZXMpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgY2FzdGxlIHNxdWFyZSBpcyBjbGVhcmVkXG4gICAgICAgIGlmIChhdChzcXVhcmUpLnBpZWNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSBjYXN0bGUgc3F1YXJlIGlzbnQgYXR0YWNrZWRcbiAgICAgICAgaWYgKG9wcE1vdmVzLmluY2x1ZGVzKHNxdWFyZSkpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIGZ1bmN0aW9uIGNoZWNrSWZSb29rRXhpc3RzKCk6IGJvb2xlYW4ge1xuICAgICAgICBsZXQgcm9va0V4aXN0cyA9IGZhbHNlO1xuICAgICAgICBjb25zdCByYW5rID0gY29sb3IgPT09ICd3aGl0ZScgPyAxIDogODtcbiAgICAgICAgY29uc3QgbG9vcFN0YXJ0ID1cbiAgICAgICAgICBzaWRlID09PSAncXVlZW5zaWRlJyA/IGZpbGVzLmluZGV4T2YoJ2EnKSA6IGZpbGVzLmluZGV4T2YoJ2QnKTtcbiAgICAgICAgY29uc3QgbG9vcEVuZCA9XG4gICAgICAgICAgc2lkZSA9PT0gJ3F1ZWVuc2lkZScgPyBmaWxlcy5pbmRleE9mKCdlJykgOiBmaWxlcy5pbmRleE9mKCdoJyk7XG4gICAgICAgIGZvciAobGV0IGkgPSBsb29wU3RhcnQ7IGkgPD0gbG9vcEVuZDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qgc3F1YXJlID0gZmlsZXNbaV0gKyByYW5rO1xuXG4gICAgICAgICAgY29uc3QgcGllY2UgPSBhdChzcXVhcmUpLnBpZWNlO1xuICAgICAgICAgIGlmICghcGllY2UpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgaWYgKHBpZWNlLnR5cGUgPT09ICdyb29rJykgcm9va0V4aXN0cyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvb2tFeGlzdHM7XG4gICAgICB9XG4gICAgfSxcbiAgICBjYXN0bGU6IChjb2xvcjogQ29sb3IsIHNpZGU6ICdraW5nc2lkZScgfCAncXVlZW5zaWRlJyk6IHZvaWQgPT4ge1xuICAgICAgY29uc3QgY2FzdGxlU3F1YXJlcyA9IGdldC5jYXN0bGVTcXVhcmVzKGNvbG9yKVtzaWRlXTtcblxuICAgICAgY29uc3Qga2luZ1BvcyA9IGdldC5raW5nUG9zaXRpb24oY29sb3IpIGFzIFNxdWFyZTtcbiAgICAgIGNvbnN0IHJvb2tQb3MgPSBnZXRSb29rUG9zKCkgYXMgU3F1YXJlO1xuXG4gICAgICBmcm9tKHJvb2tQb3MpLnRvKGNhc3RsZVNxdWFyZXNbMF0pO1xuICAgICAgZnJvbShraW5nUG9zKS50byhjYXN0bGVTcXVhcmVzWzFdKTtcblxuICAgICAgZnVuY3Rpb24gZ2V0Um9va1BvcygpIHtcbiAgICAgICAgY29uc3QgcGllY2VNYXAgPSBnZXQucGllY2VNYXAoKTtcbiAgICAgICAgY29uc3Qgcm9va1BvcyA9IHBpZWNlTWFwW2NvbG9yXS5yb29rLmZpbmQoKHNxdWFyZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGZpbGUgPSBzcXVhcmUuc3BsaXQoJycpWzBdO1xuICAgICAgICAgIHJldHVybiBzaWRlID09PSAna2luZ3NpZGUnXG4gICAgICAgICAgICA/IGZpbGVzLmluZGV4T2YoZmlsZSkgPiAzXG4gICAgICAgICAgICA6IGZpbGVzLmluZGV4T2YoZmlsZSkgPCAzO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcm9va1BvcztcbiAgICAgIH1cbiAgICAgIC8vIG5lZWQgdG8gZ2V0IGtpbmcgcG9zaXRpb25cbiAgICAgIC8vIG5lZWQgdG8gZ2V0IGNhc3RsZSBzcXVhcmVzXG4gICAgICAvLyBuZWVkIHRvIGZpbmQgcm9va1xuICAgIH0sXG4gICAgZ2V0UmlnaHRzQWZ0ZXJNb3ZlOiAoc3F1YXJlOiBTcXVhcmUpOiBDYXN0bGVPYmogPT4ge1xuICAgICAgY29uc3QgcGllY2UgPSBhdChzcXVhcmUpLnBpZWNlIGFzIFBpZWNlT2JqO1xuXG4gICAgICBjb25zdCBjYXN0bGVSaWdodHMgPSBDYXN0bGVSaWdodHMgfHwgQ2FzdGxlKHRydWUsIHRydWUsIHRydWUsIHRydWUpO1xuXG4gICAgICBpZiAoXG4gICAgICAgIGNhc3RsZVJpZ2h0c1twaWVjZS5jb2xvcl0ua2luZ3NpZGUgfHxcbiAgICAgICAgY2FzdGxlUmlnaHRzW3BpZWNlLmNvbG9yXS5xdWVlbnNpZGVcbiAgICAgICkge1xuICAgICAgICAvLyBjaGVjayBpZiBpIG5lZWQgdG8gY2hhbmdlIGNhc3RsaW5nIHJpZ2h0c1xuICAgICAgICBpZiAocGllY2UudHlwZSA9PT0gJ2tpbmcnKSB7XG4gICAgICAgICAgY2FzdGxlUmlnaHRzW3BpZWNlLmNvbG9yXS5raW5nc2lkZSA9IGZhbHNlO1xuICAgICAgICAgIGNhc3RsZVJpZ2h0c1twaWVjZS5jb2xvcl0ucXVlZW5zaWRlID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGllY2UudHlwZSA9PT0gJ3Jvb2snKSB7XG4gICAgICAgICAgLy8gbmVlZCB0byBmaW5kIGlmIGl0IGlzIGtpbmdzaWRlIG9yIHF1ZWVuc2lkZSByb29rXG4gICAgICAgICAgY29uc3QgW2ZpbGVdID0gc3F1YXJlLnNwbGl0KCcnKTtcbiAgICAgICAgICBjb25zdCBraW5nc2lkZSA9IGZpbGVzLmluZGV4T2YoZmlsZSkgPiAzO1xuICAgICAgICAgIGlmIChraW5nc2lkZSkgY2FzdGxlUmlnaHRzW3BpZWNlLmNvbG9yXS5raW5nc2lkZSA9IGZhbHNlO1xuICAgICAgICAgIGVsc2UgY2FzdGxlUmlnaHRzW3BpZWNlLmNvbG9yXS5xdWVlbnNpZGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2FzdGxlUmlnaHRzO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBlblBhc3NhbnQgPSAoKCkgPT4ge1xuICAgIGZ1bmN0aW9uIGdldFNxdWFyZShjdXJyZW50OiBTcXVhcmUsIGNvbG9yOiBDb2xvcik6IFNxdWFyZSB7XG4gICAgICBjb25zdCB7IHgsIHkgfSA9IHRvWFkoY3VycmVudCk7XG4gICAgICBjb25zdCBuZXdZID0gY29sb3IgPT09ICd3aGl0ZScgPyB5IC0gMSA6IHkgKyAxO1xuICAgICAgcmV0dXJuIGZyb21YWSh7IHgsIHk6IG5ld1kgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNoZWNrVG9nZ2xlOiAoZnJvbTogU3F1YXJlLCB0bzogU3F1YXJlKTogYm9vbGVhbiA9PiB7XG4gICAgICAgIGNvbnN0IHsgeTogeTEgfSA9IHRvWFkoZnJvbSk7XG4gICAgICAgIGNvbnN0IHsgeTogeTIgfSA9IHRvWFkodG8pO1xuXG4gICAgICAgIHJldHVybiBNYXRoLmFicyh5MSAtIHkyKSA9PT0gMjtcbiAgICAgIH0sXG4gICAgICB0b2dnbGU6IChjdXJyZW50OiBTcXVhcmUpOiB2b2lkID0+IHtcbiAgICAgICAgY29uc3QgeyBjb2xvciB9ID0gYXQoY3VycmVudCkucGllY2UgYXMgUGllY2VPYmo7XG4gICAgICAgIGNvbnN0IGVuUGFzc2FudFNxdWFyZSA9IGdldFNxdWFyZShjdXJyZW50LCBjb2xvcik7XG4gICAgICAgIGF0KGVuUGFzc2FudFNxdWFyZSkuc2V0RW5QYXNzYW50KGNvbG9yLCBjdXJyZW50KTtcbiAgICAgIH0sXG4gICAgICByZW1vdmU6ICgpOiB2b2lkID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBzcXVhcmVPYmogb2YgYm9hcmQudmFsdWVzKCkpIHtcbiAgICAgICAgICBpZiAoc3F1YXJlT2JqLmVuUGFzc2FudCkgcmV0dXJuIChzcXVhcmVPYmouZW5QYXNzYW50ID0gdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0pKCk7XG5cbiAgY29uc3QgYXQgPSAoc3F1YXJlOiBTcXVhcmUpID0+ICh7XG4gICAgcGxhY2U6IChwaWVjZTogUGllY2VPYmopOiB2b2lkID0+IHtcbiAgICAgIGlmICghYm9hcmQuZ2V0KHNxdWFyZSkpIHJldHVybjtcblxuICAgICAgYm9hcmQuc2V0KHNxdWFyZSwgeyBwaWVjZSB9KTtcbiAgICB9LFxuICAgIHJlbW92ZTogKCk6IHZvaWQgPT4ge1xuICAgICAgaWYgKCFib2FyZC5nZXQoc3F1YXJlKSkgcmV0dXJuO1xuXG4gICAgICBib2FyZC5zZXQoc3F1YXJlLCB7IHBpZWNlOiBudWxsIH0pO1xuICAgIH0sXG4gICAgcHJvbW90ZTogKHBpZWNlVHlwZTogUGllY2VUeXBlKTogdm9pZCA9PiB7XG4gICAgICBjb25zdCBzcXVhcmVWYWwgPSBib2FyZC5nZXQoc3F1YXJlKTtcbiAgICAgIGNvbnN0IHBpZWNlID0gc3F1YXJlVmFsPy5waWVjZTtcbiAgICAgIGlmICghcGllY2UpIHJldHVybjtcblxuICAgICAgYm9hcmQuc2V0KHNxdWFyZSwgeyAuLi5zcXVhcmVWYWwsIHBpZWNlOiB7IC4uLnBpZWNlLCB0eXBlOiBwaWVjZVR5cGUgfSB9KTtcbiAgICB9LFxuICAgIHNldEVuUGFzc2FudDogKGNvbG9yOiBDb2xvciwgY3VycmVudDogU3F1YXJlKTogdm9pZCA9PiB7XG4gICAgICBpZiAoIWJvYXJkLmdldChzcXVhcmUpKSByZXR1cm47XG5cbiAgICAgIGJvYXJkLnNldChzcXVhcmUsIHtcbiAgICAgICAgcGllY2U6IG51bGwsXG4gICAgICAgIGVuUGFzc2FudDoge1xuICAgICAgICAgIGN1cnJlbnQgLyogc3F1YXJlIHBhd24gaXMgb24gKi8sXG4gICAgICAgICAgY29sb3I6IGNvbG9yXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0IHBpZWNlKCkge1xuICAgICAgcmV0dXJuIGJvYXJkLmdldChzcXVhcmUpPy5waWVjZTtcbiAgICB9LFxuICAgIGdldExlZ2FsTW92ZXM6ICgpOiBNb3ZlcyA9PiB7XG4gICAgICBzcXVhcmVzR2l2aW5nQ2hlY2sgPSBzcXVhcmVzR2l2aW5nQ2hlY2sgfHwgW107XG4gICAgICBjb25zdCB7IHR5cGUsIGNvbG9yIH0gPSBhdChzcXVhcmUpLnBpZWNlIGFzIFBpZWNlT2JqO1xuXG4gICAgICBzd2l0Y2ggKHNxdWFyZXNHaXZpbmdDaGVjay5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgaWYgKHR5cGUgIT09ICdraW5nJykgcmV0dXJuIFtdO1xuICAgICAgICAgIHJldHVybiBnZXRMZWdhbE1vdmVzKHNxdWFyZSwgYm9hcmQpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMToge1xuICAgICAgICAgIHJldHVybiBnZXRMZWdhbE1vdmVzSW5DaGVjayhcbiAgICAgICAgICAgIG9yaWdpbixcbiAgICAgICAgICAgIGJvYXJkLFxuICAgICAgICAgICAgZ2V0LmtpbmdQb3NpdGlvbihjb2xvcikgYXMgU3F1YXJlLFxuICAgICAgICAgICAgc3F1YXJlc0dpdmluZ0NoZWNrWzBdXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdraW5nJykge1xuICAgICAgICAgICAgbGV0IGxlZ2FsTW92ZXMgPSBnZXRMZWdhbE1vdmVzKHNxdWFyZSwgYm9hcmQpO1xuICAgICAgICAgICAgaWYgKGNhc3RsaW5nLmNhbkNhc3RsZShjb2xvciwgJ2tpbmdzaWRlJykpXG4gICAgICAgICAgICAgIGxlZ2FsTW92ZXMgPSBbXG4gICAgICAgICAgICAgICAgLi4ubGVnYWxNb3ZlcyxcbiAgICAgICAgICAgICAgICAuLi5nZXQuY2FzdGxlU3F1YXJlcyhjb2xvcikua2luZ3NpZGVcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGlmIChjYXN0bGluZy5jYW5DYXN0bGUoY29sb3IsICdxdWVlbnNpZGUnKSlcbiAgICAgICAgICAgICAgbGVnYWxNb3ZlcyA9IFtcbiAgICAgICAgICAgICAgICAuLi5sZWdhbE1vdmVzLFxuICAgICAgICAgICAgICAgIC4uLmdldC5jYXN0bGVTcXVhcmVzKGNvbG9yKS5xdWVlbnNpZGVcbiAgICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgcmV0dXJuIGxlZ2FsTW92ZXM7XG4gICAgICAgICAgfSBlbHNlIHJldHVybiBnZXRMZWdhbE1vdmVzKHNxdWFyZSwgYm9hcmQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBjb25zdCBmcm9tID0gKHMxOiBTcXVhcmUpID0+ICh7XG4gICAgdG86IChzMjogU3F1YXJlKTogdm9pZCA9PiB7XG4gICAgICBjb25zdCBwaWVjZSA9IGF0KHMxKS5waWVjZTtcbiAgICAgIGlmICghcGllY2UpIHJldHVybjtcblxuICAgICAgLy8gbW92ZSBwaWVjZVxuICAgICAgYXQoczEpLnJlbW92ZSgpO1xuICAgICAgYXQoczIpLnBsYWNlKHBpZWNlKTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IGdldCA9IHtcbiAgICBraW5nUG9zaXRpb246IChjb2xvcjogQ29sb3IpOiBTcXVhcmUgfCB1bmRlZmluZWQgPT4ge1xuICAgICAgZm9yIChjb25zdCBbc3F1YXJlLCB2YWx1ZV0gb2YgYm9hcmQuZW50cmllcygpKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB2YWx1ZS5waWVjZSAmJlxuICAgICAgICAgIHZhbHVlLnBpZWNlLnR5cGUgPT09ICdraW5nJyAmJlxuICAgICAgICAgIHZhbHVlLnBpZWNlLmNvbG9yID09PSBjb2xvclxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIHNxdWFyZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHBpZWNlTWFwOiAoKTogQWxsUGllY2VNYXAgPT4ge1xuICAgICAgY29uc3QgcGllY2VNYXAgPSB7IHdoaXRlOiB7fSBhcyBQaWVjZU1hcCwgYmxhY2s6IHt9IGFzIFBpZWNlTWFwIH07XG4gICAgICBmb3IgKGNvbnN0IFtzcXVhcmUsIHZhbHVlXSBvZiBib2FyZC5lbnRyaWVzKCkpIHtcbiAgICAgICAgY29uc3QgeyBwaWVjZSB9ID0gdmFsdWU7XG4gICAgICAgIGlmICghcGllY2UpIGNvbnRpbnVlO1xuXG4gICAgICAgIGNvbnN0IHsgdHlwZSwgY29sb3IgfSA9IHBpZWNlO1xuICAgICAgICBwaWVjZU1hcFtjb2xvcl1bdHlwZV0gPSBwaWVjZU1hcFtjb2xvcl1bdHlwZV1cbiAgICAgICAgICA/IFsuLi5waWVjZU1hcFtjb2xvcl1bdHlwZV0sIHNxdWFyZV1cbiAgICAgICAgICA6IFtzcXVhcmVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBpZWNlTWFwO1xuICAgIH0sXG4gICAgc3F1YXJlc0dpdmluZ0NoZWNrQWZ0ZXJNb3ZlOiAoZnJvbTogU3F1YXJlLCBlbmQ6IFNxdWFyZSk6IFNxdWFyZVtdID0+IHtcbiAgICAgIGNvbnN0IHNxdWFyZXNHaXZpbmdDaGVjazogc3RyaW5nW10gPSBbXTtcblxuICAgICAgY29uc3QgcGllY2UgPSBib2FyZC5nZXQoZW5kKT8ucGllY2UgYXMgUGllY2VPYmo7XG4gICAgICBjb25zdCBvcHBDb2xvciA9IHBpZWNlLmNvbG9yID09PSAnd2hpdGUnID8gJ2JsYWNrJyA6ICd3aGl0ZSc7XG4gICAgICBjb25zdCBraW5nUG9zaXRpb24gPSBnZXQua2luZ1Bvc2l0aW9uKG9wcENvbG9yKSBhcyBTcXVhcmU7XG5cbiAgICAgIGNvbnN0IHBpZWNlSGl0c0tpbmcgPSBnZXRMZWdhbE1vdmVzKGVuZCwgYm9hcmQpLmluY2x1ZGVzKGtpbmdQb3NpdGlvbik7XG4gICAgICBpZiAocGllY2VIaXRzS2luZykgc3F1YXJlc0dpdmluZ0NoZWNrLnB1c2goZW5kKTtcblxuICAgICAgY29uc3QgZGlzY292ZXJlZENoZWNrID0gZ2V0RGlzY292ZXJlZENoZWNrKFxuICAgICAgICBraW5nUG9zaXRpb24sXG4gICAgICAgIG9wcENvbG9yLFxuICAgICAgICBmcm9tLFxuICAgICAgICBib2FyZFxuICAgICAgKTtcbiAgICAgIGlmIChkaXNjb3ZlcmVkQ2hlY2spIHNxdWFyZXNHaXZpbmdDaGVjay5wdXNoKGRpc2NvdmVyZWRDaGVjayk7XG5cbiAgICAgIHJldHVybiBzcXVhcmVzR2l2aW5nQ2hlY2s7XG4gICAgfSxcbiAgICBpc0NoZWNrbWF0ZTogKGNvbG9yOiBDb2xvciwgc3F1YXJlc0dpdmluZ0NoZWNrOiBzdHJpbmdbXSk6IGJvb2xlYW4gPT4ge1xuICAgICAgY29uc3Qga2luZ1BvcyA9IGdldC5raW5nUG9zaXRpb24oY29sb3IpIGFzIFNxdWFyZTtcbiAgICAgIGNvbnN0IGxlZ2FsTW92ZXMgPSBhdChraW5nUG9zKS5nZXRMZWdhbE1vdmVzKCk7XG4gICAgICAvLyBjaGVjayBpZiBjaGVjayBjYW4gYmUgYmxvY2tlZFxuICAgICAgaWYgKHNxdWFyZXNHaXZpbmdDaGVjay5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKGNhbkJsb2NrT3JDYXB0dXJlQ2hlY2soa2luZ1Bvcywgc3F1YXJlc0dpdmluZ0NoZWNrWzBdLCBib2FyZCkpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCFsZWdhbE1vdmVzIHx8ICFsZWdhbE1vdmVzLmxlbmd0aCkgcmV0dXJuIHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBjYXN0bGVTcXVhcmVzKGNvbG9yOiBDb2xvcik6IENhc3RsZVNxdWFyZXNUeXBlIHtcbiAgICAgIGNvbnN0IHJhbmsgPSBjb2xvciA9PT0gJ3doaXRlJyA/IDEgOiA4O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2luZ3NpZGU6IFtgZiR7cmFua31gLCBgZyR7cmFua31gXSxcbiAgICAgICAgcXVlZW5zaWRlOiBbYGQke3Jhbmt9YCwgYGMke3Jhbmt9YF1cbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHZhbGlkYXRlID0ge1xuICAgIG1vdmU6IChmcm9tOiBTcXVhcmUsIHRvOiBTcXVhcmUpOiBib29sZWFuID0+IHtcbiAgICAgIGNvbnN0IHBpZWNlID0gYXQoZnJvbSkucGllY2U7XG4gICAgICBpZiAoIXBpZWNlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGlmICghYXQoZnJvbSkuZ2V0TGVnYWxNb3ZlcygpLmluY2x1ZGVzKHRvKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIHByb21vdGlvbjogKGZyb206IFNxdWFyZSwgdG86IFNxdWFyZSk6IGJvb2xlYW4gPT4ge1xuICAgICAgY29uc3QgcGllY2UgPSBhdChmcm9tKS5waWVjZTtcblxuICAgICAgaWYgKHBpZWNlPy50eXBlICE9PSAncGF3bicpIHJldHVybiBmYWxzZTtcblxuICAgICAgY29uc3QgZW5kT2ZCb2FyZCA9IHBpZWNlLmNvbG9yID09PSAnd2hpdGUnID8gOCA6IDE7XG4gICAgICBjb25zdCBbLCByYW5rXSA9IHRvLnNwbGl0KCcnKTtcbiAgICAgIGlmICgrcmFuayA9PT0gZW5kT2ZCb2FyZCkgcmV0dXJuIHRydWU7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBjcmVhdGVCb2FyZCxcbiAgICBjYXN0bGluZyxcbiAgICBlblBhc3NhbnQsXG4gICAgYXQsXG4gICAgZnJvbSxcbiAgICBnZXQsXG4gICAgdmFsaWRhdGUsXG4gICAgbWFrZU1vdmUsXG4gICAgZ2V0IGJvYXJkKCkge1xuICAgICAgcmV0dXJuIGJvYXJkO1xuICAgIH1cbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEdhbWVib2FyZDtcbiIsIi8vIHNob3VsZCBvdXRwdXQgaGlzdG9yeSBvYmplY3QgdGhhdCBob2xkcyBtb3ZlIGhpc3RvcnkgaW4gMmQgYXJyYXlcbi8vIGZvciBlYWNoIG1vdmUgbmVlZHMgdG8gYXR0YWNoIHBpZWNlIFR5cGUgdG8gYmVnaW5uaW5nIG9mIG1vdmUgaWYgbm90IHBhd25cbi8vIHNob3VsZCBmdXJ0aGVyIHNwZWNpZnkgc3F1YXJlIG9mIHBpZWNlIGlmLCBzYXkgYm90aCByb29rcywgY2FuIG1vdmUgdG8gc2FtZSBzcXVhcmVcblxuaW1wb3J0IHsgQWxsUGllY2VNYXAsIEhpc3RvcnlPYmosIFBpZWNlT2JqIH0gZnJvbSAnLi90eXBlcy9pbnRlcmZhY2VzJztcbmltcG9ydCB7IEJvYXJkLCBQaWVjZVR5cGUsIFNxdWFyZSB9IGZyb20gJy4vdHlwZXMvdHlwZXMnO1xuaW1wb3J0IHsgZ2V0TGVnYWxNb3ZlcyB9IGZyb20gJy4vdXRpbHMvbW92ZXMnO1xuXG50eXBlIEhpc3RvcnlUeXBlID0gU3F1YXJlW11bXTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSGlzdG9yeShcbiAgcHJldkhpc3Rvcnk6IEhpc3RvcnlUeXBlLFxuICBib2FyZDogQm9hcmQsXG4gIHBpZWNlTWFwOiBBbGxQaWVjZU1hcFxuKTogSGlzdG9yeU9iaiB7XG4gIGNvbnN0IGhpc3Rvcnk6IEhpc3RvcnlUeXBlID0gcHJldkhpc3RvcnkgfHwgW107XG5cbiAgY29uc3QgZ2V0ID0ge1xuICAgIHBpZWNlUHJlZml4OiAoZnJvbTogU3F1YXJlLCB0bzogU3F1YXJlKSA9PiB7XG4gICAgICBjb25zdCB7IHR5cGUsIGNvbG9yIH0gPSBib2FyZC5nZXQodG8pPy5waWVjZSBhcyBQaWVjZU9iajtcblxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ3Bhd24nOlxuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgY2FzZSAna25pZ2h0JzpcbiAgICAgICAgY2FzZSAncm9vayc6IHtcbiAgICAgICAgICBsZXQgcHJlZml4ID0gdHlwZSA9PT0gJ3Jvb2snID8gJ1InIDogJ04nO1xuICAgICAgICAgIGlmIChwaWVjZU1hcFtjb2xvcl1bdHlwZV0ubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICAvLyBsb29rIGZvciBwaWVjZSBvZiBzYW1lIHR5cGUgdGhhdCBjb3VsZHZlIGFsc28gd2VudCB0byB0aGUgc3F1YXJlXG4gICAgICAgICAgICBwaWVjZU1hcFtjb2xvcl1bdHlwZV0uZm9yRWFjaCgocykgPT4ge1xuICAgICAgICAgICAgICBpZiAocyA9PT0gdG8pIHJldHVybjtcblxuICAgICAgICAgICAgICBjb25zdCBib2FyZENvcHkgPSBuZXcgTWFwKGJvYXJkKTtcbiAgICAgICAgICAgICAgYm9hcmRDb3B5LnNldCh0bywgeyBwaWVjZTogbnVsbCB9KTtcblxuICAgICAgICAgICAgICBpZiAoZ2V0TGVnYWxNb3ZlcyhzLCBib2FyZENvcHkpLmluY2x1ZGVzKHRvKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFt4MSwgeTFdID0gZnJvbS5zcGxpdCgnJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgW3gyXSA9IHMuc3BsaXQoJycpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNhbWVGaWxlID0geDEgPT09IHgyO1xuXG4gICAgICAgICAgICAgICAgcHJlZml4ID0gc2FtZUZpbGUgPyBwcmVmaXggKyB5MSA6IHByZWZpeCArIHgxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcHJlZml4O1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBjb25zdCBwcmVmaXggPSB0eXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgIHJldHVybiBwcmVmaXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNhc3RsZU5vdGF0aW9uOiAoc2lkZTogJ2tpbmdzaWRlJyB8ICdxdWVlbnNpZGUnKSA9PiB7XG4gICAgICByZXR1cm4gc2lkZSA9PT0gJ2tpbmdzaWRlJyA/ICdPLU8nIDogJ08tTy1PJztcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgYWZmaXggPSB7XG4gICAgY2FwdHVyZTogKG1vdmU6IFNxdWFyZSwgcHJlZml4OiBzdHJpbmcpID0+IHtcbiAgICAgIHJldHVybiBgJHtwcmVmaXh9eCR7bW92ZX1gO1xuICAgIH0sXG4gICAgcHJvbW90ZTogKG1vdmU6IFNxdWFyZSwgcGllY2VUeXBlOiBQaWVjZVR5cGUpID0+IHtcbiAgICAgIGNvbnN0IHN1ZmZpeCA9XG4gICAgICAgIHBpZWNlVHlwZSA9PT0gJ2tuaWdodCcgPyAnTicgOiBwaWVjZVR5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgIHJldHVybiBgJHttb3ZlfT0ke3N1ZmZpeH1gO1xuICAgIH0sXG4gICAgY2hlY2s6IChub3RhdGlvbjogc3RyaW5nKSA9PiB7XG4gICAgICByZXR1cm4gYCR7bm90YXRpb259K2A7XG4gICAgfSxcbiAgICBjaGVja21hdGU6IChub3RhdGlvbjogc3RyaW5nKSA9PiB7XG4gICAgICByZXR1cm4gYCR7bm90YXRpb259I2A7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgZ2V0LFxuICAgIGFmZml4LFxuICAgIGluc2VydE1vdmU6IChub3RhdGlvbjogc3RyaW5nKSA9PiB7XG4gICAgICBjb25zdCBsYXN0TW92ZVBhaXIgPSBoaXN0b3J5W2hpc3RvcnkubGVuZ3RoIC0gMV07XG4gICAgICBpZiAobGFzdE1vdmVQYWlyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBsYXN0TW92ZVBhaXIucHVzaChub3RhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBuZXdNb3ZlUGFpciA9IFtub3RhdGlvbl07XG4gICAgICAgIGhpc3RvcnkucHVzaChuZXdNb3ZlUGFpcik7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuIiwiaW1wb3J0IHsgQWxsUGllY2VNYXAgfSBmcm9tICcuL3R5cGVzL2ludGVyZmFjZXMnO1xuXG5jb25zdCBzdGFuZGFyZDogQWxsUGllY2VNYXAgPSB7XG4gIHdoaXRlOiB7XG4gICAgcm9vazogWydhMScsICdoMSddLFxuICAgIGtuaWdodDogWydnMScsICdiMSddLFxuICAgIGJpc2hvcDogWydmMScsICdjMSddLFxuICAgIGtpbmc6IFsnZTEnXSxcbiAgICBxdWVlbjogWydkMSddLFxuICAgIHBhd246IFsnYTInLCAnYjInLCAnYzInLCAnZDInLCAnZTInLCAnZjInLCAnZzInLCAnaDInXVxuICB9LFxuICBibGFjazoge1xuICAgIHJvb2s6IFsnYTgnLCAnaDgnXSxcbiAgICBrbmlnaHQ6IFsnZzgnLCAnYjgnXSxcbiAgICBiaXNob3A6IFsnZjgnLCAnYzgnXSxcbiAgICBraW5nOiBbJ2U4J10sXG4gICAgcXVlZW46IFsnZDgnXSxcbiAgICBwYXduOiBbJ2E3JywgJ2I3JywgJ2M3JywgJ2Q3JywgJ2U3JywgJ2Y3JywgJ2c3JywgJ2g3J11cbiAgfVxufTtcblxuZXhwb3J0IHsgc3RhbmRhcmQgfTtcbiIsImltcG9ydCBHYW1lYm9hcmQgZnJvbSAnLi9HYW1lYm9hcmQnO1xuaW1wb3J0IEhpc3RvcnkgZnJvbSAnLi9IaXN0b3J5JztcbmltcG9ydCBDYXN0bGUgZnJvbSAnLi9DYXN0bGUnO1xuaW1wb3J0ICogYXMgc3RhcnRpbmdQb3NpdGlvbnMgZnJvbSAnLi9zdGFydGluZ1Bvc2l0aW9ucyc7XG5pbXBvcnQgeyByYW5rcywgZmlsZXMgfSBmcm9tICcuL3JhbmtzQW5kRmlsZXMnO1xuXG5leHBvcnQgeyBHYW1lYm9hcmQsIEhpc3RvcnksIENhc3RsZSwgc3RhcnRpbmdQb3NpdGlvbnMsIHJhbmtzLCBmaWxlcyB9O1xuIl0sIm5hbWVzIjpbInRvWFkiLCJzcXVhcmUiLCJ4IiwieSIsInNwbGl0IiwiaW5kZXhPZiIsInRvTG93ZXJDYXNlIiwiTnVtYmVyIiwiZnJvbVhZIiwiY29vcmQiLCJjb2wiLCJjb25jYXQiLCJ0b1N0cmluZyIsImNhbGNEaXN0YW5jZSIsInNxdWFyZU9uZSIsInNxdWFyZVR3byIsIngxIiwieTEiLCJ4MiIsInkyIiwieERpZmYiLCJ5RGlmZiIsIm1vdmVzIiwiUGllY2UiLCJjb2xvciIsInR5cGUiLCJoYXNNb3ZlIiwiZnJvbSIsInRvIiwib25lU3F1YXJlVmVydCIsInlCeU4iLCJ4QnlOIiwib25lU3F1YXJlTGF0ZXJhbCIsIm9uZVNxdWFyZURpYWdvbmFsbHkiLCJkaWFnb25hbCIsInZlcnRBbmRMYXRlcmFsIiwib25seU1vdmVzSW5Gcm9udCIsInJlZ3VsYXJNb3ZlIiwiZmlyc3RNb3ZlIiwianVtcFR3byIsImdldFBhd25DYXB0dXJlcyIsIm9yaWdpbiIsIm5ld1kiLCJjYXB0dXJlT25lIiwiY2FwdHVyZVR3byIsIk1hdGgiLCJhYnMiLCJudW0iLCJzcGxpdEludG9WZWN0b3JzIiwiYXJyYXlPZk1vdmVzIiwic3RhcnQiLCJyZWR1Y2UiLCJhY2MiLCJjdXJyIiwidmVjdG9yIiwiY2hhckF0Iiwic2xpY2UiLCJwdXNoIiwiZ2V0QmVnaW5uaW5nT2ZWZWN0b3IiLCJsZW5ndGgiLCJhY2NJc0JlZ2lubmluZyIsImdldE1vdmVzQWxvbmdWZWN0b3IiLCJzMSIsInMyIiwiYWxsU3F1YXJlcyIsImxpZXNTYW1lVmVydE9yTGF0IiwibGllc1NhbWVEaWFnb25hbGx5IiwibGllc09uU2FtZUxpbmUiLCJtYXRjaGluZ1ZlY3RvciIsInNxdWFyZXNBbG9uZ1ZlY3RvciIsImZpbHRlciIsInMiLCJzb3J0TW92ZXNDbG9zZXN0VG8iLCJzb3J0IiwiYSIsImIiLCJ4MURpZmYiLCJ5MURpZmYiLCJhRGlmZiIsIngyRGlmZiIsInkyRGlmZiIsImJEaWZmIiwiZ2V0UG9zc2libGVNb3ZlcyIsImJvYXJkIiwiQXJyYXkiLCJrZXlzIiwiZ2V0IiwicGllY2UiLCJnZXRMZWdhbE1vdmVzIiwicG9zc2libGVNb3ZlcyIsIm9ic3RydWN0aW9ucyIsIl9hIiwibGVnYWxNb3ZlcyIsImNhcHR1cmVzQXZhaWxhYmxlIiwidW5vYnN0cnVjdGVkTW92ZXMiLCJyZW1vdmVNb3Zlc1dpdGhQaWVjZXMiLCJyZW1vdmVPYnN0cnVjdGVkTW92ZXMiLCJyZW1vdmVQcm90ZWN0ZWRTcXVhcmVzIiwiZ2V0TGVnYWxNb3Zlc0luQ2hlY2siLCJraW5nUG9zIiwic3F1YXJlR2l2aW5nQ2hlY2siLCJzcXVhcmVzVGhhdERlYWxXaXRoQ2hlY2siLCJnZXRTcXVhcmVzQmV0d2VlbktpbmdBbmRDaGVjayIsImluY2x1ZGVzIiwiZ2V0QXR0YWNraW5nTW92ZXMiLCJnZXRBbGxNb3Zlc0ZvckNvbG9yIiwiYWxsTW92ZXMiLCJlbnRyaWVzIiwiZmxhdCIsImdldEF0dGFja2luZ01vdmVzRm9yQ29sb3IiLCJwYXduU3F1YXJlIiwicGF3biIsImNhcHR1cmVNb3ZlcyIsInNxdWFyZVZhbCIsImVuUGFzc2FudCIsImNoZWNrUG9zIiwic3F1YXJlc0JldHdlZW5LaW5nQW5kUGllY2UiLCJyZW1vdmVNb3Zlc0JlaGluZFR3b1NxdWFyZXMiLCJzb3J0ZWQiLCJmdXJ0aGVzdFNxdWFyZSIsImNsb3Nlc3RTcXVhcmUiLCJyZW1vdmVkT25lRW5kIiwicmVtb3ZlTW92ZXNCZWhpbmRTcXVhcmUiLCJyZW1vdmVkQm90aEVuZHMiLCJyZXZlcnNlIiwiY29weSIsImluZGV4Iiwic3BsaWNlIiwic3RhcnRpbmdTcXVhcmUiLCJmaWx0ZXJlZE1vdmVzIiwiYWxsVmVjdG9ycyIsIm9ic3RydWN0aW9uVmVjdG9ycyIsImNsb3Nlc3RPYnN0cnVjdGlvbiIsImtpbmciLCJvcHBDb2xvciIsImFsbEVuZW15TW92ZXMiLCJnZXREaXNjb3ZlcmVkQ2hlY2siLCJraW5nQ29sb3IiLCJ2YWNhdGVkIiwiY2FuQmxvY2tPckNhcHR1cmVDaGVjayIsImJsb2NrT3JDYXB0dXJlU3F1YXJlcyIsIm93blBpZWNlTW92ZXMiLCJzb21lIiwibW92ZSIsImZpbGVzIiwicmFua3MiLCJDYXN0bGUiLCJ3aGl0ZUtpbmdzaWRlIiwid2hpdGVRdWVlbnNpZGUiLCJibGFja0tpbmdzaWRlIiwiYmxhY2tRdWVlbnNpZGUiLCJ3aGl0ZSIsImtpbmdzaWRlIiwicXVlZW5zaWRlIiwiYmxhY2siLCJjcmVhdGVCb2FyZCIsImZpbGUiLCJmb3JFYWNoIiwicmFuayIsInNldCIsIk1hcCIsIkdhbWVib2FyZCIsInNxdWFyZXNHaXZpbmdDaGVjayIsIkNhc3RsZVJpZ2h0cyIsIm1ha2VNb3ZlIiwicHJvbW90ZSIsImF0IiwidmFsaWRhdGUiLCJwcm9tb3Rpb24iLCJjaGVja1RvZ2dsZSIsInRvZ2dsZSIsImNhc3RsZVNpZGUiLCJjYXN0bGVTcXVhcmVzIiwic2lkZSIsInNxdWFyZXMiLCJPYmplY3QiLCJjYXN0bGluZyIsImNhc3RsZSIsInJlbW92ZSIsImNhbkNhc3RsZSIsImNoZWNrSWZSb29rRXhpc3RzIiwib3BwTW92ZXMiLCJyb29rRXhpc3RzIiwibG9vcFN0YXJ0IiwibG9vcEVuZCIsImkiLCJraW5nUG9zaXRpb24iLCJyb29rUG9zIiwiZ2V0Um9va1BvcyIsInBpZWNlTWFwIiwicm9vayIsImZpbmQiLCJnZXRSaWdodHNBZnRlck1vdmUiLCJjYXN0bGVSaWdodHMiLCJnZXRTcXVhcmUiLCJjdXJyZW50IiwiZW5QYXNzYW50U3F1YXJlIiwic2V0RW5QYXNzYW50Iiwic3F1YXJlT2JqIiwidmFsdWVzIiwidW5kZWZpbmVkIiwicGxhY2UiLCJwaWVjZVR5cGUiLCJ2YWx1ZSIsInNxdWFyZXNHaXZpbmdDaGVja0FmdGVyTW92ZSIsImVuZCIsInBpZWNlSGl0c0tpbmciLCJkaXNjb3ZlcmVkQ2hlY2siLCJpc0NoZWNrbWF0ZSIsImVuZE9mQm9hcmQiLCJIaXN0b3J5IiwicHJldkhpc3RvcnkiLCJoaXN0b3J5IiwicGllY2VQcmVmaXgiLCJwcmVmaXgiLCJib2FyZENvcHkiLCJzYW1lRmlsZSIsInRvVXBwZXJDYXNlIiwiY2FzdGxlTm90YXRpb24iLCJhZmZpeCIsImNhcHR1cmUiLCJzdWZmaXgiLCJjaGVjayIsIm5vdGF0aW9uIiwiY2hlY2ttYXRlIiwiaW5zZXJ0TW92ZSIsImxhc3RNb3ZlUGFpciIsIm5ld01vdmVQYWlyIiwic3RhbmRhcmQiLCJrbmlnaHQiLCJiaXNob3AiLCJxdWVlbiIsInN0YXJ0aW5nUG9zaXRpb25zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///708\n")}},__webpack_require__={d:(Q,F)=>{for(var B in F)__webpack_require__.o(F,B)&&!__webpack_require__.o(Q,B)&&Object.defineProperty(Q,B,{enumerable:!0,get:F[B]})},o:(Q,F)=>Object.prototype.hasOwnProperty.call(Q,F),r:Q=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})}},__webpack_exports__={};return __webpack_modules__[708](0,__webpack_exports__,__webpack_require__),__webpack_exports__})()}));