!function(Q,F){"object"==typeof exports&&"object"==typeof module?module.exports=F():"function"==typeof define&&define.amd?define([],F):"object"==typeof exports?exports.croChess=F():Q.croChess=F()}(this,(()=>(()=>{"use strict";var __webpack_modules__={327:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"Castle\": () => (/* reexport */ Castle),\n  \"Gameboard\": () => (/* reexport */ src_Gameboard),\n  \"History\": () => (/* reexport */ History),\n  \"files\": () => (/* reexport */ files),\n  \"ranks\": () => (/* reexport */ ranks),\n  \"startingPositions\": () => (/* reexport */ startingPositions_namespaceObject)\n});\n\n// NAMESPACE OBJECT: ./src/startingPositions.ts\nvar startingPositions_namespaceObject = {};\n__webpack_require__.r(startingPositions_namespaceObject);\n__webpack_require__.d(startingPositions_namespaceObject, {\n  \"standard\": () => (standard)\n});\n\n;// CONCATENATED MODULE: ./src/utils/helpers.ts\nfunction toXY(square) {\n  const [x, y] = square.split('');\n  return {\n    x: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'].indexOf(x.toLowerCase()),\n    y: Number(y)\n  };\n}\nfunction fromXY(coord) {\n  const {\n    x,\n    y\n  } = coord;\n  const col = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'][x];\n  if (!col) return '';\n  return col.concat(y.toString());\n}\nconst calcDistance = squareOne => squareTwo => {\n  const {\n    x: x1,\n    y: y1\n  } = toXY(squareOne);\n  const {\n    x: x2,\n    y: y2\n  } = toXY(squareTwo);\n  const xDiff = x1 - x2;\n  const yDiff = y1 - y2;\n  return {\n    xDiff,\n    yDiff\n  };\n};\nfunction getPieceFromAbbr(abbr) {\n  switch (abbr) {\n    case 'K':\n      return 'king';\n\n    case 'Q':\n      return 'queen';\n\n    case 'N':\n      return 'knight';\n\n    case 'B':\n      return 'bishop';\n\n    case 'R':\n      return 'rook';\n  }\n}\nfunction parseNotation(notation) {\n  const move = {};\n  const replaced = notation.replace(/[+x#]/, '');\n\n  if (+replaced[0] === 0) {\n    // this is castle\n    move.castle = replaced.length === 3 ? 'kingside' : 'queenside';\n    return move;\n  }\n\n  if (replaced[0].toUpperCase() === replaced[0]) {\n    // this is piece move\n    move.pieceType = getPieceFromAbbr(replaced[0]);\n    move.to = replaced.slice(-2);\n\n    switch (replaced.length) {\n      case 4:\n        move.from = replaced[1];\n        break;\n\n      case 5:\n        move.from = replaced.slice(1, 3);\n        break;\n    }\n\n    return move;\n  } else {\n    // is a pawn move\n    move.pieceType = 'pawn';\n\n    if (replaced.includes('=')) {\n      // indicates promotion\n      move.promote = getPieceFromAbbr(replaced.slice(-1));\n    }\n\n    const promoteNoteIndex = replaced.indexOf('=');\n    const noPromoteNotation = replaced.slice(0, promoteNoteIndex === -1 ? replaced.length : promoteNoteIndex);\n\n    if (noPromoteNotation.length === 3) {\n      move.from = replaced[0];\n    }\n\n    move.to = noPromoteNotation.slice(-2);\n  }\n\n  return move;\n}\nfunction deepCopy2dArray(arr) {\n  return arr.map(n => [...n]);\n}\nfunction comparePieceMaps(pm1, pm2) {\n  let color;\n\n  for (color in pm1) {\n    const map = pm1[color];\n    let pieceType;\n\n    for (pieceType in map) {\n      const squares = map[pieceType];\n      const squares2 = pm2[color][pieceType];\n      if (squares.length !== squares2.length) return false;\n\n      for (let j = 0; j < squares.length; j++) {\n        if (color === 'black' && pieceType === 'pawn') if (squares[j] !== squares2[j]) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n;// CONCATENATED MODULE: ./src/Piece.ts\n\n\n\nconst Piece = (color, type) => {\n  function hasMove(from, to) {\n    switch (type) {\n      case 'king':\n        {\n          const oneSquareVert = utils_moves.yByN(1)(from)(to) && utils_moves.xByN(0)(from)(to);\n          const oneSquareLateral = utils_moves.xByN(1)(from)(to) && utils_moves.yByN(0)(from)(to);\n          const oneSquareDiagonally = utils_moves.yByN(1)(from)(to) && utils_moves.xByN(1)(from)(to);\n          return from !== to && (oneSquareDiagonally || oneSquareVert || oneSquareLateral);\n        }\n\n      case 'queen':\n        {\n          return from !== to && (utils_moves.diagonal(from)(to) || utils_moves.vertAndLateral(from)(to));\n        }\n\n      case 'bishop':\n        {\n          return from !== to && utils_moves.diagonal(from)(to);\n        }\n\n      case 'knight':\n        {\n          return from !== to && (utils_moves.xByN(1)(from)(to) && utils_moves.yByN(2)(from)(to) || utils_moves.xByN(2)(from)(to) && utils_moves.yByN(1)(from)(to));\n        }\n\n      case 'rook':\n        {\n          return from !== to && utils_moves.vertAndLateral(to)(from);\n        }\n\n      case 'pawn':\n        {\n          const {\n            x: x1,\n            y: y1\n          } = toXY(from);\n          const {\n            x: x2,\n            y: y2\n          } = toXY(to);\n          const onlyMovesInFront = color === 'white' ? y1 < y2 : y1 > y2;\n          const regularMove = utils_moves.yByN(1)(from)(to) && x1 === x2;\n          const firstMove = color === 'white' ? y1 === 2 : y1 === 7;\n          const jumpTwo = utils_moves.yByN(2)(from)(to) && x1 === x2;\n          return from !== to && onlyMovesInFront && (regularMove || firstMove && jumpTwo);\n        }\n    }\n  }\n\n  function getPawnCaptures(origin) {\n    if (type !== 'pawn') return;\n    const {\n      x,\n      y\n    } = toXY(origin);\n    const newY = color === 'white' ? y + 1 : y - 1;\n    const captureOne = {\n      x: x + 1,\n      y: newY\n    };\n    const captureTwo = {\n      x: x - 1,\n      y: newY\n    };\n    return [fromXY(captureOne), fromXY(captureTwo)];\n  }\n\n  return {\n    hasMove,\n    getPawnCaptures,\n\n    get type() {\n      return type;\n    },\n\n    get color() {\n      return color;\n    }\n\n  };\n};\n\n/* harmony default export */ const src_Piece = (Piece);\n;// CONCATENATED MODULE: ./src/utils/moves.ts\n\n\nconst moves = {\n  vertAndLateral: from => to => {\n    const [x1, y1] = from.split('');\n    const [x2, y2] = to.split('');\n    return x1 === x2 || y1 === y2;\n  },\n  diagonal: from => to => {\n    const {\n      x: x1,\n      y: y1\n    } = toXY(from);\n    const {\n      x: x2,\n      y: y2\n    } = toXY(to);\n    return Math.abs(x2 - x1) === Math.abs(y2 - y1);\n  },\n  xByN: num => from => to => {\n    const {\n      x: x1\n    } = toXY(from);\n    const {\n      x: x2\n    } = toXY(to);\n    return Math.abs(x1 - x2) === num;\n  },\n  yByN: num => from => to => {\n    const {\n      y: y1\n    } = toXY(from);\n    const {\n      y: y2\n    } = toXY(to);\n    return Math.abs(y1 - y2) === num;\n  }\n};\n/* harmony default export */ const utils_moves = (moves);\n/* dealing with move vectors */\n\nfunction splitIntoVectors(arrayOfMoves, start) {\n  return arrayOfMoves.reduce((acc, curr) => {\n    const {\n      xDiff,\n      yDiff\n    } = calcDistance(start)(curr);\n    let vector = '';\n    if (yDiff !== 0) vector = yDiff < 0 ? 'up' : 'down';\n    if (xDiff !== 0) vector += xDiff < 0 ? 'Right' : 'Left'; // normalize vector name\n\n    vector = vector.charAt(0).toLowerCase() + vector.slice(1);\n    acc[vector] = acc[vector] || [];\n    acc[vector].push(curr);\n    return acc;\n  }, {});\n}\n\nfunction getBeginningOfVector(vector) {\n  if (vector.length === 0) return '';\n  return vector.reduce((acc, curr) => {\n    const {\n      x: x1,\n      y: y1\n    } = toXY(acc);\n    const {\n      x: x2,\n      y: y2\n    } = toXY(curr);\n    const accIsBeginning = x1 === x2 ? y1 < y2 : x1 < x2;\n    return accIsBeginning ? acc : curr;\n  });\n}\n\nconst getMovesAlongVector = (s1, s2, allSquares) => {\n  const liesSameVertOrLat = moves.vertAndLateral(s1)(s2);\n  const liesSameDiagonally = moves.diagonal(s1)(s2);\n  const liesOnSameLine = liesSameVertOrLat || liesSameDiagonally;\n  if (!liesOnSameLine) return [];\n  const matchingVector = liesSameDiagonally ? 'diagonal' : 'vertAndLateral';\n  const squaresAlongVector = allSquares.filter(s => moves[matchingVector](s1)(s) && moves[matchingVector](s2)(s));\n  return squaresAlongVector;\n};\n/* sort moves */\n\n\nconst sortMovesClosestTo = square => moves => {\n  return [...moves].sort((a, b) => {\n    const {\n      xDiff: x1Diff,\n      yDiff: y1Diff\n    } = calcDistance(square)(a);\n    const aDiff = Math.abs(x1Diff) + Math.abs(y1Diff);\n    const {\n      xDiff: x2Diff,\n      yDiff: y2Diff\n    } = calcDistance(square)(b);\n    const bDiff = Math.abs(x2Diff) + Math.abs(y2Diff);\n    return aDiff - bDiff;\n  });\n};\n/* get moves */\n\n\nfunction getPossibleMoves(origin, board) {\n  // get all moves that can happen if no other pieces were on the board\n  const allSquares = Array.from(board.keys());\n  const square = board.get(origin);\n  const {\n    type,\n    color\n  } = square.piece;\n  const piece = src_Piece(color, type);\n  return allSquares.filter(s => piece.hasMove(origin, s));\n}\n\nfunction getLegalMoves(origin, board) {\n  // get moves regardless of whether or not there is check\n  const square = board.get(origin);\n  const piece = square.piece;\n  const possibleMoves = getPossibleMoves(origin, board);\n  const obstructions = possibleMoves.filter(s => {\n    var _a;\n\n    return (_a = board.get(s)) === null || _a === void 0 ? void 0 : _a.piece;\n  });\n\n  if (!obstructions.length) {\n    switch (piece.type) {\n      case 'pawn':\n        return [...getPawnCaptures(origin, board), ...possibleMoves];\n\n      case 'king':\n        return removeProtectedSquares(origin, possibleMoves, board);\n\n      default:\n        return possibleMoves;\n    }\n  }\n\n  let legalMoves = [];\n\n  switch (piece.type) {\n    case 'knight':\n      {\n        legalMoves = possibleMoves;\n        break;\n      }\n\n    case 'pawn':\n      {\n        const capturesAvailable = getPawnCaptures(origin, board);\n        const unobstructedMoves = removeMovesWithPieces(removeObstructedMoves(origin, possibleMoves, obstructions), board);\n        legalMoves = [...capturesAvailable, ...unobstructedMoves];\n        break;\n      }\n\n    case 'king':\n      {\n        legalMoves = removeProtectedSquares(origin, possibleMoves, board);\n        break;\n      }\n\n    default:\n      {\n        legalMoves = removeObstructedMoves(origin, possibleMoves, obstructions);\n      }\n  }\n\n  return removeMovesWithPieces(legalMoves, board, piece.color);\n}\n\nfunction getLegalMovesInCheck(origin, board, kingPos, squareGivingCheck) {\n  const squaresThatDealWithCheck = getSquaresBetweenKingAndCheck(kingPos, squareGivingCheck, Array.from(board.keys()));\n  const moves = getLegalMoves(origin, board);\n  return moves.filter(s => squaresThatDealWithCheck.includes(s));\n}\n\nfunction getAttackingMoves(origin, board) {\n  const square = board.get(origin);\n  const {\n    type,\n    color\n  } = square.piece;\n\n  switch (type) {\n    case 'pawn':\n      {\n        const piece = src_Piece(color, 'pawn');\n        return piece.getPawnCaptures(origin);\n      }\n\n    case 'king':\n      {\n        // need to do this because getLegalMoves will recursively call removeProtectedSquares otherwise\n        const attackingMoves = removeMovesWithPieces(getPossibleMoves(origin, board), board, color);\n        return attackingMoves;\n      }\n\n    default:\n      return getLegalMoves(origin, board);\n  }\n}\n\nfunction getAllMovesForColor(color, board, skipKing) {\n  const allMoves = [];\n\n  for (const [square, {\n    piece\n  }] of board.entries()) {\n    if (!piece) continue;\n    if (piece.color !== color) continue;\n    if (skipKing && piece.type === 'king') continue;\n    allMoves.push(getLegalMoves(square, board));\n  }\n\n  return allMoves.flat();\n}\n\nfunction getAttackingMovesForColor(color, board) {\n  const allMoves = [];\n\n  for (const [square, {\n    piece\n  }] of board.entries()) {\n    if (!piece) continue;\n    if (piece.color !== color) continue;\n    allMoves.push(getAttackingMoves(square, board));\n  }\n\n  return allMoves.flat();\n}\n\nfunction getPawnCaptures(pawnSquare, board) {\n  var _a;\n\n  const {\n    color\n  } = (_a = board.get(pawnSquare)) === null || _a === void 0 ? void 0 : _a.piece;\n  const pawn = src_Piece(color, 'pawn');\n  const captureMoves = pawn.getPawnCaptures(pawnSquare);\n  if (!captureMoves) return [];\n  return captureMoves.filter(s => {\n    const squareVal = board.get(s);\n    if (!squareVal) return false;\n    const piece = squareVal.piece;\n    const enPassant = squareVal.enPassant;\n    return piece && piece.color !== pawn.color || enPassant && enPassant.color !== pawn.color;\n  });\n}\n\nfunction getSquaresBetweenKingAndCheck(kingPos, checkPos, allSquares) {\n  // includes kingPos and checkPos\n  const squaresAlongVector = getMovesAlongVector(kingPos, checkPos, allSquares);\n  const squaresBetweenKingAndPiece = removeMovesBehindTwoSquares(kingPos, checkPos, squaresAlongVector);\n  return squaresBetweenKingAndPiece;\n}\n/* filter moves */\n\n\nfunction removeMovesBehindTwoSquares(s1, s2, vector) {\n  const sorted = sortMovesClosestTo(getBeginningOfVector(vector))(vector);\n  let furthestSquare;\n  let closestSquare;\n\n  if (sorted.indexOf(s1) > sorted.indexOf(s2)) {\n    furthestSquare = s1;\n    closestSquare = s2;\n  } else {\n    furthestSquare = s2;\n    closestSquare = s1;\n  }\n\n  const removedOneEnd = removeMovesBehindSquare(furthestSquare)(sorted);\n  const removedBothEnds = removeMovesBehindSquare(closestSquare)(removedOneEnd.reverse());\n  return removedBothEnds;\n}\n\nconst removeMovesBehindSquare = square => moves => {\n  const copy = [...moves];\n  const index = moves.indexOf(square);\n  if (index === -1) return [];\n  copy.splice(index + 1);\n  return copy;\n};\n\nfunction removeObstructedMoves(startingSquare, possibleMoves, obstructions) {\n  // a) split possible moves into vectors (up,down,left,right, and/or diagonals)\n  // b) see which obstructions belong to which vector\n  // c) find the closest obstruction\n  // d) remove all the moves behind that obstruction\n  const filteredMoves = [];\n  const allVectors = splitIntoVectors(possibleMoves, startingSquare);\n  const obstructionVectors = splitIntoVectors(obstructions, startingSquare);\n\n  for (const vector in allVectors) {\n    if (!obstructionVectors[vector]) {\n      // look for vector obstruction is on\n      filteredMoves.push(allVectors[vector]);\n      continue;\n    }\n\n    const sorted = sortMovesClosestTo(startingSquare)(allVectors[vector]);\n    const closestObstruction = sortMovesClosestTo(startingSquare)(obstructionVectors[vector])[0];\n    filteredMoves.push(removeMovesBehindSquare(closestObstruction)(sorted));\n  }\n\n  return filteredMoves.flat();\n}\n\nfunction removeProtectedSquares(kingPos, possibleMoves, board) {\n  var _a;\n\n  const king = (_a = board.get(kingPos)) === null || _a === void 0 ? void 0 : _a.piece;\n  const oppColor = king.color === 'white' ? 'black' : 'white';\n  const enemyPiecesInVicinity = possibleMoves.filter(s => {\n    var _a, _b;\n\n    return ((_b = (_a = board.get(s)) === null || _a === void 0 ? void 0 : _a.piece) === null || _b === void 0 ? void 0 : _b.color) === oppColor;\n  });\n  const squaresProtectedByEnemyInVicinity = enemyPiecesInVicinity.map(s => getAttackingMoves(s, board)).flat(); // bc king cant move if square is protected\n  // set king piece on each square in possible moves to find which squares are protected\n\n  const boardCopy = new Map(board);\n  possibleMoves.forEach(s => boardCopy.set(s, {\n    piece: king\n  }));\n  const squaresProtectedByRange = getAttackingMovesForColor(oppColor, boardCopy);\n  return possibleMoves.filter(s => {\n    return !squaresProtectedByRange.includes(s) && !squaresProtectedByEnemyInVicinity.includes(s);\n  });\n}\n\nfunction removeMovesWithPieces(moves, board, color) {\n  return moves.filter(s => {\n    const squareVal = board.get(s);\n    if (!squareVal) return false;\n    if (color) return !squareVal.piece || squareVal.piece.color !== color;else return !squareVal.piece;\n  });\n}\n/* gameboard checks */\n\n\nfunction getDiscoveredCheck(kingPos, kingColor, vacated, board) {\n  var _a; // openSquare is a square just vacated\n\n\n  let squaresAlongVector = getMovesAlongVector(kingPos, vacated, Array.from(board.keys()));\n  squaresAlongVector = squaresAlongVector.filter(s => s !== kingPos && s !== vacated);\n  if (!squaresAlongVector.length) return '';\n\n  for (const square of squaresAlongVector) {\n    const piece = (_a = board.get(square)) === null || _a === void 0 ? void 0 : _a.piece;\n    if (!piece || piece.color === kingColor) continue;\n    const legalMoves = getLegalMoves(square, board);\n    if (legalMoves.includes(kingPos)) return square;\n  }\n\n  return '';\n}\n\nfunction canBlockOrCaptureCheck(kingPos, squareGivingCheck, board) {\n  var _a;\n\n  const king = (_a = board.get(kingPos)) === null || _a === void 0 ? void 0 : _a.piece;\n  const blockOrCaptureSquares = getSquaresBetweenKingAndCheck(kingPos, squareGivingCheck, Array.from(board.keys())); // also includes check square\n\n  const ownPieceMoves = getAllMovesForColor(king.color, board, true);\n  return ownPieceMoves.some(move => blockOrCaptureSquares.includes(move));\n}\n\nfunction getPiecesWithMove(board, move, pieceType, color) {\n  const pieceSquares = [];\n\n  for (const [square, {\n    piece\n  }] of board.entries()) {\n    if (!piece) continue;\n    if (piece.color !== color) continue;\n    if (piece.type !== pieceType) continue;\n  }\n}\n\n\n;// CONCATENATED MODULE: ./src/ranksAndFiles.ts\nconst files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];\nconst ranks = [1, 2, 3, 4, 5, 6, 7, 8];\n\n;// CONCATENATED MODULE: ./src/Castle.ts\nfunction Castle(whiteKingside, whiteQueenside, blackKingside, blackQueenside) {\n  return {\n    white: {\n      kingside: whiteKingside,\n      queenside: whiteQueenside\n    },\n    black: {\n      kingside: blackKingside,\n      queenside: blackQueenside\n    }\n  };\n}\n;// CONCATENATED MODULE: ./src/moveNotation.ts\nconst moveNotation = notation => {\n  function castle(side) {\n    notation = side === 'kingside' ? '0-0' : '0-0-0';\n    return notation;\n  }\n\n  const affix = {\n    pieceNotation: (pieceType, differentiation) => {\n      differentiation = differentiation || '';\n\n      switch (pieceType) {\n        case 'pawn':\n          {\n            notation = differentiation + notation;\n            return notation;\n          }\n\n        case 'king':\n          {\n            notation = 'K' + notation;\n            return notation;\n          }\n\n        case 'knight':\n          {\n            notation = 'N' + differentiation + notation;\n            return notation;\n          }\n\n        default:\n          {\n            notation = pieceType[0].toUpperCase() + differentiation + notation;\n            return notation;\n          }\n      }\n    },\n    capture: () => {\n      notation = `x${notation}`;\n      return notation;\n    },\n    promote: pieceType => {\n      const suffix = '=' + pieceType === 'knight' ? 'N' : pieceType.charAt(0).toUpperCase();\n      notation += '=' + suffix;\n      return notation;\n    },\n    check: () => {\n      notation += '+';\n      return notation;\n    },\n    checkmate: () => {\n      notation += '#';\n      return notation;\n    }\n  };\n\n  function get(moveDetails) {\n    const {\n      capture,\n      castle: castleSide,\n      promote,\n      check,\n      checkmate,\n      pieceType,\n      differentiation\n    } = moveDetails;\n    if (castleSide) return castle(castleSide);\n    if (capture) affix.capture();\n    affix.pieceNotation(pieceType, differentiation);\n    if (promote) affix.promote(promote);\n    if (checkmate) affix.checkmate();else if (check) affix.check();\n    return notation;\n  }\n\n  return {\n    get\n  };\n};\n\n/* harmony default export */ const src_moveNotation = (moveNotation);\n;// CONCATENATED MODULE: ./src/Gameboard.ts\n\n\n\n\n\n\n\n\nfunction createBoard() {\n  return files.reduce((acc, file) => {\n    ranks.forEach(rank => {\n      const square = file.concat(rank.toString());\n      acc.set(square, {\n        piece: null\n      });\n    });\n    return acc;\n  }, new Map());\n}\n\nconst Gameboard = (board = createBoard(), squaresGivingCheck, CastleRights) => {\n  board = new Map(board);\n\n  function placePieces(pieceMap, boardMap = board) {\n    let color;\n\n    for (color in pieceMap) {\n      const map = pieceMap[color];\n      let pieceType;\n\n      for (pieceType in map) {\n        const squares = map[pieceType];\n        squares.forEach(s => at(s, boardMap).place({\n          type: pieceType,\n          color: color\n        }));\n      }\n    }\n  }\n\n  function makeMove(s1, s2, promote) {\n    const piece = at(s1).piece; // validate move\n\n    if (!piece) return;\n    if (!validate.move(s1, s2)) return;\n    if (promote && !validate.promotion(s1, s2)) return;\n\n    switch (piece.type) {\n      case 'pawn':\n        {\n          if (promote) {\n            at(s1).promote(promote);\n          }\n\n          if (enPassant.isCapture(s1, s2)) {\n            enPassant.capture(s2);\n          }\n\n          enPassant.remove();\n\n          if (enPassant.checkToggle(s1, s2)) {\n            enPassant.toggle(piece.color, s2);\n          }\n\n          from(s1).to(s2);\n          break;\n        }\n\n      case 'king':\n        {\n          // check if move is castle\n          const castleSide = get.castleSide(piece.color, s2);\n          if (castleSide) castle(piece.color, castleSide);else from(s1).to(s2);\n          enPassant.remove();\n          break;\n        }\n\n      default:\n        from(s1).to(s2);\n        enPassant.remove();\n    }\n\n    return board;\n  }\n\n  function castle(color, side, boardMap = board) {\n    const castleSquares = get.castleSquares(color)[side];\n    const kingPos = get.kingPosition(color, boardMap);\n    const rookPos = getRookPos();\n    from(rookPos, boardMap).to(castleSquares[0]);\n    from(kingPos, boardMap).to(castleSquares[1]);\n\n    function getRookPos() {\n      const pieceMap = get.pieceMap(boardMap);\n      const rookPos = pieceMap[color].rook.find(square => {\n        const file = square.split('')[0];\n        return side === 'kingside' ? files.indexOf(file) > 3 : files.indexOf(file) < 3;\n      });\n      return rookPos;\n    } // need to get king position\n    // need to get castle squares\n    // need to find rook\n\n  }\n\n  const enPassant = (() => {\n    function getSquare(current, color) {\n      const {\n        x,\n        y\n      } = toXY(current);\n      const newY = color === 'white' ? y - 1 : y + 1;\n      return fromXY({\n        x,\n        y: newY\n      });\n    }\n\n    return {\n      checkToggle: (from, to) => {\n        const {\n          y: y1\n        } = toXY(from);\n        const {\n          y: y2\n        } = toXY(to);\n        return Math.abs(y1 - y2) === 2;\n      },\n      toggle: (color, current, boardMap = board) => {\n        const enPassantSquare = getSquare(current, color);\n        at(enPassantSquare, boardMap).setEnPassant(color, current);\n      },\n      remove: (boardMap = board) => {\n        for (const squareObj of boardMap.values()) {\n          if (squareObj.enPassant) return squareObj.enPassant = undefined;\n        }\n      },\n      isCapture: (from, to, boardMap = board) => {\n        var _a;\n\n        const piece = at(from, boardMap).piece;\n        const enPassant = (_a = boardMap.get(to)) === null || _a === void 0 ? void 0 : _a.enPassant;\n        if (!piece || piece.type !== 'pawn') return false;\n        if (!enPassant) return false;\n        if (enPassant.color === piece.color) return false;\n        return true;\n      },\n      capture: (to, boardMap = board) => {\n        var _a;\n\n        const enPassant = (_a = boardMap.get(to)) === null || _a === void 0 ? void 0 : _a.enPassant;\n        at(enPassant.current, boardMap).remove();\n      }\n    };\n  })();\n\n  const isDraw = {\n    byThreefoldRepetition: (allPieceMaps, newPieceMap) => {\n      return allPieceMaps.filter(pm => {\n        return comparePieceMaps(pm, newPieceMap);\n      }).length >= 3;\n    }\n  };\n\n  const at = (square, boardMap = board) => ({\n    place: piece => {\n      if (!boardMap.get(square)) return;\n      boardMap.set(square, {\n        piece\n      });\n    },\n    remove: () => {\n      if (!boardMap.get(square)) return;\n      boardMap.set(square, {\n        piece: null\n      });\n    },\n    promote: pieceType => {\n      const squareVal = boardMap.get(square);\n      const piece = squareVal === null || squareVal === void 0 ? void 0 : squareVal.piece;\n      if (!piece) return;\n      boardMap.set(square, Object.assign(Object.assign({}, squareVal), {\n        piece: Object.assign(Object.assign({}, piece), {\n          type: pieceType\n        })\n      }));\n    },\n    setEnPassant: (color, current) => {\n      if (!boardMap.get(square)) return;\n      boardMap.set(square, {\n        piece: null,\n        enPassant: {\n          current\n          /* square pawn is on */\n          ,\n          color\n        }\n      });\n    },\n\n    get piece() {\n      var _a;\n\n      return (_a = boardMap.get(square)) === null || _a === void 0 ? void 0 : _a.piece;\n    },\n\n    getLegalMoves: (checks = squaresGivingCheck || []) => {\n      const {\n        type,\n        color\n      } = at(square, boardMap).piece;\n\n      switch (checks.length) {\n        case 2:\n          {\n            if (type !== 'king') return [];\n            return getLegalMoves(square, boardMap);\n          }\n\n        case 1:\n          {\n            if (type === 'king') return getLegalMoves(square, boardMap);else return getLegalMovesInCheck(square, boardMap, get.kingPosition(color), checks[0]);\n          }\n\n        default:\n          {\n            if (type === 'king') {\n              let legalMoves = getLegalMoves(square, boardMap);\n              if (get.canCastle(color, 'kingside')) legalMoves = [...legalMoves, ...get.castleSquares(color).kingside];\n              if (get.canCastle(color, 'queenside')) legalMoves = [...legalMoves, ...get.castleSquares(color).queenside];\n              return legalMoves;\n            } else return getLegalMoves(square, boardMap);\n          }\n      }\n    }\n  });\n\n  const from = (s1, boardMap = board) => ({\n    to: s2 => {\n      const piece = at(s1, boardMap).piece;\n      if (!piece) return; // move piece\n\n      at(s1, boardMap).remove();\n      at(s2, boardMap).place(piece);\n    }\n  });\n\n  const get = {\n    kingPosition: (color, boardMap = board) => {\n      for (const [square, value] of boardMap.entries()) {\n        if (value.piece && value.piece.type === 'king' && value.piece.color === color) return square;\n      }\n    },\n    pieceMap: (boardMap = board) => {\n      const pieceMap = {\n        white: {},\n        black: {}\n      };\n\n      for (const [square, value] of boardMap.entries()) {\n        const {\n          piece\n        } = value;\n        if (!piece) continue;\n        const {\n          type,\n          color\n        } = piece;\n        if (pieceMap[color][type]) pieceMap[color][type].push(square);else pieceMap[color][type] = [square];\n      }\n\n      return pieceMap;\n    },\n    piecesThatHitSquare: (color, pieceType, square, boardMap = board) => {\n      const pieceMap = get.pieceMap(boardMap);\n      if (pieceMap[color][pieceType].includes(square)) return [];\n      const pieces = [];\n      if (pieceMap[color][pieceType].length <= 1) return [];\n      pieceMap[color][pieceType].forEach(s => {\n        if (at(s, boardMap).getLegalMoves().includes(square)) pieces.push(s);\n      });\n      return pieces;\n    },\n    squaresGivingCheckAfterMove: (from, end) => {\n      var _a;\n\n      const squaresGivingCheck = [];\n      const piece = (_a = board.get(end)) === null || _a === void 0 ? void 0 : _a.piece;\n      const oppColor = piece.color === 'white' ? 'black' : 'white';\n      const kingPosition = get.kingPosition(oppColor);\n      const pieceHitsKing = getLegalMoves(end, board).includes(kingPosition);\n      if (pieceHitsKing) squaresGivingCheck.push(end);\n      const discoveredCheck = getDiscoveredCheck(kingPosition, oppColor, from, board);\n      if (discoveredCheck && discoveredCheck !== end) squaresGivingCheck.push(discoveredCheck);\n      return squaresGivingCheck;\n    },\n    isCheckmate: (colorOfKing, squaresGivingCheck, boardMap = board) => {\n      const kingPos = get.kingPosition(colorOfKing, boardMap);\n      const legalMoves = at(kingPos, boardMap).getLegalMoves(); // check if check can be blocked\n\n      if (squaresGivingCheck.length === 1) {\n        if (canBlockOrCaptureCheck(kingPos, squaresGivingCheck[0], boardMap)) return false;\n      }\n\n      if (legalMoves.length) return false;\n      return true;\n    },\n\n    castleSquares(color) {\n      const rank = color === 'white' ? 1 : 8;\n      return {\n        kingside: [`f${rank}`, `g${rank}`],\n        queenside: [`d${rank}`, `c${rank}`]\n      };\n    },\n\n    castleSide(color, to) {\n      let castleSide = '';\n      const castleSquares = get.castleSquares(color);\n\n      for (const [side, squares] of Object.entries(castleSquares)) {\n        if (squares[1] === to) castleSide = side;\n      }\n\n      return castleSide;\n    },\n\n    castleRightsAfterMove: (square, boardMap = board) => {\n      const piece = at(square, boardMap).piece;\n      const castleRights = CastleRights || Castle(true, true, true, true);\n\n      if (castleRights[piece.color].kingside || castleRights[piece.color].queenside) {\n        // check if i need to change castling rights\n        if (piece.type === 'king') {\n          castleRights[piece.color].kingside = false;\n          castleRights[piece.color].queenside = false;\n        }\n\n        if (piece.type === 'rook') {\n          // need to find if it is kingside or queenside rook\n          const [file] = square.split('');\n          const kingside = files.indexOf(file) > 3;\n          if (kingside) castleRights[piece.color].kingside = false;else castleRights[piece.color].queenside = false;\n        }\n      }\n\n      return castleRights;\n    },\n    canCastle: (color, side, boardMap = board) => {\n      if (CastleRights && !CastleRights[color][side]) return false; // check if rook still exists\n\n      if (!checkIfRookExists()) return false;\n      const oppColor = color === 'white' ? 'black' : 'white';\n      const oppMoves = getAttackingMovesForColor(oppColor, boardMap);\n      const castleSquares = get.castleSquares(color)[side];\n\n      for (const square of castleSquares) {\n        // check if castle square is cleared\n        if (at(square, boardMap).piece) return false; // make sure castle square isnt attacked\n\n        if (oppMoves.includes(square)) return false;\n      }\n\n      return true;\n\n      function checkIfRookExists() {\n        let rookExists = false;\n        const rank = color === 'white' ? 1 : 8;\n        const loopStart = side === 'queenside' ? files.indexOf('a') : files.indexOf('d');\n        const loopEnd = side === 'queenside' ? files.indexOf('e') : files.indexOf('h');\n\n        for (let i = loopStart; i <= loopEnd; i++) {\n          const square = files[i] + rank;\n          const piece = at(square, boardMap).piece;\n          if (!piece) continue;\n          if (piece.type === 'rook') rookExists = true;\n        }\n\n        return rookExists;\n      }\n    },\n    pieceMapsFromHistory: history => {\n      const pieceMaps = [];\n      const boardMap = createBoard();\n      placePieces(standard, boardMap);\n      let pieceMap = standard; // history is 2d array\n\n      const flat = history.flat();\n      /* iterate over history */\n\n      for (const [i, m] of flat.entries()) {\n        const parsed = parseNotation(m);\n        const color = i % 2 === 0 ? 'white' : 'black';\n\n        if (parsed.castle) {\n          castle(color, parsed.castle, boardMap);\n          pieceMap = get.pieceMap(boardMap);\n          pieceMaps.push(pieceMap);\n          continue;\n        }\n\n        const possiblePieces = pieceMap[color][parsed.pieceType].filter(s => getLegalMoves(s, boardMap).includes(parsed.to)); // get 'from' square\n\n        let s1;\n\n        if (parsed.from) {\n          const notation = parsed.from;\n          if (notation.length === 2) s1 = notation;else {\n            s1 = possiblePieces.find(s => {\n              // if notation is a number, that means piece is on the rank === notation, if not, same file\n              return isNaN(Number(notation)) ? s[0] === notation : s[1] === notation;\n            }) || '';\n          }\n        } else s1 = possiblePieces[0];\n\n        const piece = at(s1, boardMap).piece;\n\n        if (!s1 || !piece) {\n          break;\n        } // make move\n\n\n        if (piece.type === 'pawn') {\n          if (enPassant.isCapture(s1, parsed.to, boardMap)) {\n            enPassant.capture(parsed.to, boardMap);\n          }\n\n          enPassant.remove(boardMap);\n          if (enPassant.checkToggle(s1, parsed.to)) enPassant.toggle(color, parsed.to, boardMap);\n\n          if (parsed.promote) {\n            at(s1, boardMap).promote(parsed.promote);\n          }\n        } else enPassant.remove(boardMap);\n\n        from(s1, boardMap).to(parsed.to);\n        pieceMap = get.pieceMap(boardMap);\n        pieceMaps.push(pieceMap);\n      }\n\n      return pieceMaps;\n    },\n\n    moveNotation(from, to, promote, check, checkmate, boardMap = board) {\n      var _a;\n\n      const moveDetails = {};\n      const {\n        type,\n        color\n      } = at(from, boardMap).piece;\n      moveDetails.pieceType = type;\n      if (checkmate) moveDetails.checkmate = checkmate;else if (check) moveDetails.check = check;\n      let capture = false;\n\n      switch (type) {\n        case 'pawn':\n          {\n            capture = (_a = src_Piece(color, type).getPawnCaptures(from)) === null || _a === void 0 ? void 0 : _a.includes(to);\n            moveDetails.capture = capture;\n            if (capture) moveDetails.differentiation = from[0];\n            break;\n          }\n\n        default:\n          {\n            capture = !!at(to, boardMap).piece;\n            moveDetails.capture = capture;\n          }\n      }\n\n      if (promote) moveDetails.promote = promote; // get differentiation ie. when multiple pieces hit the same square\n\n      const piecesThatHitSquare = get.piecesThatHitSquare(color, type, to, boardMap);\n\n      switch (piecesThatHitSquare.length) {\n        case 3:\n          moveDetails.differentiation = from;\n          break;\n\n        case 2:\n          {\n            // need to find if on same file or rank\n            const otherPiece = piecesThatHitSquare.find(s => s !== from);\n            moveDetails.differentiation = otherPiece[0] === from[0] ? from[1] : from[0];\n          }\n      }\n\n      return src_moveNotation(to).get(moveDetails);\n    }\n\n  };\n  const validate = {\n    move: (from, to, boardMap = board) => {\n      const piece = at(from, boardMap).piece;\n      if (!piece) return false;\n      if (!at(from, boardMap).getLegalMoves().includes(to)) return false;\n      return true;\n    },\n    promotion: (from, to, boardMap = board) => {\n      const piece = at(from, boardMap).piece;\n      if ((piece === null || piece === void 0 ? void 0 : piece.type) !== 'pawn') return false;\n      const endOfBoard = piece.color === 'white' ? 8 : 1;\n      const [, rank] = to.split('');\n      if (+rank !== endOfBoard) return false;\n      return true;\n    }\n  };\n  return {\n    createBoard,\n    placePieces,\n    castle,\n    isDraw,\n    enPassant,\n    at,\n    from,\n    get,\n    validate,\n    makeMove,\n\n    get board() {\n      return board;\n    }\n\n  };\n};\n\n/* harmony default export */ const src_Gameboard = (Gameboard);\n;// CONCATENATED MODULE: ./src/History.ts\n\nfunction History(prevHistory) {\n  const history = deepCopy2dArray(prevHistory) || [];\n  return {\n    insertMove: notation => {\n      const lastPair = history[history.length - 1];\n\n      if (lastPair && lastPair.length === 1) {\n        lastPair.push(notation);\n      } else {\n        const newPair = [notation];\n        history.push(newPair);\n      }\n\n      return history;\n    }\n  };\n}\n;// CONCATENATED MODULE: ./src/startingPositions.ts\nconst standard = {\n  white: {\n    rook: ['a1', 'h1'],\n    knight: ['g1', 'b1'],\n    bishop: ['f1', 'c1'],\n    king: ['e1'],\n    queen: ['d1'],\n    pawn: ['a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2']\n  },\n  black: {\n    rook: ['a8', 'h8'],\n    knight: ['g8', 'b8'],\n    bishop: ['f8', 'c8'],\n    king: ['e8'],\n    queen: ['d8'],\n    pawn: ['a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7']\n  }\n};\n\n;// CONCATENATED MODULE: ./src/main.ts\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQXdPLGVBQU8sQ0FBQy9LLElBQVIsQ0FBYTRMLE9BQWI7QUFDRDs7QUFFRCxhQUFPYixPQUFQO0FBQ0Q7QUFYSSxHQUFQO0FBYUQsQzs7QUNsQkQsTUFBTUUsUUFBUSxHQUFnQjtBQUM1QjNFLE9BQUssRUFBRTtBQUNMc0MsUUFBSSxFQUFFLENBQUMsSUFBRCxFQUFPLElBQVAsQ0FERDtBQUVMaUQsVUFBTSxFQUFFLENBQUMsSUFBRCxFQUFPLElBQVAsQ0FGSDtBQUdMQyxVQUFNLEVBQUUsQ0FBQyxJQUFELEVBQU8sSUFBUCxDQUhIO0FBSUxsSCxRQUFJLEVBQUUsQ0FBQyxJQUFELENBSkQ7QUFLTG1ILFNBQUssRUFBRSxDQUFDLElBQUQsQ0FMRjtBQU1MekksUUFBSSxFQUFFLENBQUMsSUFBRCxFQUFPLElBQVAsRUFBYSxJQUFiLEVBQW1CLElBQW5CLEVBQXlCLElBQXpCLEVBQStCLElBQS9CLEVBQXFDLElBQXJDLEVBQTJDLElBQTNDO0FBTkQsR0FEcUI7QUFTNUJtRCxPQUFLLEVBQUU7QUFDTG1DLFFBQUksRUFBRSxDQUFDLElBQUQsRUFBTyxJQUFQLENBREQ7QUFFTGlELFVBQU0sRUFBRSxDQUFDLElBQUQsRUFBTyxJQUFQLENBRkg7QUFHTEMsVUFBTSxFQUFFLENBQUMsSUFBRCxFQUFPLElBQVAsQ0FISDtBQUlMbEgsUUFBSSxFQUFFLENBQUMsSUFBRCxDQUpEO0FBS0xtSCxTQUFLLEVBQUUsQ0FBQyxJQUFELENBTEY7QUFNTHpJLFFBQUksRUFBRSxDQUFDLElBQUQsRUFBTyxJQUFQLEVBQWEsSUFBYixFQUFtQixJQUFuQixFQUF5QixJQUF6QixFQUErQixJQUEvQixFQUFxQyxJQUFyQyxFQUEyQyxJQUEzQztBQU5EO0FBVHFCLENBQTlCOzs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3JvQ2hlc3MvLi9zcmMvdXRpbHMvaGVscGVycy50cz8yOGYzIiwid2VicGFjazovL2Nyb0NoZXNzLy4vc3JjL1BpZWNlLnRzPzJlYjgiLCJ3ZWJwYWNrOi8vY3JvQ2hlc3MvLi9zcmMvdXRpbHMvbW92ZXMudHM/NTBmYiIsIndlYnBhY2s6Ly9jcm9DaGVzcy8uL3NyYy9yYW5rc0FuZEZpbGVzLnRzP2U2MjEiLCJ3ZWJwYWNrOi8vY3JvQ2hlc3MvLi9zcmMvQ2FzdGxlLnRzPzFjZWEiLCJ3ZWJwYWNrOi8vY3JvQ2hlc3MvLi9zcmMvbW92ZU5vdGF0aW9uLnRzPzc2ZTUiLCJ3ZWJwYWNrOi8vY3JvQ2hlc3MvLi9zcmMvR2FtZWJvYXJkLnRzPzU3ZTMiLCJ3ZWJwYWNrOi8vY3JvQ2hlc3MvLi9zcmMvSGlzdG9yeS50cz80YzIxIiwid2VicGFjazovL2Nyb0NoZXNzLy4vc3JjL3N0YXJ0aW5nUG9zaXRpb25zLnRzPzNiYmMiLCJ3ZWJwYWNrOi8vY3JvQ2hlc3MvLi9zcmMvbWFpbi50cz9jZDQ5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEFsbFBpZWNlTWFwLFxuICBDb29yZCxcbiAgUGFyc2VkTm90YXRpb25JbnRlcmZhY2Vcbn0gZnJvbSAnLi4vdHlwZXMvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBQaWVjZUFiYnJldmlhdGlvbiwgU3F1YXJlIH0gZnJvbSAnLi4vdHlwZXMvdHlwZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gdG9YWShzcXVhcmU6IFNxdWFyZSk6IENvb3JkIHtcbiAgY29uc3QgW3gsIHldID0gc3F1YXJlLnNwbGl0KCcnKTtcbiAgcmV0dXJuIHtcbiAgICB4OiBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJywgJ2cnLCAnaCddLmluZGV4T2YoeC50b0xvd2VyQ2FzZSgpKSxcbiAgICB5OiBOdW1iZXIoeSlcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21YWShjb29yZDogQ29vcmQpOiBTcXVhcmUge1xuICBjb25zdCB7IHgsIHkgfSA9IGNvb3JkO1xuICBjb25zdCBjb2wgPSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJywgJ2cnLCAnaCddW3hdO1xuICBpZiAoIWNvbCkgcmV0dXJuICcnO1xuICByZXR1cm4gY29sLmNvbmNhdCh5LnRvU3RyaW5nKCkpO1xufVxuXG5leHBvcnQgY29uc3QgY2FsY0Rpc3RhbmNlID0gKHNxdWFyZU9uZTogc3RyaW5nKSA9PiAoc3F1YXJlVHdvOiBzdHJpbmcpID0+IHtcbiAgY29uc3QgeyB4OiB4MSwgeTogeTEgfSA9IHRvWFkoc3F1YXJlT25lKTtcbiAgY29uc3QgeyB4OiB4MiwgeTogeTIgfSA9IHRvWFkoc3F1YXJlVHdvKTtcblxuICBjb25zdCB4RGlmZiA9IHgxIC0geDI7XG4gIGNvbnN0IHlEaWZmID0geTEgLSB5MjtcbiAgcmV0dXJuIHtcbiAgICB4RGlmZixcbiAgICB5RGlmZlxuICB9O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBpZWNlRnJvbUFiYnIoYWJicjogUGllY2VBYmJyZXZpYXRpb24pIHtcbiAgc3dpdGNoIChhYmJyKSB7XG4gICAgY2FzZSAnSyc6XG4gICAgICByZXR1cm4gJ2tpbmcnO1xuXG4gICAgY2FzZSAnUSc6XG4gICAgICByZXR1cm4gJ3F1ZWVuJztcblxuICAgIGNhc2UgJ04nOlxuICAgICAgcmV0dXJuICdrbmlnaHQnO1xuXG4gICAgY2FzZSAnQic6XG4gICAgICByZXR1cm4gJ2Jpc2hvcCc7XG5cbiAgICBjYXNlICdSJzpcbiAgICAgIHJldHVybiAncm9vayc7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlTm90YXRpb24obm90YXRpb246IHN0cmluZykge1xuICBjb25zdCBtb3ZlID0gPFBhcnNlZE5vdGF0aW9uSW50ZXJmYWNlPnt9O1xuXG4gIGNvbnN0IHJlcGxhY2VkID0gbm90YXRpb24ucmVwbGFjZSgvWyt4I10vLCAnJyk7XG5cbiAgaWYgKCtyZXBsYWNlZFswXSA9PT0gMCkge1xuICAgIC8vIHRoaXMgaXMgY2FzdGxlXG4gICAgbW92ZS5jYXN0bGUgPSByZXBsYWNlZC5sZW5ndGggPT09IDMgPyAna2luZ3NpZGUnIDogJ3F1ZWVuc2lkZSc7XG4gICAgcmV0dXJuIG1vdmU7XG4gIH1cblxuICBpZiAocmVwbGFjZWRbMF0udG9VcHBlckNhc2UoKSA9PT0gcmVwbGFjZWRbMF0pIHtcbiAgICAvLyB0aGlzIGlzIHBpZWNlIG1vdmVcbiAgICBtb3ZlLnBpZWNlVHlwZSA9IGdldFBpZWNlRnJvbUFiYnIocmVwbGFjZWRbMF0gYXMgUGllY2VBYmJyZXZpYXRpb24pO1xuICAgIG1vdmUudG8gPSByZXBsYWNlZC5zbGljZSgtMik7XG5cbiAgICBzd2l0Y2ggKHJlcGxhY2VkLmxlbmd0aCkge1xuICAgICAgY2FzZSA0OlxuICAgICAgICBtb3ZlLmZyb20gPSByZXBsYWNlZFsxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDU6XG4gICAgICAgIG1vdmUuZnJvbSA9IHJlcGxhY2VkLnNsaWNlKDEsIDMpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gbW92ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpcyBhIHBhd24gbW92ZVxuICAgIG1vdmUucGllY2VUeXBlID0gJ3Bhd24nO1xuXG4gICAgaWYgKHJlcGxhY2VkLmluY2x1ZGVzKCc9JykpIHtcbiAgICAgIC8vIGluZGljYXRlcyBwcm9tb3Rpb25cbiAgICAgIG1vdmUucHJvbW90ZSA9IGdldFBpZWNlRnJvbUFiYnIocmVwbGFjZWQuc2xpY2UoLTEpIGFzIFBpZWNlQWJicmV2aWF0aW9uKTtcbiAgICB9XG5cbiAgICBjb25zdCBwcm9tb3RlTm90ZUluZGV4ID0gcmVwbGFjZWQuaW5kZXhPZignPScpO1xuICAgIGNvbnN0IG5vUHJvbW90ZU5vdGF0aW9uID0gcmVwbGFjZWQuc2xpY2UoXG4gICAgICAwLFxuICAgICAgcHJvbW90ZU5vdGVJbmRleCA9PT0gLTEgPyByZXBsYWNlZC5sZW5ndGggOiBwcm9tb3RlTm90ZUluZGV4XG4gICAgKTtcbiAgICBpZiAobm9Qcm9tb3RlTm90YXRpb24ubGVuZ3RoID09PSAzKSB7XG4gICAgICBtb3ZlLmZyb20gPSByZXBsYWNlZFswXTtcbiAgICB9XG4gICAgbW92ZS50byA9IG5vUHJvbW90ZU5vdGF0aW9uLnNsaWNlKC0yKTtcbiAgfVxuXG4gIHJldHVybiBtb3ZlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVlcENvcHkyZEFycmF5KGFycjogc3RyaW5nW11bXSk6IHN0cmluZ1tdW10ge1xuICByZXR1cm4gYXJyLm1hcCgobikgPT4gWy4uLm5dKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVQaWVjZU1hcHMocG0xOiBBbGxQaWVjZU1hcCwgcG0yOiBBbGxQaWVjZU1hcCkge1xuICBsZXQgY29sb3I6IGtleW9mIHR5cGVvZiBwbTE7XG4gIGZvciAoY29sb3IgaW4gcG0xKSB7XG4gICAgY29uc3QgbWFwID0gcG0xW2NvbG9yXTtcblxuICAgIGxldCBwaWVjZVR5cGU6IGtleW9mIHR5cGVvZiBtYXA7XG4gICAgZm9yIChwaWVjZVR5cGUgaW4gbWFwKSB7XG4gICAgICBjb25zdCBzcXVhcmVzID0gbWFwW3BpZWNlVHlwZV07XG4gICAgICBjb25zdCBzcXVhcmVzMiA9IHBtMltjb2xvcl1bcGllY2VUeXBlXTtcblxuICAgICAgaWYgKHNxdWFyZXMubGVuZ3RoICE9PSBzcXVhcmVzMi5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzcXVhcmVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChjb2xvciA9PT0gJ2JsYWNrJyAmJiBwaWVjZVR5cGUgPT09ICdwYXduJylcbiAgICAgICAgICBpZiAoc3F1YXJlc1tqXSAhPT0gc3F1YXJlczJbal0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG4iLCJpbXBvcnQgbW92ZXMgZnJvbSAnLi91dGlscy9tb3Zlcyc7XG5pbXBvcnQgeyB0b1hZLCBmcm9tWFkgfSBmcm9tICcuL3V0aWxzL2hlbHBlcnMnO1xuXG5pbXBvcnQgeyBDb2xvciwgU3F1YXJlLCBQaWVjZVR5cGUgfSBmcm9tICcuL3R5cGVzL3R5cGVzJztcblxuY29uc3QgUGllY2UgPSAoY29sb3I6IENvbG9yLCB0eXBlOiBQaWVjZVR5cGUpID0+IHtcbiAgZnVuY3Rpb24gaGFzTW92ZShmcm9tOiBTcXVhcmUsIHRvOiBTcXVhcmUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2tpbmcnOiB7XG4gICAgICAgIGNvbnN0IG9uZVNxdWFyZVZlcnQgPVxuICAgICAgICAgIG1vdmVzLnlCeU4oMSkoZnJvbSkodG8pICYmIG1vdmVzLnhCeU4oMCkoZnJvbSkodG8pO1xuICAgICAgICBjb25zdCBvbmVTcXVhcmVMYXRlcmFsID1cbiAgICAgICAgICBtb3Zlcy54QnlOKDEpKGZyb20pKHRvKSAmJiBtb3Zlcy55QnlOKDApKGZyb20pKHRvKTtcbiAgICAgICAgY29uc3Qgb25lU3F1YXJlRGlhZ29uYWxseSA9XG4gICAgICAgICAgbW92ZXMueUJ5TigxKShmcm9tKSh0bykgJiYgbW92ZXMueEJ5TigxKShmcm9tKSh0byk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBmcm9tICE9PSB0byAmJlxuICAgICAgICAgIChvbmVTcXVhcmVEaWFnb25hbGx5IHx8IG9uZVNxdWFyZVZlcnQgfHwgb25lU3F1YXJlTGF0ZXJhbClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ3F1ZWVuJzoge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGZyb20gIT09IHRvICYmXG4gICAgICAgICAgKG1vdmVzLmRpYWdvbmFsKGZyb20pKHRvKSB8fCBtb3Zlcy52ZXJ0QW5kTGF0ZXJhbChmcm9tKSh0bykpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjYXNlICdiaXNob3AnOiB7XG4gICAgICAgIHJldHVybiBmcm9tICE9PSB0byAmJiBtb3Zlcy5kaWFnb25hbChmcm9tKSh0byk7XG4gICAgICB9XG4gICAgICBjYXNlICdrbmlnaHQnOiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgZnJvbSAhPT0gdG8gJiZcbiAgICAgICAgICAoKG1vdmVzLnhCeU4oMSkoZnJvbSkodG8pICYmIG1vdmVzLnlCeU4oMikoZnJvbSkodG8pKSB8fFxuICAgICAgICAgICAgKG1vdmVzLnhCeU4oMikoZnJvbSkodG8pICYmIG1vdmVzLnlCeU4oMSkoZnJvbSkodG8pKSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ3Jvb2snOiB7XG4gICAgICAgIHJldHVybiBmcm9tICE9PSB0byAmJiBtb3Zlcy52ZXJ0QW5kTGF0ZXJhbCh0bykoZnJvbSk7XG4gICAgICB9XG4gICAgICBjYXNlICdwYXduJzoge1xuICAgICAgICBjb25zdCB7IHg6IHgxLCB5OiB5MSB9ID0gdG9YWShmcm9tKTtcbiAgICAgICAgY29uc3QgeyB4OiB4MiwgeTogeTIgfSA9IHRvWFkodG8pO1xuXG4gICAgICAgIGNvbnN0IG9ubHlNb3Zlc0luRnJvbnQgPSBjb2xvciA9PT0gJ3doaXRlJyA/IHkxIDwgeTIgOiB5MSA+IHkyO1xuICAgICAgICBjb25zdCByZWd1bGFyTW92ZSA9IG1vdmVzLnlCeU4oMSkoZnJvbSkodG8pICYmIHgxID09PSB4MjtcblxuICAgICAgICBjb25zdCBmaXJzdE1vdmUgPSBjb2xvciA9PT0gJ3doaXRlJyA/IHkxID09PSAyIDogeTEgPT09IDc7XG4gICAgICAgIGNvbnN0IGp1bXBUd28gPSBtb3Zlcy55QnlOKDIpKGZyb20pKHRvKSAmJiB4MSA9PT0geDI7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBmcm9tICE9PSB0byAmJlxuICAgICAgICAgIG9ubHlNb3Zlc0luRnJvbnQgJiZcbiAgICAgICAgICAocmVndWxhck1vdmUgfHwgKGZpcnN0TW92ZSAmJiBqdW1wVHdvKSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQYXduQ2FwdHVyZXMob3JpZ2luOiBTcXVhcmUpIHtcbiAgICBpZiAodHlwZSAhPT0gJ3Bhd24nKSByZXR1cm47XG5cbiAgICBjb25zdCB7IHgsIHkgfSA9IHRvWFkob3JpZ2luKTtcblxuICAgIGNvbnN0IG5ld1kgPSBjb2xvciA9PT0gJ3doaXRlJyA/IHkgKyAxIDogeSAtIDE7XG5cbiAgICBjb25zdCBjYXB0dXJlT25lID0geyB4OiB4ICsgMSwgeTogbmV3WSB9O1xuICAgIGNvbnN0IGNhcHR1cmVUd28gPSB7IHg6IHggLSAxLCB5OiBuZXdZIH07XG5cbiAgICByZXR1cm4gW2Zyb21YWShjYXB0dXJlT25lKSwgZnJvbVhZKGNhcHR1cmVUd28pXTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaGFzTW92ZSxcbiAgICBnZXRQYXduQ2FwdHVyZXMsXG4gICAgZ2V0IHR5cGUoKSB7XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9LFxuICAgIGdldCBjb2xvcigpIHtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG4gIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBQaWVjZTtcbiIsImltcG9ydCB7IGNhbGNEaXN0YW5jZSwgdG9YWSB9IGZyb20gJy4vaGVscGVycyc7XG5pbXBvcnQgeyBTcXVhcmVPYmosIFBpZWNlT2JqLCBFblBhc3NhbnRPYmogfSBmcm9tICcuLi90eXBlcy9pbnRlcmZhY2VzJztcbmltcG9ydCB7IE1vdmVzLCBCb2FyZCwgU3F1YXJlLCBDb2xvciwgUGllY2VUeXBlIH0gZnJvbSAnLi4vdHlwZXMvdHlwZXMnO1xuaW1wb3J0IFBpZWNlIGZyb20gJy4uL1BpZWNlJztcblxuY29uc3QgbW92ZXMgPSB7XG4gIHZlcnRBbmRMYXRlcmFsOiAoZnJvbTogU3F1YXJlKSA9PiAodG86IFNxdWFyZSkgPT4ge1xuICAgIGNvbnN0IFt4MSwgeTFdID0gZnJvbS5zcGxpdCgnJyk7XG4gICAgY29uc3QgW3gyLCB5Ml0gPSB0by5zcGxpdCgnJyk7XG4gICAgcmV0dXJuIHgxID09PSB4MiB8fCB5MSA9PT0geTI7XG4gIH0sXG4gIGRpYWdvbmFsOiAoZnJvbTogU3F1YXJlKSA9PiAodG86IFNxdWFyZSkgPT4ge1xuICAgIGNvbnN0IHsgeDogeDEsIHk6IHkxIH0gPSB0b1hZKGZyb20pO1xuICAgIGNvbnN0IHsgeDogeDIsIHk6IHkyIH0gPSB0b1hZKHRvKTtcbiAgICByZXR1cm4gTWF0aC5hYnMoeDIgLSB4MSkgPT09IE1hdGguYWJzKHkyIC0geTEpO1xuICB9LFxuICB4QnlOOiAobnVtOiBudW1iZXIpID0+IChmcm9tOiBTcXVhcmUpID0+ICh0bzogU3F1YXJlKSA9PiB7XG4gICAgY29uc3QgeyB4OiB4MSB9ID0gdG9YWShmcm9tKTtcbiAgICBjb25zdCB7IHg6IHgyIH0gPSB0b1hZKHRvKTtcbiAgICByZXR1cm4gTWF0aC5hYnMoeDEgLSB4MikgPT09IG51bTtcbiAgfSxcbiAgeUJ5TjogKG51bTogbnVtYmVyKSA9PiAoZnJvbTogU3F1YXJlKSA9PiAodG86IFNxdWFyZSkgPT4ge1xuICAgIGNvbnN0IHsgeTogeTEgfSA9IHRvWFkoZnJvbSk7XG4gICAgY29uc3QgeyB5OiB5MiB9ID0gdG9YWSh0byk7XG4gICAgcmV0dXJuIE1hdGguYWJzKHkxIC0geTIpID09PSBudW07XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IG1vdmVzO1xuXG4vKiBkZWFsaW5nIHdpdGggbW92ZSB2ZWN0b3JzICovXG5cbmZ1bmN0aW9uIHNwbGl0SW50b1ZlY3RvcnMoYXJyYXlPZk1vdmVzOiBNb3Zlcywgc3RhcnQ6IFNxdWFyZSkge1xuICBpbnRlcmZhY2UgVmVjdG9ycyB7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nW107XG4gIH1cbiAgcmV0dXJuIGFycmF5T2ZNb3Zlcy5yZWR1Y2UoKGFjYzogVmVjdG9ycywgY3VycjogU3F1YXJlKSA9PiB7XG4gICAgY29uc3QgeyB4RGlmZiwgeURpZmYgfSA9IGNhbGNEaXN0YW5jZShzdGFydCkoY3Vycik7XG5cbiAgICBsZXQgdmVjdG9yID0gJyc7XG4gICAgaWYgKHlEaWZmICE9PSAwKSB2ZWN0b3IgPSB5RGlmZiA8IDAgPyAndXAnIDogJ2Rvd24nO1xuICAgIGlmICh4RGlmZiAhPT0gMCkgdmVjdG9yICs9IHhEaWZmIDwgMCA/ICdSaWdodCcgOiAnTGVmdCc7XG5cbiAgICAvLyBub3JtYWxpemUgdmVjdG9yIG5hbWVcbiAgICB2ZWN0b3IgPSB2ZWN0b3IuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyB2ZWN0b3Iuc2xpY2UoMSk7XG5cbiAgICBhY2NbdmVjdG9yXSA9IGFjY1t2ZWN0b3JdIHx8IFtdO1xuICAgIGFjY1t2ZWN0b3JdLnB1c2goY3Vycik7XG5cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59XG5cbmZ1bmN0aW9uIGdldEJlZ2lubmluZ09mVmVjdG9yKHZlY3RvcjogTW92ZXMpIHtcbiAgaWYgKHZlY3Rvci5sZW5ndGggPT09IDApIHJldHVybiAnJztcblxuICByZXR1cm4gdmVjdG9yLnJlZHVjZSgoYWNjLCBjdXJyKSA9PiB7XG4gICAgY29uc3QgeyB4OiB4MSwgeTogeTEgfSA9IHRvWFkoYWNjKTtcbiAgICBjb25zdCB7IHg6IHgyLCB5OiB5MiB9ID0gdG9YWShjdXJyKTtcblxuICAgIGNvbnN0IGFjY0lzQmVnaW5uaW5nID0geDEgPT09IHgyID8geTEgPCB5MiA6IHgxIDwgeDI7XG4gICAgcmV0dXJuIGFjY0lzQmVnaW5uaW5nID8gYWNjIDogY3VycjtcbiAgfSk7XG59XG5cbmNvbnN0IGdldE1vdmVzQWxvbmdWZWN0b3IgPSAoXG4gIHMxOiBTcXVhcmUsXG4gIHMyOiBTcXVhcmUsXG4gIGFsbFNxdWFyZXM6IE1vdmVzXG4pOiBNb3ZlcyA9PiB7XG4gIGNvbnN0IGxpZXNTYW1lVmVydE9yTGF0ID0gbW92ZXMudmVydEFuZExhdGVyYWwoczEpKHMyKTtcbiAgY29uc3QgbGllc1NhbWVEaWFnb25hbGx5ID0gbW92ZXMuZGlhZ29uYWwoczEpKHMyKTtcblxuICBjb25zdCBsaWVzT25TYW1lTGluZSA9IGxpZXNTYW1lVmVydE9yTGF0IHx8IGxpZXNTYW1lRGlhZ29uYWxseTtcbiAgaWYgKCFsaWVzT25TYW1lTGluZSkgcmV0dXJuIFtdO1xuXG4gIGNvbnN0IG1hdGNoaW5nVmVjdG9yID0gbGllc1NhbWVEaWFnb25hbGx5ID8gJ2RpYWdvbmFsJyA6ICd2ZXJ0QW5kTGF0ZXJhbCc7XG5cbiAgY29uc3Qgc3F1YXJlc0Fsb25nVmVjdG9yID0gYWxsU3F1YXJlcy5maWx0ZXIoXG4gICAgKHMpID0+IG1vdmVzW21hdGNoaW5nVmVjdG9yXShzMSkocykgJiYgbW92ZXNbbWF0Y2hpbmdWZWN0b3JdKHMyKShzKVxuICApO1xuICByZXR1cm4gc3F1YXJlc0Fsb25nVmVjdG9yO1xufTtcblxuLyogc29ydCBtb3ZlcyAqL1xuXG5jb25zdCBzb3J0TW92ZXNDbG9zZXN0VG8gPVxuICAoc3F1YXJlOiBTcXVhcmUpID0+XG4gIChtb3ZlczogTW92ZXMpOiBNb3ZlcyA9PiB7XG4gICAgcmV0dXJuIFsuLi5tb3Zlc10uc29ydCgoYSwgYikgPT4ge1xuICAgICAgY29uc3QgeyB4RGlmZjogeDFEaWZmLCB5RGlmZjogeTFEaWZmIH0gPSBjYWxjRGlzdGFuY2Uoc3F1YXJlKShhKTtcbiAgICAgIGNvbnN0IGFEaWZmID0gTWF0aC5hYnMoeDFEaWZmKSArIE1hdGguYWJzKHkxRGlmZik7XG5cbiAgICAgIGNvbnN0IHsgeERpZmY6IHgyRGlmZiwgeURpZmY6IHkyRGlmZiB9ID0gY2FsY0Rpc3RhbmNlKHNxdWFyZSkoYik7XG4gICAgICBjb25zdCBiRGlmZiA9IE1hdGguYWJzKHgyRGlmZikgKyBNYXRoLmFicyh5MkRpZmYpO1xuXG4gICAgICByZXR1cm4gYURpZmYgLSBiRGlmZjtcbiAgICB9KTtcbiAgfTtcblxuLyogZ2V0IG1vdmVzICovXG5cbmZ1bmN0aW9uIGdldFBvc3NpYmxlTW92ZXMob3JpZ2luOiBTcXVhcmUsIGJvYXJkOiBCb2FyZCkge1xuICAvLyBnZXQgYWxsIG1vdmVzIHRoYXQgY2FuIGhhcHBlbiBpZiBubyBvdGhlciBwaWVjZXMgd2VyZSBvbiB0aGUgYm9hcmRcbiAgY29uc3QgYWxsU3F1YXJlcyA9IEFycmF5LmZyb20oYm9hcmQua2V5cygpKTtcblxuICBjb25zdCBzcXVhcmUgPSBib2FyZC5nZXQob3JpZ2luKSBhcyBTcXVhcmVPYmo7XG5cbiAgY29uc3QgeyB0eXBlLCBjb2xvciB9ID0gc3F1YXJlLnBpZWNlIGFzIFBpZWNlT2JqO1xuICBjb25zdCBwaWVjZSA9IFBpZWNlKGNvbG9yLCB0eXBlKTtcblxuICByZXR1cm4gYWxsU3F1YXJlcy5maWx0ZXIoKHMpID0+IHBpZWNlLmhhc01vdmUob3JpZ2luLCBzKSk7XG59XG5cbmZ1bmN0aW9uIGdldExlZ2FsTW92ZXMob3JpZ2luOiBTcXVhcmUsIGJvYXJkOiBCb2FyZCkge1xuICAvLyBnZXQgbW92ZXMgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIG9yIG5vdCB0aGVyZSBpcyBjaGVja1xuICBjb25zdCBzcXVhcmUgPSBib2FyZC5nZXQob3JpZ2luKSBhcyBTcXVhcmVPYmo7XG5cbiAgY29uc3QgcGllY2UgPSBzcXVhcmUucGllY2UgYXMgUGllY2VPYmo7XG5cbiAgY29uc3QgcG9zc2libGVNb3ZlcyA9IGdldFBvc3NpYmxlTW92ZXMob3JpZ2luLCBib2FyZCk7XG5cbiAgY29uc3Qgb2JzdHJ1Y3Rpb25zID0gcG9zc2libGVNb3Zlcy5maWx0ZXIoKHMpID0+IGJvYXJkLmdldChzKT8ucGllY2UpO1xuICBpZiAoIW9ic3RydWN0aW9ucy5sZW5ndGgpIHtcbiAgICBzd2l0Y2ggKHBpZWNlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3Bhd24nOlxuICAgICAgICByZXR1cm4gWy4uLmdldFBhd25DYXB0dXJlcyhvcmlnaW4sIGJvYXJkKSwgLi4ucG9zc2libGVNb3Zlc107XG5cbiAgICAgIGNhc2UgJ2tpbmcnOlxuICAgICAgICByZXR1cm4gcmVtb3ZlUHJvdGVjdGVkU3F1YXJlcyhvcmlnaW4sIHBvc3NpYmxlTW92ZXMsIGJvYXJkKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBwb3NzaWJsZU1vdmVzO1xuICAgIH1cbiAgfVxuXG4gIGxldCBsZWdhbE1vdmVzOiBNb3ZlcyA9IFtdO1xuICBzd2l0Y2ggKHBpZWNlLnR5cGUpIHtcbiAgICBjYXNlICdrbmlnaHQnOiB7XG4gICAgICBsZWdhbE1vdmVzID0gcG9zc2libGVNb3ZlcztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlICdwYXduJzoge1xuICAgICAgY29uc3QgY2FwdHVyZXNBdmFpbGFibGUgPSBnZXRQYXduQ2FwdHVyZXMob3JpZ2luLCBib2FyZCk7XG4gICAgICBjb25zdCB1bm9ic3RydWN0ZWRNb3ZlcyA9IHJlbW92ZU1vdmVzV2l0aFBpZWNlcyhcbiAgICAgICAgcmVtb3ZlT2JzdHJ1Y3RlZE1vdmVzKG9yaWdpbiwgcG9zc2libGVNb3Zlcywgb2JzdHJ1Y3Rpb25zKSxcbiAgICAgICAgYm9hcmRcbiAgICAgICk7XG4gICAgICBsZWdhbE1vdmVzID0gWy4uLmNhcHR1cmVzQXZhaWxhYmxlLCAuLi51bm9ic3RydWN0ZWRNb3Zlc107XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAna2luZyc6IHtcbiAgICAgIGxlZ2FsTW92ZXMgPSByZW1vdmVQcm90ZWN0ZWRTcXVhcmVzKG9yaWdpbiwgcG9zc2libGVNb3ZlcywgYm9hcmQpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGxlZ2FsTW92ZXMgPSByZW1vdmVPYnN0cnVjdGVkTW92ZXMob3JpZ2luLCBwb3NzaWJsZU1vdmVzLCBvYnN0cnVjdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZW1vdmVNb3Zlc1dpdGhQaWVjZXMobGVnYWxNb3ZlcywgYm9hcmQsIHBpZWNlLmNvbG9yKTtcbn1cblxuZnVuY3Rpb24gZ2V0TGVnYWxNb3Zlc0luQ2hlY2soXG4gIG9yaWdpbjogU3F1YXJlLFxuICBib2FyZDogQm9hcmQsXG4gIGtpbmdQb3M6IFNxdWFyZSxcbiAgc3F1YXJlR2l2aW5nQ2hlY2s6IFNxdWFyZVxuKSB7XG4gIGNvbnN0IHNxdWFyZXNUaGF0RGVhbFdpdGhDaGVjayA9IGdldFNxdWFyZXNCZXR3ZWVuS2luZ0FuZENoZWNrKFxuICAgIGtpbmdQb3MsXG4gICAgc3F1YXJlR2l2aW5nQ2hlY2ssXG4gICAgQXJyYXkuZnJvbShib2FyZC5rZXlzKCkpXG4gICk7XG4gIGNvbnN0IG1vdmVzID0gZ2V0TGVnYWxNb3ZlcyhvcmlnaW4sIGJvYXJkKTtcblxuICByZXR1cm4gbW92ZXMuZmlsdGVyKChzKSA9PiBzcXVhcmVzVGhhdERlYWxXaXRoQ2hlY2suaW5jbHVkZXMocykpO1xufVxuXG5mdW5jdGlvbiBnZXRBdHRhY2tpbmdNb3ZlcyhvcmlnaW46IFNxdWFyZSwgYm9hcmQ6IEJvYXJkKTogTW92ZXMge1xuICBjb25zdCBzcXVhcmUgPSBib2FyZC5nZXQob3JpZ2luKSBhcyBTcXVhcmVPYmo7XG5cbiAgY29uc3QgeyB0eXBlLCBjb2xvciB9ID0gc3F1YXJlLnBpZWNlIGFzIFBpZWNlT2JqO1xuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3Bhd24nOiB7XG4gICAgICBjb25zdCBwaWVjZSA9IFBpZWNlKGNvbG9yLCAncGF3bicpO1xuICAgICAgcmV0dXJuIHBpZWNlLmdldFBhd25DYXB0dXJlcyhvcmlnaW4pIGFzIE1vdmVzO1xuICAgIH1cbiAgICBjYXNlICdraW5nJzoge1xuICAgICAgLy8gbmVlZCB0byBkbyB0aGlzIGJlY2F1c2UgZ2V0TGVnYWxNb3ZlcyB3aWxsIHJlY3Vyc2l2ZWx5IGNhbGwgcmVtb3ZlUHJvdGVjdGVkU3F1YXJlcyBvdGhlcndpc2VcbiAgICAgIGNvbnN0IGF0dGFja2luZ01vdmVzID0gcmVtb3ZlTW92ZXNXaXRoUGllY2VzKFxuICAgICAgICBnZXRQb3NzaWJsZU1vdmVzKG9yaWdpbiwgYm9hcmQpLFxuICAgICAgICBib2FyZCxcbiAgICAgICAgY29sb3JcbiAgICAgICk7XG4gICAgICByZXR1cm4gYXR0YWNraW5nTW92ZXM7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZ2V0TGVnYWxNb3ZlcyhvcmlnaW4sIGJvYXJkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRBbGxNb3Zlc0ZvckNvbG9yKFxuICBjb2xvcjogQ29sb3IsXG4gIGJvYXJkOiBCb2FyZCxcbiAgc2tpcEtpbmc/OiBib29sZWFuXG4pOiBNb3ZlcyB7XG4gIGNvbnN0IGFsbE1vdmVzOiBNb3Zlc1tdID0gW107XG4gIGZvciAoY29uc3QgW3NxdWFyZSwgeyBwaWVjZSB9XSBvZiBib2FyZC5lbnRyaWVzKCkpIHtcbiAgICBpZiAoIXBpZWNlKSBjb250aW51ZTtcbiAgICBpZiAocGllY2UuY29sb3IgIT09IGNvbG9yKSBjb250aW51ZTtcbiAgICBpZiAoc2tpcEtpbmcgJiYgcGllY2UudHlwZSA9PT0gJ2tpbmcnKSBjb250aW51ZTtcblxuICAgIGFsbE1vdmVzLnB1c2goZ2V0TGVnYWxNb3ZlcyhzcXVhcmUsIGJvYXJkKSk7XG4gIH1cblxuICByZXR1cm4gYWxsTW92ZXMuZmxhdCgpO1xufVxuXG5mdW5jdGlvbiBnZXRBdHRhY2tpbmdNb3Zlc0ZvckNvbG9yKGNvbG9yOiBDb2xvciwgYm9hcmQ6IEJvYXJkKTogTW92ZXMge1xuICBjb25zdCBhbGxNb3ZlczogTW92ZXNbXSA9IFtdO1xuICBmb3IgKGNvbnN0IFtzcXVhcmUsIHsgcGllY2UgfV0gb2YgYm9hcmQuZW50cmllcygpKSB7XG4gICAgaWYgKCFwaWVjZSkgY29udGludWU7XG4gICAgaWYgKHBpZWNlLmNvbG9yICE9PSBjb2xvcikgY29udGludWU7XG5cbiAgICBhbGxNb3Zlcy5wdXNoKGdldEF0dGFja2luZ01vdmVzKHNxdWFyZSwgYm9hcmQpKTtcbiAgfVxuXG4gIHJldHVybiBhbGxNb3Zlcy5mbGF0KCk7XG59XG5cbmZ1bmN0aW9uIGdldFBhd25DYXB0dXJlcyhwYXduU3F1YXJlOiBTcXVhcmUsIGJvYXJkOiBCb2FyZCkge1xuICBjb25zdCB7IGNvbG9yIH0gPSBib2FyZC5nZXQocGF3blNxdWFyZSk/LnBpZWNlIGFzIFBpZWNlT2JqO1xuICBjb25zdCBwYXduID0gUGllY2UoY29sb3IsICdwYXduJyk7XG5cbiAgY29uc3QgY2FwdHVyZU1vdmVzID0gcGF3bi5nZXRQYXduQ2FwdHVyZXMocGF3blNxdWFyZSk7XG4gIGlmICghY2FwdHVyZU1vdmVzKSByZXR1cm4gW107XG5cbiAgcmV0dXJuIGNhcHR1cmVNb3Zlcy5maWx0ZXIoKHMpID0+IHtcbiAgICBjb25zdCBzcXVhcmVWYWwgPSBib2FyZC5nZXQocyk7XG4gICAgaWYgKCFzcXVhcmVWYWwpIHJldHVybiBmYWxzZTtcblxuICAgIGNvbnN0IHBpZWNlID0gc3F1YXJlVmFsLnBpZWNlO1xuICAgIGNvbnN0IGVuUGFzc2FudDogRW5QYXNzYW50T2JqIHwgdW5kZWZpbmVkID0gc3F1YXJlVmFsLmVuUGFzc2FudDtcblxuICAgIHJldHVybiAoXG4gICAgICAocGllY2UgJiYgcGllY2UuY29sb3IgIT09IHBhd24uY29sb3IpIHx8XG4gICAgICAoZW5QYXNzYW50ICYmIGVuUGFzc2FudC5jb2xvciAhPT0gcGF3bi5jb2xvcilcbiAgICApO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0U3F1YXJlc0JldHdlZW5LaW5nQW5kQ2hlY2soXG4gIGtpbmdQb3M6IFNxdWFyZSxcbiAgY2hlY2tQb3M6IFNxdWFyZSxcbiAgYWxsU3F1YXJlczogTW92ZXNcbikge1xuICAvLyBpbmNsdWRlcyBraW5nUG9zIGFuZCBjaGVja1Bvc1xuICBjb25zdCBzcXVhcmVzQWxvbmdWZWN0b3IgPSBnZXRNb3Zlc0Fsb25nVmVjdG9yKGtpbmdQb3MsIGNoZWNrUG9zLCBhbGxTcXVhcmVzKTtcbiAgY29uc3Qgc3F1YXJlc0JldHdlZW5LaW5nQW5kUGllY2UgPSByZW1vdmVNb3Zlc0JlaGluZFR3b1NxdWFyZXMoXG4gICAga2luZ1BvcyxcbiAgICBjaGVja1BvcyxcbiAgICBzcXVhcmVzQWxvbmdWZWN0b3JcbiAgKTtcbiAgcmV0dXJuIHNxdWFyZXNCZXR3ZWVuS2luZ0FuZFBpZWNlO1xufVxuXG4vKiBmaWx0ZXIgbW92ZXMgKi9cblxuZnVuY3Rpb24gcmVtb3ZlTW92ZXNCZWhpbmRUd29TcXVhcmVzKFxuICBzMTogU3F1YXJlLFxuICBzMjogU3F1YXJlLFxuICB2ZWN0b3I6IE1vdmVzXG4pOiBNb3ZlcyB7XG4gIGNvbnN0IHNvcnRlZCA9IHNvcnRNb3Zlc0Nsb3Nlc3RUbyhnZXRCZWdpbm5pbmdPZlZlY3Rvcih2ZWN0b3IpKSh2ZWN0b3IpO1xuICBsZXQgZnVydGhlc3RTcXVhcmU7XG4gIGxldCBjbG9zZXN0U3F1YXJlO1xuXG4gIGlmIChzb3J0ZWQuaW5kZXhPZihzMSkgPiBzb3J0ZWQuaW5kZXhPZihzMikpIHtcbiAgICBmdXJ0aGVzdFNxdWFyZSA9IHMxO1xuICAgIGNsb3Nlc3RTcXVhcmUgPSBzMjtcbiAgfSBlbHNlIHtcbiAgICBmdXJ0aGVzdFNxdWFyZSA9IHMyO1xuICAgIGNsb3Nlc3RTcXVhcmUgPSBzMTtcbiAgfVxuICBjb25zdCByZW1vdmVkT25lRW5kID0gcmVtb3ZlTW92ZXNCZWhpbmRTcXVhcmUoZnVydGhlc3RTcXVhcmUpKHNvcnRlZCk7XG4gIGNvbnN0IHJlbW92ZWRCb3RoRW5kcyA9IHJlbW92ZU1vdmVzQmVoaW5kU3F1YXJlKGNsb3Nlc3RTcXVhcmUpKFxuICAgIHJlbW92ZWRPbmVFbmQucmV2ZXJzZSgpXG4gICk7XG5cbiAgcmV0dXJuIHJlbW92ZWRCb3RoRW5kcztcbn1cblxuY29uc3QgcmVtb3ZlTW92ZXNCZWhpbmRTcXVhcmUgPVxuICAoc3F1YXJlOiBTcXVhcmUpID0+XG4gIChtb3ZlczogTW92ZXMpOiBNb3ZlcyA9PiB7XG4gICAgY29uc3QgY29weSA9IFsuLi5tb3Zlc107XG4gICAgY29uc3QgaW5kZXggPSBtb3Zlcy5pbmRleE9mKHNxdWFyZSk7XG5cbiAgICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gW107XG5cbiAgICBjb3B5LnNwbGljZShpbmRleCArIDEpO1xuXG4gICAgcmV0dXJuIGNvcHk7XG4gIH07XG5cbmZ1bmN0aW9uIHJlbW92ZU9ic3RydWN0ZWRNb3ZlcyhcbiAgc3RhcnRpbmdTcXVhcmU6IFNxdWFyZSxcbiAgcG9zc2libGVNb3ZlczogTW92ZXMsXG4gIG9ic3RydWN0aW9uczogTW92ZXNcbik6IE1vdmVzIHtcbiAgLy8gYSkgc3BsaXQgcG9zc2libGUgbW92ZXMgaW50byB2ZWN0b3JzICh1cCxkb3duLGxlZnQscmlnaHQsIGFuZC9vciBkaWFnb25hbHMpXG4gIC8vIGIpIHNlZSB3aGljaCBvYnN0cnVjdGlvbnMgYmVsb25nIHRvIHdoaWNoIHZlY3RvclxuICAvLyBjKSBmaW5kIHRoZSBjbG9zZXN0IG9ic3RydWN0aW9uXG4gIC8vIGQpIHJlbW92ZSBhbGwgdGhlIG1vdmVzIGJlaGluZCB0aGF0IG9ic3RydWN0aW9uXG5cbiAgY29uc3QgZmlsdGVyZWRNb3ZlczogTW92ZXNbXSA9IFtdO1xuXG4gIGNvbnN0IGFsbFZlY3RvcnMgPSBzcGxpdEludG9WZWN0b3JzKHBvc3NpYmxlTW92ZXMsIHN0YXJ0aW5nU3F1YXJlKTtcbiAgY29uc3Qgb2JzdHJ1Y3Rpb25WZWN0b3JzID0gc3BsaXRJbnRvVmVjdG9ycyhvYnN0cnVjdGlvbnMsIHN0YXJ0aW5nU3F1YXJlKTtcbiAgZm9yIChjb25zdCB2ZWN0b3IgaW4gYWxsVmVjdG9ycykge1xuICAgIGlmICghb2JzdHJ1Y3Rpb25WZWN0b3JzW3ZlY3Rvcl0pIHtcbiAgICAgIC8vIGxvb2sgZm9yIHZlY3RvciBvYnN0cnVjdGlvbiBpcyBvblxuICAgICAgZmlsdGVyZWRNb3Zlcy5wdXNoKGFsbFZlY3RvcnNbdmVjdG9yXSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBzb3J0ZWQgPSBzb3J0TW92ZXNDbG9zZXN0VG8oc3RhcnRpbmdTcXVhcmUpKGFsbFZlY3RvcnNbdmVjdG9yXSk7XG4gICAgY29uc3QgY2xvc2VzdE9ic3RydWN0aW9uID0gc29ydE1vdmVzQ2xvc2VzdFRvKHN0YXJ0aW5nU3F1YXJlKShcbiAgICAgIG9ic3RydWN0aW9uVmVjdG9yc1t2ZWN0b3JdXG4gICAgKVswXTtcblxuICAgIGZpbHRlcmVkTW92ZXMucHVzaChyZW1vdmVNb3Zlc0JlaGluZFNxdWFyZShjbG9zZXN0T2JzdHJ1Y3Rpb24pKHNvcnRlZCkpO1xuICB9XG5cbiAgcmV0dXJuIGZpbHRlcmVkTW92ZXMuZmxhdCgpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVQcm90ZWN0ZWRTcXVhcmVzKFxuICBraW5nUG9zOiBTcXVhcmUsXG4gIHBvc3NpYmxlTW92ZXM6IE1vdmVzLFxuICBib2FyZDogQm9hcmRcbik6IE1vdmVzIHtcbiAgY29uc3Qga2luZyA9IGJvYXJkLmdldChraW5nUG9zKT8ucGllY2UgYXMgUGllY2VPYmo7XG4gIGNvbnN0IG9wcENvbG9yID0ga2luZy5jb2xvciA9PT0gJ3doaXRlJyA/ICdibGFjaycgOiAnd2hpdGUnO1xuXG4gIGNvbnN0IGVuZW15UGllY2VzSW5WaWNpbml0eTogU3F1YXJlW10gPSBwb3NzaWJsZU1vdmVzLmZpbHRlcihcbiAgICAocykgPT4gYm9hcmQuZ2V0KHMpPy5waWVjZT8uY29sb3IgPT09IG9wcENvbG9yXG4gICk7XG4gIGNvbnN0IHNxdWFyZXNQcm90ZWN0ZWRCeUVuZW15SW5WaWNpbml0eTogU3F1YXJlW10gPSBlbmVteVBpZWNlc0luVmljaW5pdHlcbiAgICAubWFwKChzKSA9PiBnZXRBdHRhY2tpbmdNb3ZlcyhzLCBib2FyZCkpXG4gICAgLmZsYXQoKTtcbiAgLy8gYmMga2luZyBjYW50IG1vdmUgaWYgc3F1YXJlIGlzIHByb3RlY3RlZFxuICAvLyBzZXQga2luZyBwaWVjZSBvbiBlYWNoIHNxdWFyZSBpbiBwb3NzaWJsZSBtb3ZlcyB0byBmaW5kIHdoaWNoIHNxdWFyZXMgYXJlIHByb3RlY3RlZFxuICBjb25zdCBib2FyZENvcHkgPSBuZXcgTWFwKGJvYXJkKTtcbiAgcG9zc2libGVNb3Zlcy5mb3JFYWNoKChzKSA9PiBib2FyZENvcHkuc2V0KHMsIHsgcGllY2U6IGtpbmcgfSkpO1xuXG4gIGNvbnN0IHNxdWFyZXNQcm90ZWN0ZWRCeVJhbmdlID0gZ2V0QXR0YWNraW5nTW92ZXNGb3JDb2xvcihcbiAgICBvcHBDb2xvcixcbiAgICBib2FyZENvcHlcbiAgKTtcbiAgcmV0dXJuIHBvc3NpYmxlTW92ZXMuZmlsdGVyKChzKSA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgICFzcXVhcmVzUHJvdGVjdGVkQnlSYW5nZS5pbmNsdWRlcyhzKSAmJlxuICAgICAgIXNxdWFyZXNQcm90ZWN0ZWRCeUVuZW15SW5WaWNpbml0eS5pbmNsdWRlcyhzKVxuICAgICk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZW1vdmVNb3Zlc1dpdGhQaWVjZXMoXG4gIG1vdmVzOiBNb3ZlcyxcbiAgYm9hcmQ6IEJvYXJkLFxuICBjb2xvcj86IENvbG9yXG4pOiBNb3ZlcyB7XG4gIHJldHVybiBtb3Zlcy5maWx0ZXIoKHMpID0+IHtcbiAgICBjb25zdCBzcXVhcmVWYWwgPSBib2FyZC5nZXQocyk7XG4gICAgaWYgKCFzcXVhcmVWYWwpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChjb2xvcikgcmV0dXJuICFzcXVhcmVWYWwucGllY2UgfHwgc3F1YXJlVmFsLnBpZWNlLmNvbG9yICE9PSBjb2xvcjtcbiAgICBlbHNlIHJldHVybiAhc3F1YXJlVmFsLnBpZWNlO1xuICB9KTtcbn1cblxuLyogZ2FtZWJvYXJkIGNoZWNrcyAqL1xuXG5mdW5jdGlvbiBnZXREaXNjb3ZlcmVkQ2hlY2soXG4gIGtpbmdQb3M6IFNxdWFyZSxcbiAga2luZ0NvbG9yOiBDb2xvcixcbiAgdmFjYXRlZDogU3F1YXJlLFxuICBib2FyZDogQm9hcmRcbik6IFNxdWFyZSB7XG4gIC8vIG9wZW5TcXVhcmUgaXMgYSBzcXVhcmUganVzdCB2YWNhdGVkXG4gIGxldCBzcXVhcmVzQWxvbmdWZWN0b3IgPSBnZXRNb3Zlc0Fsb25nVmVjdG9yKFxuICAgIGtpbmdQb3MsXG4gICAgdmFjYXRlZCxcbiAgICBBcnJheS5mcm9tKGJvYXJkLmtleXMoKSlcbiAgKTtcbiAgc3F1YXJlc0Fsb25nVmVjdG9yID0gc3F1YXJlc0Fsb25nVmVjdG9yLmZpbHRlcihcbiAgICAocykgPT4gcyAhPT0ga2luZ1BvcyAmJiBzICE9PSB2YWNhdGVkXG4gICk7XG4gIGlmICghc3F1YXJlc0Fsb25nVmVjdG9yLmxlbmd0aCkgcmV0dXJuICcnO1xuXG4gIGZvciAoY29uc3Qgc3F1YXJlIG9mIHNxdWFyZXNBbG9uZ1ZlY3Rvcikge1xuICAgIGNvbnN0IHBpZWNlID0gYm9hcmQuZ2V0KHNxdWFyZSk/LnBpZWNlO1xuICAgIGlmICghcGllY2UgfHwgcGllY2UuY29sb3IgPT09IGtpbmdDb2xvcikgY29udGludWU7XG5cbiAgICBjb25zdCBsZWdhbE1vdmVzID0gZ2V0TGVnYWxNb3ZlcyhzcXVhcmUsIGJvYXJkKTtcbiAgICBpZiAobGVnYWxNb3Zlcy5pbmNsdWRlcyhraW5nUG9zKSkgcmV0dXJuIHNxdWFyZTtcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gY2FuQmxvY2tPckNhcHR1cmVDaGVjayhcbiAga2luZ1BvczogU3F1YXJlLFxuICBzcXVhcmVHaXZpbmdDaGVjazogU3F1YXJlLFxuICBib2FyZDogQm9hcmRcbik6IGJvb2xlYW4ge1xuICBjb25zdCBraW5nID0gYm9hcmQuZ2V0KGtpbmdQb3MpPy5waWVjZSBhcyBQaWVjZU9iajtcblxuICBjb25zdCBibG9ja09yQ2FwdHVyZVNxdWFyZXMgPSBnZXRTcXVhcmVzQmV0d2VlbktpbmdBbmRDaGVjayhcbiAgICBraW5nUG9zLFxuICAgIHNxdWFyZUdpdmluZ0NoZWNrLFxuICAgIEFycmF5LmZyb20oYm9hcmQua2V5cygpKVxuICApOyAvLyBhbHNvIGluY2x1ZGVzIGNoZWNrIHNxdWFyZVxuXG4gIGNvbnN0IG93blBpZWNlTW92ZXMgPSBnZXRBbGxNb3Zlc0ZvckNvbG9yKGtpbmcuY29sb3IsIGJvYXJkLCB0cnVlKTtcbiAgcmV0dXJuIG93blBpZWNlTW92ZXMuc29tZSgobW92ZSkgPT4gYmxvY2tPckNhcHR1cmVTcXVhcmVzLmluY2x1ZGVzKG1vdmUpKTtcbn1cblxuZnVuY3Rpb24gZ2V0UGllY2VzV2l0aE1vdmUoXG4gIGJvYXJkOiBCb2FyZCxcbiAgbW92ZTogU3F1YXJlLFxuICBwaWVjZVR5cGU6IFBpZWNlVHlwZSxcbiAgY29sb3I6ICdibGFjaycgfCAnd2hpdGUnXG4pIHtcbiAgY29uc3QgcGllY2VTcXVhcmVzOiBNb3ZlcyA9IFtdO1xuICBmb3IgKGNvbnN0IFtzcXVhcmUsIHsgcGllY2UgfV0gb2YgYm9hcmQuZW50cmllcygpKSB7XG4gICAgaWYgKCFwaWVjZSkgY29udGludWU7XG4gICAgaWYgKHBpZWNlLmNvbG9yICE9PSBjb2xvcikgY29udGludWU7XG4gICAgaWYgKHBpZWNlLnR5cGUgIT09IHBpZWNlVHlwZSkgY29udGludWU7XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgZ2V0QXR0YWNraW5nTW92ZXNGb3JDb2xvcixcbiAgZ2V0TGVnYWxNb3ZlcyxcbiAgZ2V0TGVnYWxNb3Zlc0luQ2hlY2ssXG4gIGdldERpc2NvdmVyZWRDaGVjayxcbiAgY2FuQmxvY2tPckNhcHR1cmVDaGVja1xufTtcbiIsImNvbnN0IGZpbGVzID0gWydhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJywgJ2gnXTtcbmNvbnN0IHJhbmtzID0gWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDhdO1xuXG5leHBvcnQgeyBmaWxlcywgcmFua3MgfTtcbiIsImltcG9ydCB7IENhc3RsZU9iaiB9IGZyb20gJy4vdHlwZXMvaW50ZXJmYWNlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENhc3RsZShcbiAgd2hpdGVLaW5nc2lkZTogYm9vbGVhbixcbiAgd2hpdGVRdWVlbnNpZGU6IGJvb2xlYW4sXG4gIGJsYWNrS2luZ3NpZGU6IGJvb2xlYW4sXG4gIGJsYWNrUXVlZW5zaWRlOiBib29sZWFuXG4pOiBDYXN0bGVPYmoge1xuICByZXR1cm4ge1xuICAgIHdoaXRlOiB7XG4gICAgICBraW5nc2lkZTogd2hpdGVLaW5nc2lkZSxcbiAgICAgIHF1ZWVuc2lkZTogd2hpdGVRdWVlbnNpZGVcbiAgICB9LFxuICAgIGJsYWNrOiB7XG4gICAgICBraW5nc2lkZTogYmxhY2tLaW5nc2lkZSxcbiAgICAgIHF1ZWVuc2lkZTogYmxhY2tRdWVlbnNpZGVcbiAgICB9XG4gIH07XG59XG4iLCJpbXBvcnQgeyBNb3ZlRGV0YWlsc0ludGVyZmFjZSB9IGZyb20gJy4vdHlwZXMvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBQaWVjZVR5cGUgfSBmcm9tICcuL3R5cGVzL3R5cGVzJztcblxuY29uc3QgbW92ZU5vdGF0aW9uID0gKG5vdGF0aW9uOiBzdHJpbmcpID0+IHtcbiAgZnVuY3Rpb24gY2FzdGxlKHNpZGU6ICdraW5nc2lkZScgfCAncXVlZW5zaWRlJykge1xuICAgIG5vdGF0aW9uID0gc2lkZSA9PT0gJ2tpbmdzaWRlJyA/ICcwLTAnIDogJzAtMC0wJztcbiAgICByZXR1cm4gbm90YXRpb247XG4gIH1cblxuICBjb25zdCBhZmZpeCA9IHtcbiAgICBwaWVjZU5vdGF0aW9uOiAocGllY2VUeXBlOiBQaWVjZVR5cGUsIGRpZmZlcmVudGlhdGlvbj86IHN0cmluZykgPT4ge1xuICAgICAgZGlmZmVyZW50aWF0aW9uID0gZGlmZmVyZW50aWF0aW9uIHx8ICcnO1xuXG4gICAgICBzd2l0Y2ggKHBpZWNlVHlwZSkge1xuICAgICAgICBjYXNlICdwYXduJzoge1xuICAgICAgICAgIG5vdGF0aW9uID0gZGlmZmVyZW50aWF0aW9uICsgbm90YXRpb247XG4gICAgICAgICAgcmV0dXJuIG5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2tpbmcnOiB7XG4gICAgICAgICAgbm90YXRpb24gPSAnSycgKyBub3RhdGlvbjtcbiAgICAgICAgICByZXR1cm4gbm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAna25pZ2h0Jzoge1xuICAgICAgICAgIG5vdGF0aW9uID0gJ04nICsgZGlmZmVyZW50aWF0aW9uICsgbm90YXRpb247XG4gICAgICAgICAgcmV0dXJuIG5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBub3RhdGlvbiA9IHBpZWNlVHlwZVswXS50b1VwcGVyQ2FzZSgpICsgZGlmZmVyZW50aWF0aW9uICsgbm90YXRpb247XG4gICAgICAgICAgcmV0dXJuIG5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjYXB0dXJlOiAoKSA9PiB7XG4gICAgICBub3RhdGlvbiA9IGB4JHtub3RhdGlvbn1gO1xuICAgICAgcmV0dXJuIG5vdGF0aW9uO1xuICAgIH0sXG4gICAgcHJvbW90ZTogKHBpZWNlVHlwZTogUGllY2VUeXBlKSA9PiB7XG4gICAgICBjb25zdCBzdWZmaXggPVxuICAgICAgICAnPScgKyBwaWVjZVR5cGUgPT09ICdrbmlnaHQnID8gJ04nIDogcGllY2VUeXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgbm90YXRpb24gKz0gJz0nICsgc3VmZml4O1xuICAgICAgcmV0dXJuIG5vdGF0aW9uO1xuICAgIH0sXG4gICAgY2hlY2s6ICgpID0+IHtcbiAgICAgIG5vdGF0aW9uICs9ICcrJztcbiAgICAgIHJldHVybiBub3RhdGlvbjtcbiAgICB9LFxuICAgIGNoZWNrbWF0ZTogKCkgPT4ge1xuICAgICAgbm90YXRpb24gKz0gJyMnO1xuICAgICAgcmV0dXJuIG5vdGF0aW9uO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBnZXQobW92ZURldGFpbHM6IE1vdmVEZXRhaWxzSW50ZXJmYWNlKSB7XG4gICAgY29uc3Qge1xuICAgICAgY2FwdHVyZSxcbiAgICAgIGNhc3RsZTogY2FzdGxlU2lkZSxcbiAgICAgIHByb21vdGUsXG4gICAgICBjaGVjayxcbiAgICAgIGNoZWNrbWF0ZSxcbiAgICAgIHBpZWNlVHlwZSxcbiAgICAgIGRpZmZlcmVudGlhdGlvblxuICAgIH0gPSBtb3ZlRGV0YWlscztcblxuICAgIGlmIChjYXN0bGVTaWRlKSByZXR1cm4gY2FzdGxlKGNhc3RsZVNpZGUpO1xuXG4gICAgaWYgKGNhcHR1cmUpIGFmZml4LmNhcHR1cmUoKTtcbiAgICBhZmZpeC5waWVjZU5vdGF0aW9uKHBpZWNlVHlwZSBhcyBQaWVjZVR5cGUsIGRpZmZlcmVudGlhdGlvbik7XG4gICAgaWYgKHByb21vdGUpIGFmZml4LnByb21vdGUocHJvbW90ZSk7XG5cbiAgICBpZiAoY2hlY2ttYXRlKSBhZmZpeC5jaGVja21hdGUoKTtcbiAgICBlbHNlIGlmIChjaGVjaykgYWZmaXguY2hlY2soKTtcblxuICAgIHJldHVybiBub3RhdGlvbjtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldFxuICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgbW92ZU5vdGF0aW9uO1xuIiwiaW1wb3J0IHtcbiAgZ2V0TGVnYWxNb3ZlcyxcbiAgZ2V0RGlzY292ZXJlZENoZWNrLFxuICBjYW5CbG9ja09yQ2FwdHVyZUNoZWNrLFxuICBnZXRBdHRhY2tpbmdNb3Zlc0ZvckNvbG9yLFxuICBnZXRMZWdhbE1vdmVzSW5DaGVja1xufSBmcm9tICcuL3V0aWxzL21vdmVzJztcbmltcG9ydCB7IHRvWFksIGZyb21YWSwgcGFyc2VOb3RhdGlvbiwgY29tcGFyZVBpZWNlTWFwcyB9IGZyb20gJy4vdXRpbHMvaGVscGVycyc7XG5pbXBvcnQgeyByYW5rcywgZmlsZXMgfSBmcm9tICcuL3JhbmtzQW5kRmlsZXMnO1xuaW1wb3J0IHtcbiAgQ29sb3IsXG4gIFNxdWFyZSxcbiAgQm9hcmQsXG4gIFBpZWNlVHlwZSxcbiAgTW92ZXMsXG4gIENhc3RsZVNxdWFyZXNUeXBlLFxuICBIaXN0b3J5VHlwZVxufSBmcm9tICcuL3R5cGVzL3R5cGVzJztcbmltcG9ydCB7XG4gIEFsbFBpZWNlTWFwLFxuICBDYXN0bGVPYmosXG4gIEVuUGFzc2FudE9iaixcbiAgR2FtZWJvYXJkT2JqLFxuICBNb3ZlRGV0YWlsc0ludGVyZmFjZSxcbiAgUGllY2VNYXAsXG4gIFBpZWNlT2JqXG59IGZyb20gJy4vdHlwZXMvaW50ZXJmYWNlcyc7XG5pbXBvcnQgQ2FzdGxlIGZyb20gJy4vQ2FzdGxlJztcbmltcG9ydCB7IHN0YXJ0aW5nUG9zaXRpb25zIH0gZnJvbSAnLi9tYWluJztcbmltcG9ydCBtb3ZlTm90YXRpb24gZnJvbSAnLi9tb3ZlTm90YXRpb24nO1xuaW1wb3J0IFBpZWNlIGZyb20gJy4vUGllY2UnO1xuXG5mdW5jdGlvbiBjcmVhdGVCb2FyZCgpOiBCb2FyZCB7XG4gIHJldHVybiBmaWxlcy5yZWR1Y2UoKGFjYywgZmlsZSkgPT4ge1xuICAgIHJhbmtzLmZvckVhY2goKHJhbmspID0+IHtcbiAgICAgIGNvbnN0IHNxdWFyZSA9IGZpbGUuY29uY2F0KHJhbmsudG9TdHJpbmcoKSk7XG4gICAgICBhY2Muc2V0KHNxdWFyZSwgeyBwaWVjZTogbnVsbCB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCBuZXcgTWFwKCkpO1xufVxuXG5jb25zdCBHYW1lYm9hcmQgPSAoXG4gIGJvYXJkID0gY3JlYXRlQm9hcmQoKSxcbiAgc3F1YXJlc0dpdmluZ0NoZWNrPzogTW92ZXMsXG4gIENhc3RsZVJpZ2h0cz86IENhc3RsZU9ialxuKTogR2FtZWJvYXJkT2JqID0+IHtcbiAgYm9hcmQgPSBuZXcgTWFwKGJvYXJkKTtcblxuICBmdW5jdGlvbiBwbGFjZVBpZWNlcyhwaWVjZU1hcDogQWxsUGllY2VNYXAsIGJvYXJkTWFwID0gYm9hcmQpIHtcbiAgICBsZXQgY29sb3I6IGtleW9mIHR5cGVvZiBwaWVjZU1hcDtcbiAgICBmb3IgKGNvbG9yIGluIHBpZWNlTWFwKSB7XG4gICAgICBjb25zdCBtYXAgPSBwaWVjZU1hcFtjb2xvcl07XG5cbiAgICAgIGxldCBwaWVjZVR5cGU6IGtleW9mIHR5cGVvZiBtYXA7XG4gICAgICBmb3IgKHBpZWNlVHlwZSBpbiBtYXApIHtcbiAgICAgICAgY29uc3Qgc3F1YXJlcyA9IG1hcFtwaWVjZVR5cGVdO1xuICAgICAgICBzcXVhcmVzLmZvckVhY2goKHMpID0+XG4gICAgICAgICAgYXQocywgYm9hcmRNYXApLnBsYWNlKHsgdHlwZTogcGllY2VUeXBlLCBjb2xvcjogY29sb3IgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlTW92ZShcbiAgICBzMTogU3F1YXJlLFxuICAgIHMyOiBTcXVhcmUsXG4gICAgcHJvbW90ZT86IFBpZWNlVHlwZVxuICApOiBCb2FyZCB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgcGllY2UgPSBhdChzMSkucGllY2U7XG5cbiAgICAvLyB2YWxpZGF0ZSBtb3ZlXG4gICAgaWYgKCFwaWVjZSkgcmV0dXJuO1xuICAgIGlmICghdmFsaWRhdGUubW92ZShzMSwgczIpKSByZXR1cm47XG4gICAgaWYgKHByb21vdGUgJiYgIXZhbGlkYXRlLnByb21vdGlvbihzMSwgczIpKSByZXR1cm47XG5cbiAgICBzd2l0Y2ggKHBpZWNlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3Bhd24nOiB7XG4gICAgICAgIGlmIChwcm9tb3RlKSB7XG4gICAgICAgICAgYXQoczEpLnByb21vdGUocHJvbW90ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5QYXNzYW50LmlzQ2FwdHVyZShzMSwgczIpKSB7XG4gICAgICAgICAgZW5QYXNzYW50LmNhcHR1cmUoczIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZW5QYXNzYW50LnJlbW92ZSgpO1xuICAgICAgICBpZiAoZW5QYXNzYW50LmNoZWNrVG9nZ2xlKHMxLCBzMikpIHtcbiAgICAgICAgICBlblBhc3NhbnQudG9nZ2xlKHBpZWNlLmNvbG9yLCBzMik7XG4gICAgICAgIH1cblxuICAgICAgICBmcm9tKHMxKS50byhzMik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjYXNlICdraW5nJzoge1xuICAgICAgICAvLyBjaGVjayBpZiBtb3ZlIGlzIGNhc3RsZVxuICAgICAgICBjb25zdCBjYXN0bGVTaWRlID0gZ2V0LmNhc3RsZVNpZGUocGllY2UuY29sb3IsIHMyKTtcbiAgICAgICAgaWYgKGNhc3RsZVNpZGUpIGNhc3RsZShwaWVjZS5jb2xvciwgY2FzdGxlU2lkZSk7XG4gICAgICAgIGVsc2UgZnJvbShzMSkudG8oczIpO1xuXG4gICAgICAgIGVuUGFzc2FudC5yZW1vdmUoKTtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZnJvbShzMSkudG8oczIpO1xuICAgICAgICBlblBhc3NhbnQucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJvYXJkO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FzdGxlKFxuICAgIGNvbG9yOiBDb2xvcixcbiAgICBzaWRlOiAna2luZ3NpZGUnIHwgJ3F1ZWVuc2lkZScsXG4gICAgYm9hcmRNYXAgPSBib2FyZFxuICApOiB2b2lkIHtcbiAgICBjb25zdCBjYXN0bGVTcXVhcmVzID0gZ2V0LmNhc3RsZVNxdWFyZXMoY29sb3IpW3NpZGVdO1xuXG4gICAgY29uc3Qga2luZ1BvcyA9IGdldC5raW5nUG9zaXRpb24oY29sb3IsIGJvYXJkTWFwKSBhcyBTcXVhcmU7XG4gICAgY29uc3Qgcm9va1BvcyA9IGdldFJvb2tQb3MoKSBhcyBTcXVhcmU7XG5cbiAgICBmcm9tKHJvb2tQb3MsIGJvYXJkTWFwKS50byhjYXN0bGVTcXVhcmVzWzBdKTtcbiAgICBmcm9tKGtpbmdQb3MsIGJvYXJkTWFwKS50byhjYXN0bGVTcXVhcmVzWzFdKTtcblxuICAgIGZ1bmN0aW9uIGdldFJvb2tQb3MoKSB7XG4gICAgICBjb25zdCBwaWVjZU1hcCA9IGdldC5waWVjZU1hcChib2FyZE1hcCk7XG4gICAgICBjb25zdCByb29rUG9zID0gcGllY2VNYXBbY29sb3JdLnJvb2suZmluZCgoc3F1YXJlKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSBzcXVhcmUuc3BsaXQoJycpWzBdO1xuICAgICAgICByZXR1cm4gc2lkZSA9PT0gJ2tpbmdzaWRlJ1xuICAgICAgICAgID8gZmlsZXMuaW5kZXhPZihmaWxlKSA+IDNcbiAgICAgICAgICA6IGZpbGVzLmluZGV4T2YoZmlsZSkgPCAzO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiByb29rUG9zO1xuICAgIH1cbiAgICAvLyBuZWVkIHRvIGdldCBraW5nIHBvc2l0aW9uXG4gICAgLy8gbmVlZCB0byBnZXQgY2FzdGxlIHNxdWFyZXNcbiAgICAvLyBuZWVkIHRvIGZpbmQgcm9va1xuICB9XG5cbiAgY29uc3QgZW5QYXNzYW50ID0gKCgpID0+IHtcbiAgICBmdW5jdGlvbiBnZXRTcXVhcmUoY3VycmVudDogU3F1YXJlLCBjb2xvcjogQ29sb3IpOiBTcXVhcmUge1xuICAgICAgY29uc3QgeyB4LCB5IH0gPSB0b1hZKGN1cnJlbnQpO1xuICAgICAgY29uc3QgbmV3WSA9IGNvbG9yID09PSAnd2hpdGUnID8geSAtIDEgOiB5ICsgMTtcbiAgICAgIHJldHVybiBmcm9tWFkoeyB4LCB5OiBuZXdZIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjaGVja1RvZ2dsZTogKGZyb206IFNxdWFyZSwgdG86IFNxdWFyZSk6IGJvb2xlYW4gPT4ge1xuICAgICAgICBjb25zdCB7IHk6IHkxIH0gPSB0b1hZKGZyb20pO1xuICAgICAgICBjb25zdCB7IHk6IHkyIH0gPSB0b1hZKHRvKTtcblxuICAgICAgICByZXR1cm4gTWF0aC5hYnMoeTEgLSB5MikgPT09IDI7XG4gICAgICB9LFxuICAgICAgdG9nZ2xlOiAoY29sb3I6IENvbG9yLCBjdXJyZW50OiBTcXVhcmUsIGJvYXJkTWFwID0gYm9hcmQpOiB2b2lkID0+IHtcbiAgICAgICAgY29uc3QgZW5QYXNzYW50U3F1YXJlID0gZ2V0U3F1YXJlKGN1cnJlbnQsIGNvbG9yKTtcbiAgICAgICAgYXQoZW5QYXNzYW50U3F1YXJlLCBib2FyZE1hcCkuc2V0RW5QYXNzYW50KGNvbG9yLCBjdXJyZW50KTtcbiAgICAgIH0sXG4gICAgICByZW1vdmU6IChib2FyZE1hcCA9IGJvYXJkKTogdm9pZCA9PiB7XG4gICAgICAgIGZvciAoY29uc3Qgc3F1YXJlT2JqIG9mIGJvYXJkTWFwLnZhbHVlcygpKSB7XG4gICAgICAgICAgaWYgKHNxdWFyZU9iai5lblBhc3NhbnQpIHJldHVybiAoc3F1YXJlT2JqLmVuUGFzc2FudCA9IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpc0NhcHR1cmU6IChmcm9tOiBTcXVhcmUsIHRvOiBTcXVhcmUsIGJvYXJkTWFwID0gYm9hcmQpOiBib29sZWFuID0+IHtcbiAgICAgICAgY29uc3QgcGllY2UgPSBhdChmcm9tLCBib2FyZE1hcCkucGllY2U7XG4gICAgICAgIGNvbnN0IGVuUGFzc2FudCA9IGJvYXJkTWFwLmdldCh0byk/LmVuUGFzc2FudDtcbiAgICAgICAgaWYgKCFwaWVjZSB8fCBwaWVjZS50eXBlICE9PSAncGF3bicpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFlblBhc3NhbnQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGVuUGFzc2FudC5jb2xvciA9PT0gcGllY2UuY29sb3IpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9LFxuICAgICAgY2FwdHVyZTogKHRvOiBTcXVhcmUsIGJvYXJkTWFwID0gYm9hcmQpID0+IHtcbiAgICAgICAgY29uc3QgZW5QYXNzYW50ID0gYm9hcmRNYXAuZ2V0KHRvKT8uZW5QYXNzYW50IGFzIEVuUGFzc2FudE9iajtcblxuICAgICAgICBhdChlblBhc3NhbnQuY3VycmVudCwgYm9hcmRNYXApLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH0pKCk7XG5cbiAgY29uc3QgaXNEcmF3ID0ge1xuICAgIGJ5VGhyZWVmb2xkUmVwZXRpdGlvbjogKFxuICAgICAgYWxsUGllY2VNYXBzOiBBbGxQaWVjZU1hcFtdLFxuICAgICAgbmV3UGllY2VNYXA6IEFsbFBpZWNlTWFwXG4gICAgKSA9PiB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBhbGxQaWVjZU1hcHMuZmlsdGVyKChwbSkgPT4ge1xuICAgICAgICAgIHJldHVybiBjb21wYXJlUGllY2VNYXBzKHBtLCBuZXdQaWVjZU1hcCk7XG4gICAgICAgIH0pLmxlbmd0aCA+PSAzXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBhdCA9IChzcXVhcmU6IFNxdWFyZSwgYm9hcmRNYXAgPSBib2FyZCkgPT4gKHtcbiAgICBwbGFjZTogKHBpZWNlOiBQaWVjZU9iaik6IHZvaWQgPT4ge1xuICAgICAgaWYgKCFib2FyZE1hcC5nZXQoc3F1YXJlKSkgcmV0dXJuO1xuXG4gICAgICBib2FyZE1hcC5zZXQoc3F1YXJlLCB7IHBpZWNlIH0pO1xuICAgIH0sXG4gICAgcmVtb3ZlOiAoKTogdm9pZCA9PiB7XG4gICAgICBpZiAoIWJvYXJkTWFwLmdldChzcXVhcmUpKSByZXR1cm47XG5cbiAgICAgIGJvYXJkTWFwLnNldChzcXVhcmUsIHsgcGllY2U6IG51bGwgfSk7XG4gICAgfSxcbiAgICBwcm9tb3RlOiAocGllY2VUeXBlOiBQaWVjZVR5cGUpOiB2b2lkID0+IHtcbiAgICAgIGNvbnN0IHNxdWFyZVZhbCA9IGJvYXJkTWFwLmdldChzcXVhcmUpO1xuICAgICAgY29uc3QgcGllY2UgPSBzcXVhcmVWYWw/LnBpZWNlO1xuICAgICAgaWYgKCFwaWVjZSkgcmV0dXJuO1xuXG4gICAgICBib2FyZE1hcC5zZXQoc3F1YXJlLCB7XG4gICAgICAgIC4uLnNxdWFyZVZhbCxcbiAgICAgICAgcGllY2U6IHsgLi4ucGllY2UsIHR5cGU6IHBpZWNlVHlwZSB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHNldEVuUGFzc2FudDogKGNvbG9yOiBDb2xvciwgY3VycmVudDogU3F1YXJlKTogdm9pZCA9PiB7XG4gICAgICBpZiAoIWJvYXJkTWFwLmdldChzcXVhcmUpKSByZXR1cm47XG5cbiAgICAgIGJvYXJkTWFwLnNldChzcXVhcmUsIHtcbiAgICAgICAgcGllY2U6IG51bGwsXG4gICAgICAgIGVuUGFzc2FudDoge1xuICAgICAgICAgIGN1cnJlbnQgLyogc3F1YXJlIHBhd24gaXMgb24gKi8sXG4gICAgICAgICAgY29sb3JcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXQgcGllY2UoKSB7XG4gICAgICByZXR1cm4gYm9hcmRNYXAuZ2V0KHNxdWFyZSk/LnBpZWNlO1xuICAgIH0sXG4gICAgZ2V0TGVnYWxNb3ZlczogKGNoZWNrcyA9IHNxdWFyZXNHaXZpbmdDaGVjayB8fCBbXSk6IE1vdmVzID0+IHtcbiAgICAgIGNvbnN0IHsgdHlwZSwgY29sb3IgfSA9IGF0KHNxdWFyZSwgYm9hcmRNYXApLnBpZWNlIGFzIFBpZWNlT2JqO1xuXG4gICAgICBzd2l0Y2ggKGNoZWNrcy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgaWYgKHR5cGUgIT09ICdraW5nJykgcmV0dXJuIFtdO1xuICAgICAgICAgIHJldHVybiBnZXRMZWdhbE1vdmVzKHNxdWFyZSwgYm9hcmRNYXApO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMToge1xuICAgICAgICAgIGlmICh0eXBlID09PSAna2luZycpIHJldHVybiBnZXRMZWdhbE1vdmVzKHNxdWFyZSwgYm9hcmRNYXApO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBnZXRMZWdhbE1vdmVzSW5DaGVjayhcbiAgICAgICAgICAgICAgc3F1YXJlLFxuICAgICAgICAgICAgICBib2FyZE1hcCxcbiAgICAgICAgICAgICAgZ2V0LmtpbmdQb3NpdGlvbihjb2xvcikgYXMgU3F1YXJlLFxuICAgICAgICAgICAgICBjaGVja3NbMF1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGlmICh0eXBlID09PSAna2luZycpIHtcbiAgICAgICAgICAgIGxldCBsZWdhbE1vdmVzID0gZ2V0TGVnYWxNb3ZlcyhzcXVhcmUsIGJvYXJkTWFwKTtcbiAgICAgICAgICAgIGlmIChnZXQuY2FuQ2FzdGxlKGNvbG9yLCAna2luZ3NpZGUnKSlcbiAgICAgICAgICAgICAgbGVnYWxNb3ZlcyA9IFtcbiAgICAgICAgICAgICAgICAuLi5sZWdhbE1vdmVzLFxuICAgICAgICAgICAgICAgIC4uLmdldC5jYXN0bGVTcXVhcmVzKGNvbG9yKS5raW5nc2lkZVxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgaWYgKGdldC5jYW5DYXN0bGUoY29sb3IsICdxdWVlbnNpZGUnKSlcbiAgICAgICAgICAgICAgbGVnYWxNb3ZlcyA9IFtcbiAgICAgICAgICAgICAgICAuLi5sZWdhbE1vdmVzLFxuICAgICAgICAgICAgICAgIC4uLmdldC5jYXN0bGVTcXVhcmVzKGNvbG9yKS5xdWVlbnNpZGVcbiAgICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgcmV0dXJuIGxlZ2FsTW92ZXM7XG4gICAgICAgICAgfSBlbHNlIHJldHVybiBnZXRMZWdhbE1vdmVzKHNxdWFyZSwgYm9hcmRNYXApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBjb25zdCBmcm9tID0gKHMxOiBTcXVhcmUsIGJvYXJkTWFwID0gYm9hcmQpID0+ICh7XG4gICAgdG86IChzMjogU3F1YXJlKTogdm9pZCA9PiB7XG4gICAgICBjb25zdCBwaWVjZSA9IGF0KHMxLCBib2FyZE1hcCkucGllY2U7XG4gICAgICBpZiAoIXBpZWNlKSByZXR1cm47XG5cbiAgICAgIC8vIG1vdmUgcGllY2VcbiAgICAgIGF0KHMxLCBib2FyZE1hcCkucmVtb3ZlKCk7XG4gICAgICBhdChzMiwgYm9hcmRNYXApLnBsYWNlKHBpZWNlKTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IGdldCA9IHtcbiAgICBraW5nUG9zaXRpb246IChjb2xvcjogQ29sb3IsIGJvYXJkTWFwID0gYm9hcmQpOiBTcXVhcmUgfCB1bmRlZmluZWQgPT4ge1xuICAgICAgZm9yIChjb25zdCBbc3F1YXJlLCB2YWx1ZV0gb2YgYm9hcmRNYXAuZW50cmllcygpKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB2YWx1ZS5waWVjZSAmJlxuICAgICAgICAgIHZhbHVlLnBpZWNlLnR5cGUgPT09ICdraW5nJyAmJlxuICAgICAgICAgIHZhbHVlLnBpZWNlLmNvbG9yID09PSBjb2xvclxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIHNxdWFyZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHBpZWNlTWFwOiAoYm9hcmRNYXAgPSBib2FyZCk6IEFsbFBpZWNlTWFwID0+IHtcbiAgICAgIGNvbnN0IHBpZWNlTWFwID0ge1xuICAgICAgICB3aGl0ZToge30gYXMgUGllY2VNYXAsXG4gICAgICAgIGJsYWNrOiB7fSBhcyBQaWVjZU1hcFxuICAgICAgfTtcbiAgICAgIGZvciAoY29uc3QgW3NxdWFyZSwgdmFsdWVdIG9mIGJvYXJkTWFwLmVudHJpZXMoKSkge1xuICAgICAgICBjb25zdCB7IHBpZWNlIH0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKCFwaWVjZSkgY29udGludWU7XG5cbiAgICAgICAgY29uc3QgeyB0eXBlLCBjb2xvciB9ID0gcGllY2U7XG4gICAgICAgIGlmIChwaWVjZU1hcFtjb2xvcl1bdHlwZV0pIHBpZWNlTWFwW2NvbG9yXVt0eXBlXS5wdXNoKHNxdWFyZSk7XG4gICAgICAgIGVsc2UgcGllY2VNYXBbY29sb3JdW3R5cGVdID0gW3NxdWFyZV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcGllY2VNYXA7XG4gICAgfSxcbiAgICBwaWVjZXNUaGF0SGl0U3F1YXJlOiAoXG4gICAgICBjb2xvcjogQ29sb3IsXG4gICAgICBwaWVjZVR5cGU6IFBpZWNlVHlwZSxcbiAgICAgIHNxdWFyZTogU3F1YXJlLFxuICAgICAgYm9hcmRNYXAgPSBib2FyZFxuICAgICk6IFNxdWFyZVtdID0+IHtcbiAgICAgIGNvbnN0IHBpZWNlTWFwID0gZ2V0LnBpZWNlTWFwKGJvYXJkTWFwKTtcbiAgICAgIGlmIChwaWVjZU1hcFtjb2xvcl1bcGllY2VUeXBlXS5pbmNsdWRlcyhzcXVhcmUpKSByZXR1cm4gW107XG5cbiAgICAgIGNvbnN0IHBpZWNlczogU3F1YXJlW10gPSBbXTtcbiAgICAgIGlmIChwaWVjZU1hcFtjb2xvcl1bcGllY2VUeXBlXS5sZW5ndGggPD0gMSkgcmV0dXJuIFtdO1xuICAgICAgcGllY2VNYXBbY29sb3JdW3BpZWNlVHlwZV0uZm9yRWFjaCgocykgPT4ge1xuICAgICAgICBpZiAoYXQocywgYm9hcmRNYXApLmdldExlZ2FsTW92ZXMoKS5pbmNsdWRlcyhzcXVhcmUpKSBwaWVjZXMucHVzaChzKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHBpZWNlcztcbiAgICB9LFxuICAgIHNxdWFyZXNHaXZpbmdDaGVja0FmdGVyTW92ZTogKGZyb206IFNxdWFyZSwgZW5kOiBTcXVhcmUpOiBTcXVhcmVbXSA9PiB7XG4gICAgICBjb25zdCBzcXVhcmVzR2l2aW5nQ2hlY2s6IHN0cmluZ1tdID0gW107XG5cbiAgICAgIGNvbnN0IHBpZWNlID0gYm9hcmQuZ2V0KGVuZCk/LnBpZWNlIGFzIFBpZWNlT2JqO1xuICAgICAgY29uc3Qgb3BwQ29sb3IgPSBwaWVjZS5jb2xvciA9PT0gJ3doaXRlJyA/ICdibGFjaycgOiAnd2hpdGUnO1xuICAgICAgY29uc3Qga2luZ1Bvc2l0aW9uID0gZ2V0LmtpbmdQb3NpdGlvbihvcHBDb2xvcikgYXMgU3F1YXJlO1xuXG4gICAgICBjb25zdCBwaWVjZUhpdHNLaW5nID0gZ2V0TGVnYWxNb3ZlcyhlbmQsIGJvYXJkKS5pbmNsdWRlcyhraW5nUG9zaXRpb24pO1xuICAgICAgaWYgKHBpZWNlSGl0c0tpbmcpIHNxdWFyZXNHaXZpbmdDaGVjay5wdXNoKGVuZCk7XG5cbiAgICAgIGNvbnN0IGRpc2NvdmVyZWRDaGVjayA9IGdldERpc2NvdmVyZWRDaGVjayhcbiAgICAgICAga2luZ1Bvc2l0aW9uLFxuICAgICAgICBvcHBDb2xvcixcbiAgICAgICAgZnJvbSxcbiAgICAgICAgYm9hcmRcbiAgICAgICk7XG4gICAgICBpZiAoZGlzY292ZXJlZENoZWNrICYmIGRpc2NvdmVyZWRDaGVjayAhPT0gZW5kKVxuICAgICAgICBzcXVhcmVzR2l2aW5nQ2hlY2sucHVzaChkaXNjb3ZlcmVkQ2hlY2spO1xuXG4gICAgICByZXR1cm4gc3F1YXJlc0dpdmluZ0NoZWNrO1xuICAgIH0sXG4gICAgaXNDaGVja21hdGU6IChcbiAgICAgIGNvbG9yT2ZLaW5nOiBDb2xvcixcbiAgICAgIHNxdWFyZXNHaXZpbmdDaGVjazogc3RyaW5nW10sXG4gICAgICBib2FyZE1hcCA9IGJvYXJkXG4gICAgKTogYm9vbGVhbiA9PiB7XG4gICAgICBjb25zdCBraW5nUG9zID0gZ2V0LmtpbmdQb3NpdGlvbihjb2xvck9mS2luZywgYm9hcmRNYXApIGFzIFNxdWFyZTtcbiAgICAgIGNvbnN0IGxlZ2FsTW92ZXMgPSBhdChraW5nUG9zLCBib2FyZE1hcCkuZ2V0TGVnYWxNb3ZlcygpO1xuICAgICAgLy8gY2hlY2sgaWYgY2hlY2sgY2FuIGJlIGJsb2NrZWRcbiAgICAgIGlmIChzcXVhcmVzR2l2aW5nQ2hlY2subGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmIChjYW5CbG9ja09yQ2FwdHVyZUNoZWNrKGtpbmdQb3MsIHNxdWFyZXNHaXZpbmdDaGVja1swXSwgYm9hcmRNYXApKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChsZWdhbE1vdmVzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBjYXN0bGVTcXVhcmVzKGNvbG9yOiBDb2xvcik6IENhc3RsZVNxdWFyZXNUeXBlIHtcbiAgICAgIGNvbnN0IHJhbmsgPSBjb2xvciA9PT0gJ3doaXRlJyA/IDEgOiA4O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2luZ3NpZGU6IFtgZiR7cmFua31gLCBgZyR7cmFua31gXSxcbiAgICAgICAgcXVlZW5zaWRlOiBbYGQke3Jhbmt9YCwgYGMke3Jhbmt9YF1cbiAgICAgIH07XG4gICAgfSxcbiAgICBjYXN0bGVTaWRlKGNvbG9yOiBDb2xvciwgdG86IFNxdWFyZSk6ICcnIHwgJ3F1ZWVuc2lkZScgfCAna2luZ3NpZGUnIHtcbiAgICAgIGxldCBjYXN0bGVTaWRlOiAnJyB8ICdxdWVlbnNpZGUnIHwgJ2tpbmdzaWRlJyA9ICcnO1xuICAgICAgY29uc3QgY2FzdGxlU3F1YXJlcyA9IGdldC5jYXN0bGVTcXVhcmVzKGNvbG9yKTtcblxuICAgICAgZm9yIChjb25zdCBbc2lkZSwgc3F1YXJlc10gb2YgT2JqZWN0LmVudHJpZXMoY2FzdGxlU3F1YXJlcykpIHtcbiAgICAgICAgaWYgKHNxdWFyZXNbMV0gPT09IHRvKSBjYXN0bGVTaWRlID0gc2lkZSBhcyAna2luZ3NpZGUnIHwgJ3F1ZWVuc2lkZSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FzdGxlU2lkZTtcbiAgICB9LFxuICAgIGNhc3RsZVJpZ2h0c0FmdGVyTW92ZTogKHNxdWFyZTogU3F1YXJlLCBib2FyZE1hcCA9IGJvYXJkKTogQ2FzdGxlT2JqID0+IHtcbiAgICAgIGNvbnN0IHBpZWNlID0gYXQoc3F1YXJlLCBib2FyZE1hcCkucGllY2UgYXMgUGllY2VPYmo7XG5cbiAgICAgIGNvbnN0IGNhc3RsZVJpZ2h0cyA9IENhc3RsZVJpZ2h0cyB8fCBDYXN0bGUodHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICAgIGlmIChcbiAgICAgICAgY2FzdGxlUmlnaHRzW3BpZWNlLmNvbG9yXS5raW5nc2lkZSB8fFxuICAgICAgICBjYXN0bGVSaWdodHNbcGllY2UuY29sb3JdLnF1ZWVuc2lkZVxuICAgICAgKSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIGkgbmVlZCB0byBjaGFuZ2UgY2FzdGxpbmcgcmlnaHRzXG4gICAgICAgIGlmIChwaWVjZS50eXBlID09PSAna2luZycpIHtcbiAgICAgICAgICBjYXN0bGVSaWdodHNbcGllY2UuY29sb3JdLmtpbmdzaWRlID0gZmFsc2U7XG4gICAgICAgICAgY2FzdGxlUmlnaHRzW3BpZWNlLmNvbG9yXS5xdWVlbnNpZGUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwaWVjZS50eXBlID09PSAncm9vaycpIHtcbiAgICAgICAgICAvLyBuZWVkIHRvIGZpbmQgaWYgaXQgaXMga2luZ3NpZGUgb3IgcXVlZW5zaWRlIHJvb2tcbiAgICAgICAgICBjb25zdCBbZmlsZV0gPSBzcXVhcmUuc3BsaXQoJycpO1xuICAgICAgICAgIGNvbnN0IGtpbmdzaWRlID0gZmlsZXMuaW5kZXhPZihmaWxlKSA+IDM7XG4gICAgICAgICAgaWYgKGtpbmdzaWRlKSBjYXN0bGVSaWdodHNbcGllY2UuY29sb3JdLmtpbmdzaWRlID0gZmFsc2U7XG4gICAgICAgICAgZWxzZSBjYXN0bGVSaWdodHNbcGllY2UuY29sb3JdLnF1ZWVuc2lkZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYXN0bGVSaWdodHM7XG4gICAgfSxcbiAgICBjYW5DYXN0bGU6IChcbiAgICAgIGNvbG9yOiBDb2xvcixcbiAgICAgIHNpZGU6ICdraW5nc2lkZScgfCAncXVlZW5zaWRlJyxcbiAgICAgIGJvYXJkTWFwID0gYm9hcmRcbiAgICApOiBib29sZWFuID0+IHtcbiAgICAgIGlmIChDYXN0bGVSaWdodHMgJiYgIUNhc3RsZVJpZ2h0c1tjb2xvcl1bc2lkZV0pIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gY2hlY2sgaWYgcm9vayBzdGlsbCBleGlzdHNcbiAgICAgIGlmICghY2hlY2tJZlJvb2tFeGlzdHMoKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBjb25zdCBvcHBDb2xvciA9IGNvbG9yID09PSAnd2hpdGUnID8gJ2JsYWNrJyA6ICd3aGl0ZSc7XG4gICAgICBjb25zdCBvcHBNb3ZlcyA9IGdldEF0dGFja2luZ01vdmVzRm9yQ29sb3Iob3BwQ29sb3IsIGJvYXJkTWFwKTtcblxuICAgICAgY29uc3QgY2FzdGxlU3F1YXJlcyA9IGdldC5jYXN0bGVTcXVhcmVzKGNvbG9yKVtzaWRlXTtcbiAgICAgIGZvciAoY29uc3Qgc3F1YXJlIG9mIGNhc3RsZVNxdWFyZXMpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgY2FzdGxlIHNxdWFyZSBpcyBjbGVhcmVkXG4gICAgICAgIGlmIChhdChzcXVhcmUsIGJvYXJkTWFwKS5waWVjZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBtYWtlIHN1cmUgY2FzdGxlIHNxdWFyZSBpc250IGF0dGFja2VkXG4gICAgICAgIGlmIChvcHBNb3Zlcy5pbmNsdWRlcyhzcXVhcmUpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICBmdW5jdGlvbiBjaGVja0lmUm9va0V4aXN0cygpOiBib29sZWFuIHtcbiAgICAgICAgbGV0IHJvb2tFeGlzdHMgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgcmFuayA9IGNvbG9yID09PSAnd2hpdGUnID8gMSA6IDg7XG4gICAgICAgIGNvbnN0IGxvb3BTdGFydCA9XG4gICAgICAgICAgc2lkZSA9PT0gJ3F1ZWVuc2lkZScgPyBmaWxlcy5pbmRleE9mKCdhJykgOiBmaWxlcy5pbmRleE9mKCdkJyk7XG4gICAgICAgIGNvbnN0IGxvb3BFbmQgPVxuICAgICAgICAgIHNpZGUgPT09ICdxdWVlbnNpZGUnID8gZmlsZXMuaW5kZXhPZignZScpIDogZmlsZXMuaW5kZXhPZignaCcpO1xuICAgICAgICBmb3IgKGxldCBpID0gbG9vcFN0YXJ0OyBpIDw9IGxvb3BFbmQ7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHNxdWFyZSA9IGZpbGVzW2ldICsgcmFuaztcblxuICAgICAgICAgIGNvbnN0IHBpZWNlID0gYXQoc3F1YXJlLCBib2FyZE1hcCkucGllY2U7XG4gICAgICAgICAgaWYgKCFwaWVjZSkgY29udGludWU7XG5cbiAgICAgICAgICBpZiAocGllY2UudHlwZSA9PT0gJ3Jvb2snKSByb29rRXhpc3RzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm9va0V4aXN0cztcbiAgICAgIH1cbiAgICB9LFxuICAgIHBpZWNlTWFwc0Zyb21IaXN0b3J5OiAoaGlzdG9yeTogSGlzdG9yeVR5cGUpOiBBbGxQaWVjZU1hcFtdID0+IHtcbiAgICAgIGNvbnN0IHBpZWNlTWFwczogQWxsUGllY2VNYXBbXSA9IFtdO1xuXG4gICAgICBjb25zdCBib2FyZE1hcCA9IGNyZWF0ZUJvYXJkKCk7XG4gICAgICBwbGFjZVBpZWNlcyhzdGFydGluZ1Bvc2l0aW9ucy5zdGFuZGFyZCwgYm9hcmRNYXApO1xuICAgICAgbGV0IHBpZWNlTWFwID0gc3RhcnRpbmdQb3NpdGlvbnMuc3RhbmRhcmQ7XG5cbiAgICAgIC8vIGhpc3RvcnkgaXMgMmQgYXJyYXlcbiAgICAgIGNvbnN0IGZsYXQgPSBoaXN0b3J5LmZsYXQoKTtcblxuICAgICAgLyogaXRlcmF0ZSBvdmVyIGhpc3RvcnkgKi9cbiAgICAgIGZvciAoY29uc3QgW2ksIG1dIG9mIGZsYXQuZW50cmllcygpKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlTm90YXRpb24obSk7XG4gICAgICAgIGNvbnN0IGNvbG9yID0gaSAlIDIgPT09IDAgPyAnd2hpdGUnIDogJ2JsYWNrJztcblxuICAgICAgICBpZiAocGFyc2VkLmNhc3RsZSkge1xuICAgICAgICAgIGNhc3RsZShjb2xvciwgcGFyc2VkLmNhc3RsZSwgYm9hcmRNYXApO1xuICAgICAgICAgIHBpZWNlTWFwID0gZ2V0LnBpZWNlTWFwKGJvYXJkTWFwKTtcbiAgICAgICAgICBwaWVjZU1hcHMucHVzaChwaWVjZU1hcCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwb3NzaWJsZVBpZWNlcyA9IHBpZWNlTWFwW2NvbG9yXVtwYXJzZWQucGllY2VUeXBlXS5maWx0ZXIoKHMpID0+XG4gICAgICAgICAgZ2V0TGVnYWxNb3ZlcyhzLCBib2FyZE1hcCkuaW5jbHVkZXMocGFyc2VkLnRvKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIGdldCAnZnJvbScgc3F1YXJlXG4gICAgICAgIGxldCBzMTogU3F1YXJlO1xuICAgICAgICBpZiAocGFyc2VkLmZyb20pIHtcbiAgICAgICAgICBjb25zdCBub3RhdGlvbiA9IHBhcnNlZC5mcm9tO1xuICAgICAgICAgIGlmIChub3RhdGlvbi5sZW5ndGggPT09IDIpIHMxID0gbm90YXRpb247XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzMSA9XG4gICAgICAgICAgICAgIHBvc3NpYmxlUGllY2VzLmZpbmQoKHMpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBpZiBub3RhdGlvbiBpcyBhIG51bWJlciwgdGhhdCBtZWFucyBwaWVjZSBpcyBvbiB0aGUgcmFuayA9PT0gbm90YXRpb24sIGlmIG5vdCwgc2FtZSBmaWxlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzTmFOKE51bWJlcihub3RhdGlvbikpXG4gICAgICAgICAgICAgICAgICA/IHNbMF0gPT09IG5vdGF0aW9uXG4gICAgICAgICAgICAgICAgICA6IHNbMV0gPT09IG5vdGF0aW9uO1xuICAgICAgICAgICAgICB9KSB8fCAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBzMSA9IHBvc3NpYmxlUGllY2VzWzBdO1xuXG4gICAgICAgIGNvbnN0IHBpZWNlID0gYXQoczEsIGJvYXJkTWFwKS5waWVjZTtcbiAgICAgICAgaWYgKCFzMSB8fCAhcGllY2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1ha2UgbW92ZVxuICAgICAgICBpZiAocGllY2UudHlwZSA9PT0gJ3Bhd24nKSB7XG4gICAgICAgICAgaWYgKGVuUGFzc2FudC5pc0NhcHR1cmUoczEsIHBhcnNlZC50bywgYm9hcmRNYXApKSB7XG4gICAgICAgICAgICBlblBhc3NhbnQuY2FwdHVyZShwYXJzZWQudG8sIGJvYXJkTWFwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlblBhc3NhbnQucmVtb3ZlKGJvYXJkTWFwKTtcblxuICAgICAgICAgIGlmIChlblBhc3NhbnQuY2hlY2tUb2dnbGUoczEsIHBhcnNlZC50bykpXG4gICAgICAgICAgICBlblBhc3NhbnQudG9nZ2xlKGNvbG9yLCBwYXJzZWQudG8sIGJvYXJkTWFwKTtcblxuICAgICAgICAgIGlmIChwYXJzZWQucHJvbW90ZSkge1xuICAgICAgICAgICAgYXQoczEsIGJvYXJkTWFwKS5wcm9tb3RlKHBhcnNlZC5wcm9tb3RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBlblBhc3NhbnQucmVtb3ZlKGJvYXJkTWFwKTtcblxuICAgICAgICBmcm9tKHMxLCBib2FyZE1hcCkudG8ocGFyc2VkLnRvKTtcbiAgICAgICAgcGllY2VNYXAgPSBnZXQucGllY2VNYXAoYm9hcmRNYXApO1xuICAgICAgICBwaWVjZU1hcHMucHVzaChwaWVjZU1hcCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwaWVjZU1hcHM7XG4gICAgfSxcbiAgICBtb3ZlTm90YXRpb24oXG4gICAgICBmcm9tOiBTcXVhcmUsXG4gICAgICB0bzogU3F1YXJlLFxuICAgICAgcHJvbW90ZT86IFBpZWNlVHlwZSxcbiAgICAgIGNoZWNrPzogYm9vbGVhbixcbiAgICAgIGNoZWNrbWF0ZT86IGJvb2xlYW4sXG4gICAgICBib2FyZE1hcCA9IGJvYXJkXG4gICAgKTogc3RyaW5nIHtcbiAgICAgIGNvbnN0IG1vdmVEZXRhaWxzOiBNb3ZlRGV0YWlsc0ludGVyZmFjZSA9IHt9O1xuXG4gICAgICBjb25zdCB7IHR5cGUsIGNvbG9yIH0gPSBhdChmcm9tLCBib2FyZE1hcCkucGllY2UgYXMgUGllY2VPYmo7XG4gICAgICBtb3ZlRGV0YWlscy5waWVjZVR5cGUgPSB0eXBlO1xuXG4gICAgICBpZiAoY2hlY2ttYXRlKSBtb3ZlRGV0YWlscy5jaGVja21hdGUgPSBjaGVja21hdGU7XG4gICAgICBlbHNlIGlmIChjaGVjaykgbW92ZURldGFpbHMuY2hlY2sgPSBjaGVjaztcblxuICAgICAgbGV0IGNhcHR1cmUgPSBmYWxzZTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdwYXduJzoge1xuICAgICAgICAgIGNhcHR1cmUgPSBQaWVjZShjb2xvciwgdHlwZSlcbiAgICAgICAgICAgIC5nZXRQYXduQ2FwdHVyZXMoZnJvbSlcbiAgICAgICAgICAgID8uaW5jbHVkZXModG8pIGFzIGJvb2xlYW47XG4gICAgICAgICAgbW92ZURldGFpbHMuY2FwdHVyZSA9IGNhcHR1cmU7XG4gICAgICAgICAgaWYgKGNhcHR1cmUpIG1vdmVEZXRhaWxzLmRpZmZlcmVudGlhdGlvbiA9IGZyb21bMF07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGNhcHR1cmUgPSAhIWF0KHRvLCBib2FyZE1hcCkucGllY2U7XG4gICAgICAgICAgbW92ZURldGFpbHMuY2FwdHVyZSA9IGNhcHR1cmU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHByb21vdGUpIG1vdmVEZXRhaWxzLnByb21vdGUgPSBwcm9tb3RlO1xuXG4gICAgICAvLyBnZXQgZGlmZmVyZW50aWF0aW9uIGllLiB3aGVuIG11bHRpcGxlIHBpZWNlcyBoaXQgdGhlIHNhbWUgc3F1YXJlXG4gICAgICBjb25zdCBwaWVjZXNUaGF0SGl0U3F1YXJlID0gZ2V0LnBpZWNlc1RoYXRIaXRTcXVhcmUoXG4gICAgICAgIGNvbG9yLFxuICAgICAgICB0eXBlLFxuICAgICAgICB0byxcbiAgICAgICAgYm9hcmRNYXBcbiAgICAgICk7XG4gICAgICBzd2l0Y2ggKHBpZWNlc1RoYXRIaXRTcXVhcmUubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBtb3ZlRGV0YWlscy5kaWZmZXJlbnRpYXRpb24gPSBmcm9tO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAvLyBuZWVkIHRvIGZpbmQgaWYgb24gc2FtZSBmaWxlIG9yIHJhbmtcbiAgICAgICAgICBjb25zdCBvdGhlclBpZWNlID0gcGllY2VzVGhhdEhpdFNxdWFyZS5maW5kKFxuICAgICAgICAgICAgKHMpID0+IHMgIT09IGZyb21cbiAgICAgICAgICApIGFzIFNxdWFyZTtcbiAgICAgICAgICBtb3ZlRGV0YWlscy5kaWZmZXJlbnRpYXRpb24gPVxuICAgICAgICAgICAgb3RoZXJQaWVjZVswXSA9PT0gZnJvbVswXSA/IGZyb21bMV0gOiBmcm9tWzBdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtb3ZlTm90YXRpb24odG8pLmdldChtb3ZlRGV0YWlscyk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHZhbGlkYXRlID0ge1xuICAgIG1vdmU6IChmcm9tOiBTcXVhcmUsIHRvOiBTcXVhcmUsIGJvYXJkTWFwID0gYm9hcmQpOiBib29sZWFuID0+IHtcbiAgICAgIGNvbnN0IHBpZWNlID0gYXQoZnJvbSwgYm9hcmRNYXApLnBpZWNlO1xuICAgICAgaWYgKCFwaWVjZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBpZiAoIWF0KGZyb20sIGJvYXJkTWFwKS5nZXRMZWdhbE1vdmVzKCkuaW5jbHVkZXModG8pKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgcHJvbW90aW9uOiAoZnJvbTogU3F1YXJlLCB0bzogU3F1YXJlLCBib2FyZE1hcCA9IGJvYXJkKTogYm9vbGVhbiA9PiB7XG4gICAgICBjb25zdCBwaWVjZSA9IGF0KGZyb20sIGJvYXJkTWFwKS5waWVjZTtcblxuICAgICAgaWYgKHBpZWNlPy50eXBlICE9PSAncGF3bicpIHJldHVybiBmYWxzZTtcblxuICAgICAgY29uc3QgZW5kT2ZCb2FyZCA9IHBpZWNlLmNvbG9yID09PSAnd2hpdGUnID8gOCA6IDE7XG4gICAgICBjb25zdCBbLCByYW5rXSA9IHRvLnNwbGl0KCcnKTtcbiAgICAgIGlmICgrcmFuayAhPT0gZW5kT2ZCb2FyZCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBjcmVhdGVCb2FyZCxcbiAgICBwbGFjZVBpZWNlcyxcbiAgICBjYXN0bGUsXG4gICAgaXNEcmF3LFxuICAgIGVuUGFzc2FudCxcbiAgICBhdCxcbiAgICBmcm9tLFxuICAgIGdldCxcbiAgICB2YWxpZGF0ZSxcbiAgICBtYWtlTW92ZSxcbiAgICBnZXQgYm9hcmQoKSB7XG4gICAgICByZXR1cm4gYm9hcmQ7XG4gICAgfVxuICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgR2FtZWJvYXJkO1xuIiwiaW1wb3J0IHsgSGlzdG9yeU9iaiB9IGZyb20gJy4vdHlwZXMvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBIaXN0b3J5VHlwZSB9IGZyb20gJy4vdHlwZXMvdHlwZXMnO1xuaW1wb3J0IHsgZGVlcENvcHkyZEFycmF5IH0gZnJvbSAnLi91dGlscy9oZWxwZXJzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSGlzdG9yeShwcmV2SGlzdG9yeTogSGlzdG9yeVR5cGUpOiBIaXN0b3J5T2JqIHtcbiAgY29uc3QgaGlzdG9yeTogSGlzdG9yeVR5cGUgPSBkZWVwQ29weTJkQXJyYXkocHJldkhpc3RvcnkpIHx8IFtdO1xuXG4gIHJldHVybiB7XG4gICAgaW5zZXJ0TW92ZTogKG5vdGF0aW9uOiBzdHJpbmcpID0+IHtcbiAgICAgIGNvbnN0IGxhc3RQYWlyID0gaGlzdG9yeVtoaXN0b3J5Lmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGxhc3RQYWlyICYmIGxhc3RQYWlyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBsYXN0UGFpci5wdXNoKG5vdGF0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5ld1BhaXIgPSBbbm90YXRpb25dO1xuICAgICAgICBoaXN0b3J5LnB1c2gobmV3UGFpcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoaXN0b3J5O1xuICAgIH1cbiAgfTtcbn1cbiIsImltcG9ydCB7IEFsbFBpZWNlTWFwIH0gZnJvbSAnLi90eXBlcy9pbnRlcmZhY2VzJztcblxuY29uc3Qgc3RhbmRhcmQ6IEFsbFBpZWNlTWFwID0ge1xuICB3aGl0ZToge1xuICAgIHJvb2s6IFsnYTEnLCAnaDEnXSxcbiAgICBrbmlnaHQ6IFsnZzEnLCAnYjEnXSxcbiAgICBiaXNob3A6IFsnZjEnLCAnYzEnXSxcbiAgICBraW5nOiBbJ2UxJ10sXG4gICAgcXVlZW46IFsnZDEnXSxcbiAgICBwYXduOiBbJ2EyJywgJ2IyJywgJ2MyJywgJ2QyJywgJ2UyJywgJ2YyJywgJ2cyJywgJ2gyJ11cbiAgfSxcbiAgYmxhY2s6IHtcbiAgICByb29rOiBbJ2E4JywgJ2g4J10sXG4gICAga25pZ2h0OiBbJ2c4JywgJ2I4J10sXG4gICAgYmlzaG9wOiBbJ2Y4JywgJ2M4J10sXG4gICAga2luZzogWydlOCddLFxuICAgIHF1ZWVuOiBbJ2Q4J10sXG4gICAgcGF3bjogWydhNycsICdiNycsICdjNycsICdkNycsICdlNycsICdmNycsICdnNycsICdoNyddXG4gIH1cbn07XG5cbmV4cG9ydCB7IHN0YW5kYXJkIH07XG4iLCJpbXBvcnQgR2FtZWJvYXJkIGZyb20gJy4vR2FtZWJvYXJkJztcbmltcG9ydCBIaXN0b3J5IGZyb20gJy4vSGlzdG9yeSc7XG5pbXBvcnQgQ2FzdGxlIGZyb20gJy4vQ2FzdGxlJztcbmltcG9ydCAqIGFzIHN0YXJ0aW5nUG9zaXRpb25zIGZyb20gJy4vc3RhcnRpbmdQb3NpdGlvbnMnO1xuaW1wb3J0IHsgcmFua3MsIGZpbGVzIH0gZnJvbSAnLi9yYW5rc0FuZEZpbGVzJztcblxuZXhwb3J0IHsgR2FtZWJvYXJkLCBIaXN0b3J5LCBDYXN0bGUsIHN0YXJ0aW5nUG9zaXRpb25zLCByYW5rcywgZmlsZXMgfTtcbiJdLCJuYW1lcyI6WyJ0b1hZIiwic3F1YXJlIiwieCIsInkiLCJzcGxpdCIsImluZGV4T2YiLCJ0b0xvd2VyQ2FzZSIsIk51bWJlciIsImZyb21YWSIsImNvb3JkIiwiY29sIiwiY29uY2F0IiwidG9TdHJpbmciLCJjYWxjRGlzdGFuY2UiLCJzcXVhcmVPbmUiLCJzcXVhcmVUd28iLCJ4MSIsInkxIiwieDIiLCJ5MiIsInhEaWZmIiwieURpZmYiLCJnZXRQaWVjZUZyb21BYmJyIiwiYWJiciIsInBhcnNlTm90YXRpb24iLCJub3RhdGlvbiIsIm1vdmUiLCJyZXBsYWNlZCIsInJlcGxhY2UiLCJjYXN0bGUiLCJsZW5ndGgiLCJ0b1VwcGVyQ2FzZSIsInBpZWNlVHlwZSIsInRvIiwic2xpY2UiLCJmcm9tIiwiaW5jbHVkZXMiLCJwcm9tb3RlIiwicHJvbW90ZU5vdGVJbmRleCIsIm5vUHJvbW90ZU5vdGF0aW9uIiwiZGVlcENvcHkyZEFycmF5IiwiYXJyIiwibWFwIiwibiIsImNvbXBhcmVQaWVjZU1hcHMiLCJwbTEiLCJwbTIiLCJjb2xvciIsInNxdWFyZXMiLCJzcXVhcmVzMiIsImoiLCJtb3ZlcyIsIlBpZWNlIiwidHlwZSIsImhhc01vdmUiLCJvbmVTcXVhcmVWZXJ0IiwieUJ5TiIsInhCeU4iLCJvbmVTcXVhcmVMYXRlcmFsIiwib25lU3F1YXJlRGlhZ29uYWxseSIsImRpYWdvbmFsIiwidmVydEFuZExhdGVyYWwiLCJvbmx5TW92ZXNJbkZyb250IiwicmVndWxhck1vdmUiLCJmaXJzdE1vdmUiLCJqdW1wVHdvIiwiZ2V0UGF3bkNhcHR1cmVzIiwib3JpZ2luIiwibmV3WSIsImNhcHR1cmVPbmUiLCJjYXB0dXJlVHdvIiwiTWF0aCIsImFicyIsIm51bSIsInNwbGl0SW50b1ZlY3RvcnMiLCJhcnJheU9mTW92ZXMiLCJzdGFydCIsInJlZHVjZSIsImFjYyIsImN1cnIiLCJ2ZWN0b3IiLCJjaGFyQXQiLCJwdXNoIiwiZ2V0QmVnaW5uaW5nT2ZWZWN0b3IiLCJhY2NJc0JlZ2lubmluZyIsImdldE1vdmVzQWxvbmdWZWN0b3IiLCJzMSIsInMyIiwiYWxsU3F1YXJlcyIsImxpZXNTYW1lVmVydE9yTGF0IiwibGllc1NhbWVEaWFnb25hbGx5IiwibGllc09uU2FtZUxpbmUiLCJtYXRjaGluZ1ZlY3RvciIsInNxdWFyZXNBbG9uZ1ZlY3RvciIsImZpbHRlciIsInMiLCJzb3J0TW92ZXNDbG9zZXN0VG8iLCJzb3J0IiwiYSIsImIiLCJ4MURpZmYiLCJ5MURpZmYiLCJhRGlmZiIsIngyRGlmZiIsInkyRGlmZiIsImJEaWZmIiwiZ2V0UG9zc2libGVNb3ZlcyIsImJvYXJkIiwiQXJyYXkiLCJrZXlzIiwiZ2V0IiwicGllY2UiLCJnZXRMZWdhbE1vdmVzIiwicG9zc2libGVNb3ZlcyIsIm9ic3RydWN0aW9ucyIsIl9hIiwicmVtb3ZlUHJvdGVjdGVkU3F1YXJlcyIsImxlZ2FsTW92ZXMiLCJjYXB0dXJlc0F2YWlsYWJsZSIsInVub2JzdHJ1Y3RlZE1vdmVzIiwicmVtb3ZlTW92ZXNXaXRoUGllY2VzIiwicmVtb3ZlT2JzdHJ1Y3RlZE1vdmVzIiwiZ2V0TGVnYWxNb3Zlc0luQ2hlY2siLCJraW5nUG9zIiwic3F1YXJlR2l2aW5nQ2hlY2siLCJzcXVhcmVzVGhhdERlYWxXaXRoQ2hlY2siLCJnZXRTcXVhcmVzQmV0d2VlbktpbmdBbmRDaGVjayIsImdldEF0dGFja2luZ01vdmVzIiwiYXR0YWNraW5nTW92ZXMiLCJnZXRBbGxNb3Zlc0ZvckNvbG9yIiwic2tpcEtpbmciLCJhbGxNb3ZlcyIsImVudHJpZXMiLCJmbGF0IiwiZ2V0QXR0YWNraW5nTW92ZXNGb3JDb2xvciIsInBhd25TcXVhcmUiLCJwYXduIiwiY2FwdHVyZU1vdmVzIiwic3F1YXJlVmFsIiwiZW5QYXNzYW50IiwiY2hlY2tQb3MiLCJzcXVhcmVzQmV0d2VlbktpbmdBbmRQaWVjZSIsInJlbW92ZU1vdmVzQmVoaW5kVHdvU3F1YXJlcyIsInNvcnRlZCIsImZ1cnRoZXN0U3F1YXJlIiwiY2xvc2VzdFNxdWFyZSIsInJlbW92ZWRPbmVFbmQiLCJyZW1vdmVNb3Zlc0JlaGluZFNxdWFyZSIsInJlbW92ZWRCb3RoRW5kcyIsInJldmVyc2UiLCJjb3B5IiwiaW5kZXgiLCJzcGxpY2UiLCJzdGFydGluZ1NxdWFyZSIsImZpbHRlcmVkTW92ZXMiLCJhbGxWZWN0b3JzIiwib2JzdHJ1Y3Rpb25WZWN0b3JzIiwiY2xvc2VzdE9ic3RydWN0aW9uIiwia2luZyIsIm9wcENvbG9yIiwiZW5lbXlQaWVjZXNJblZpY2luaXR5IiwiX2IiLCJzcXVhcmVzUHJvdGVjdGVkQnlFbmVteUluVmljaW5pdHkiLCJib2FyZENvcHkiLCJNYXAiLCJmb3JFYWNoIiwic2V0Iiwic3F1YXJlc1Byb3RlY3RlZEJ5UmFuZ2UiLCJnZXREaXNjb3ZlcmVkQ2hlY2siLCJraW5nQ29sb3IiLCJ2YWNhdGVkIiwiY2FuQmxvY2tPckNhcHR1cmVDaGVjayIsImJsb2NrT3JDYXB0dXJlU3F1YXJlcyIsIm93blBpZWNlTW92ZXMiLCJzb21lIiwiZ2V0UGllY2VzV2l0aE1vdmUiLCJwaWVjZVNxdWFyZXMiLCJmaWxlcyIsInJhbmtzIiwiQ2FzdGxlIiwid2hpdGVLaW5nc2lkZSIsIndoaXRlUXVlZW5zaWRlIiwiYmxhY2tLaW5nc2lkZSIsImJsYWNrUXVlZW5zaWRlIiwid2hpdGUiLCJraW5nc2lkZSIsInF1ZWVuc2lkZSIsImJsYWNrIiwibW92ZU5vdGF0aW9uIiwic2lkZSIsImFmZml4IiwicGllY2VOb3RhdGlvbiIsImRpZmZlcmVudGlhdGlvbiIsImNhcHR1cmUiLCJzdWZmaXgiLCJjaGVjayIsImNoZWNrbWF0ZSIsIm1vdmVEZXRhaWxzIiwiY2FzdGxlU2lkZSIsInN0YXJ0aW5nUG9zaXRpb25zIiwiY3JlYXRlQm9hcmQiLCJmaWxlIiwicmFuayIsIkdhbWVib2FyZCIsInNxdWFyZXNHaXZpbmdDaGVjayIsIkNhc3RsZVJpZ2h0cyIsInBsYWNlUGllY2VzIiwicGllY2VNYXAiLCJib2FyZE1hcCIsImF0IiwicGxhY2UiLCJtYWtlTW92ZSIsInZhbGlkYXRlIiwicHJvbW90aW9uIiwiaXNDYXB0dXJlIiwicmVtb3ZlIiwiY2hlY2tUb2dnbGUiLCJ0b2dnbGUiLCJjYXN0bGVTcXVhcmVzIiwia2luZ1Bvc2l0aW9uIiwicm9va1BvcyIsImdldFJvb2tQb3MiLCJyb29rIiwiZmluZCIsImdldFNxdWFyZSIsImN1cnJlbnQiLCJlblBhc3NhbnRTcXVhcmUiLCJzZXRFblBhc3NhbnQiLCJzcXVhcmVPYmoiLCJ2YWx1ZXMiLCJ1bmRlZmluZWQiLCJpc0RyYXciLCJieVRocmVlZm9sZFJlcGV0aXRpb24iLCJhbGxQaWVjZU1hcHMiLCJuZXdQaWVjZU1hcCIsInBtIiwiT2JqZWN0IiwiY2hlY2tzIiwiY2FuQ2FzdGxlIiwidmFsdWUiLCJwaWVjZXNUaGF0SGl0U3F1YXJlIiwicGllY2VzIiwic3F1YXJlc0dpdmluZ0NoZWNrQWZ0ZXJNb3ZlIiwiZW5kIiwicGllY2VIaXRzS2luZyIsImRpc2NvdmVyZWRDaGVjayIsImlzQ2hlY2ttYXRlIiwiY29sb3JPZktpbmciLCJjYXN0bGVSaWdodHNBZnRlck1vdmUiLCJjYXN0bGVSaWdodHMiLCJjaGVja0lmUm9va0V4aXN0cyIsIm9wcE1vdmVzIiwicm9va0V4aXN0cyIsImxvb3BTdGFydCIsImxvb3BFbmQiLCJpIiwicGllY2VNYXBzRnJvbUhpc3RvcnkiLCJoaXN0b3J5IiwicGllY2VNYXBzIiwic3RhbmRhcmQiLCJtIiwicGFyc2VkIiwicG9zc2libGVQaWVjZXMiLCJpc05hTiIsIm90aGVyUGllY2UiLCJlbmRPZkJvYXJkIiwiSGlzdG9yeSIsInByZXZIaXN0b3J5IiwiaW5zZXJ0TW92ZSIsImxhc3RQYWlyIiwibmV3UGFpciIsImtuaWdodCIsImJpc2hvcCIsInF1ZWVuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///327\n")}},__webpack_require__={d:(Q,F)=>{for(var B in F)__webpack_require__.o(F,B)&&!__webpack_require__.o(Q,B)&&Object.defineProperty(Q,B,{enumerable:!0,get:F[B]})},o:(Q,F)=>Object.prototype.hasOwnProperty.call(Q,F),r:Q=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})}},__webpack_exports__={};return __webpack_modules__[327](0,__webpack_exports__,__webpack_require__),__webpack_exports__})()));