!function(Q,F){"object"==typeof exports&&"object"==typeof module?module.exports=F():"function"==typeof define&&define.amd?define([],F):"object"==typeof exports?exports.croChess=F():Q.croChess=F()}(this,(function(){return(()=>{"use strict";var __webpack_modules__={371:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"Gameboard\": () => (/* reexport */ src_Gameboard),\n  \"History\": () => (/* reexport */ History)\n});\n\n;// CONCATENATED MODULE: ./src/utils/helpers.ts\nvar __read = undefined && undefined.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nfunction toXY(square) {\n  var _a = __read(square.split(''), 2),\n      x = _a[0],\n      y = _a[1];\n\n  return {\n    x: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'].indexOf(x.toLowerCase()),\n    y: Number(y)\n  };\n}\n\nfunction fromXY(coord) {\n  var x = coord.x,\n      y = coord.y;\n  var col = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'][x];\n  if (!col) return '';\n  return col.concat(y.toString());\n}\n\nvar calcDistance = function (squareOne) {\n  return function (squareTwo) {\n    var _a = toXY(squareOne),\n        x1 = _a.x,\n        y1 = _a.y;\n\n    var _b = toXY(squareTwo),\n        x2 = _b.x,\n        y2 = _b.y;\n\n    var xDiff = x1 - x2;\n    var yDiff = y1 - y2;\n    return {\n      xDiff: xDiff,\n      yDiff: yDiff\n    };\n  };\n};\n\n\n;// CONCATENATED MODULE: ./src/Piece.ts\n\n\n\nvar Piece = function (color, type) {\n  function hasMove(from, to) {\n    switch (type) {\n      case 'king':\n        {\n          var oneSquareVert = utils_moves.yByN(1)(from)(to) && utils_moves.xByN(0)(from)(to);\n          var oneSquareLateral = utils_moves.xByN(1)(from)(to) && utils_moves.yByN(0)(from)(to);\n          var oneSquareDiagonally = utils_moves.yByN(1)(from)(to) && utils_moves.xByN(1)(from)(to);\n          return from !== to && (oneSquareDiagonally || oneSquareVert || oneSquareLateral);\n        }\n\n      case 'queen':\n        {\n          return from !== to && (utils_moves.diagonal(from)(to) || utils_moves.vertAndLateral(from)(to));\n        }\n\n      case 'bishop':\n        {\n          return from !== to && utils_moves.diagonal(from)(to);\n        }\n\n      case 'knight':\n        {\n          return from !== to && (utils_moves.xByN(1)(from)(to) && utils_moves.yByN(2)(from)(to) || utils_moves.xByN(2)(from)(to) && utils_moves.yByN(1)(from)(to));\n        }\n\n      case 'rook':\n        {\n          return from !== to && utils_moves.vertAndLateral(to)(from);\n        }\n\n      case 'pawn':\n        {\n          var _a = toXY(from),\n              x1 = _a.x,\n              y1 = _a.y;\n\n          var _b = toXY(to),\n              x2 = _b.x,\n              y2 = _b.y;\n\n          var onlyMovesInFront = color === 'white' ? y1 < y2 : y1 > y2;\n          var regularMove = utils_moves.yByN(1)(from)(to) && x1 === x2;\n          var firstMove = color === 'white' ? y1 === 2 : y1 === 7;\n          var jumpTwo = utils_moves.yByN(2)(from)(to) && x1 === x2;\n          return from !== to && onlyMovesInFront && (regularMove || firstMove && jumpTwo);\n        }\n    }\n  }\n\n  function getPawnCaptures(origin) {\n    if (type !== 'pawn') return;\n\n    var _a = toXY(origin),\n        x = _a.x,\n        y = _a.y;\n\n    var newY = color === 'white' ? y + 1 : y - 1;\n    var captureOne = {\n      x: x + 1,\n      y: newY\n    };\n    var captureTwo = {\n      x: x - 1,\n      y: newY\n    };\n    return [fromXY(captureOne), fromXY(captureTwo)];\n  }\n\n  return {\n    hasMove: hasMove,\n    getPawnCaptures: getPawnCaptures,\n\n    get type() {\n      return type;\n    },\n\n    get color() {\n      return color;\n    }\n\n  };\n};\n\n/* harmony default export */ const src_Piece = (Piece);\n;// CONCATENATED MODULE: ./src/utils/moves.ts\nvar moves_read = undefined && undefined.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = undefined && undefined.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nvar __values = undefined && undefined.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\n\n\nvar moves = {\n  vertAndLateral: function (from) {\n    return function (to) {\n      var _a = moves_read(from.split(''), 2),\n          x1 = _a[0],\n          y1 = _a[1];\n\n      var _b = moves_read(to.split(''), 2),\n          x2 = _b[0],\n          y2 = _b[1];\n\n      return x1 === x2 || y1 === y2;\n    };\n  },\n  diagonal: function (from) {\n    return function (to) {\n      var _a = toXY(from),\n          x1 = _a.x,\n          y1 = _a.y;\n\n      var _b = toXY(to),\n          x2 = _b.x,\n          y2 = _b.y;\n\n      return Math.abs(x2 - x1) === Math.abs(y2 - y1);\n    };\n  },\n  xByN: function (num) {\n    return function (from) {\n      return function (to) {\n        var x1 = toXY(from).x;\n        var x2 = toXY(to).x;\n        return Math.abs(x1 - x2) === num;\n      };\n    };\n  },\n  yByN: function (num) {\n    return function (from) {\n      return function (to) {\n        var y1 = toXY(from).y;\n        var y2 = toXY(to).y;\n        return Math.abs(y1 - y2) === num;\n      };\n    };\n  }\n};\n/* harmony default export */ const utils_moves = (moves);\n/* dealing with move vectors */\n\nfunction splitIntoVectors(arrayOfMoves, start) {\n  return arrayOfMoves.reduce(function (acc, curr) {\n    var _a = calcDistance(start)(curr),\n        xDiff = _a.xDiff,\n        yDiff = _a.yDiff;\n\n    var vector = '';\n    if (yDiff !== 0) vector = yDiff < 0 ? 'up' : 'down';\n    if (xDiff !== 0) vector += xDiff < 0 ? 'Right' : 'Left'; // normalize vector name\n\n    vector = vector.charAt(0).toLowerCase() + vector.slice(1);\n    acc[vector] = acc[vector] || [];\n    acc[vector].push(curr);\n    return acc;\n  }, {});\n}\n\nfunction getBeginningOfVector(vector) {\n  if (vector.length === 0) return '';\n  return vector.reduce(function (acc, curr) {\n    var _a = toXY(acc),\n        x1 = _a.x,\n        y1 = _a.y;\n\n    var _b = toXY(curr),\n        x2 = _b.x,\n        y2 = _b.y;\n\n    var accIsBeginning = x1 === x2 ? y1 < y2 : x1 < x2;\n    return accIsBeginning ? acc : curr;\n  });\n}\n\nvar getMovesAlongVector = function (s1, s2, allSquares) {\n  var liesSameVertOrLat = moves.vertAndLateral(s1)(s2);\n  var liesSameDiagonally = moves.diagonal(s1)(s2);\n  var liesOnSameLine = liesSameVertOrLat || liesSameDiagonally;\n  if (!liesOnSameLine) return [];\n  var matchingVector = liesSameDiagonally ? 'diagonal' : 'vertAndLateral';\n  var squaresAlongVector = allSquares.filter(function (s) {\n    return moves[matchingVector](s1)(s) && moves[matchingVector](s2)(s);\n  });\n  return squaresAlongVector;\n};\n/* sort moves */\n\n\nvar sortMovesClosestTo = function (square) {\n  return function (moves) {\n    return __spreadArray([], moves_read(moves), false).sort(function (a, b) {\n      var _a = calcDistance(square)(a),\n          x1Diff = _a.xDiff,\n          y1Diff = _a.yDiff;\n\n      var aDiff = Math.abs(x1Diff) + Math.abs(y1Diff);\n\n      var _b = calcDistance(square)(b),\n          x2Diff = _b.xDiff,\n          y2Diff = _b.yDiff;\n\n      var bDiff = Math.abs(x2Diff) + Math.abs(y2Diff);\n      return aDiff - bDiff;\n    });\n  };\n};\n/* get moves */\n\n\nfunction getPossibleMoves(origin, board) {\n  // get all moves that can happen if no other pieces were on the board\n  var allSquares = Array.from(board.keys());\n  var square = board.get(origin);\n  var _a = square.piece,\n      type = _a.type,\n      color = _a.color;\n  var piece = src_Piece(color, type);\n  return allSquares.filter(function (s) {\n    return piece.hasMove(origin, s);\n  });\n}\n\nfunction getLegalMoves(origin, board) {\n  // get moves regardless of whether or not there is check\n  var square = board.get(origin);\n  var piece = square.piece;\n  var possibleMoves = getPossibleMoves(origin, board);\n  var obstructions = possibleMoves.filter(function (s) {\n    var _a;\n\n    return (_a = board.get(s)) === null || _a === void 0 ? void 0 : _a.piece;\n  });\n\n  if (!obstructions.length) {\n    if (piece.type === 'pawn') return __spreadArray(__spreadArray([], moves_read(getPawnCaptures(origin, board)), false), moves_read(possibleMoves), false);\n    return possibleMoves;\n  }\n\n  var legalMoves = [];\n\n  switch (piece.type) {\n    case 'knight':\n      {\n        legalMoves = possibleMoves;\n        break;\n      }\n\n    case 'pawn':\n      {\n        var capturesAvailable = getPawnCaptures(origin, board);\n        var unobstructedMoves = removeMovesWithPieces(removeObstructedMoves(origin, possibleMoves, obstructions), board);\n        legalMoves = __spreadArray(__spreadArray([], moves_read(capturesAvailable), false), moves_read(unobstructedMoves), false);\n        break;\n      }\n\n    case 'king':\n      {\n        legalMoves = removeProtectedSquares(piece, possibleMoves, board);\n        break;\n      }\n\n    default:\n      {\n        legalMoves = removeObstructedMoves(origin, possibleMoves, obstructions);\n      }\n  }\n\n  return removeMovesWithPieces(legalMoves, board, piece.color);\n}\n\nfunction getLegalMovesInCheck(origin, board, kingPos, squareGivingCheck) {\n  var squaresThatDealWithCheck = getSquaresBetweenKingAndCheck(kingPos, squareGivingCheck, Array.from(board.keys()));\n  var moves = getLegalMoves(origin, board);\n  return moves.filter(function (s) {\n    return squaresThatDealWithCheck.includes(s);\n  });\n}\n\nfunction getAttackingMoves(origin, board) {\n  // for when you need to check for if squares are protected\n  var square = board.get(origin);\n  var _a = square.piece,\n      type = _a.type,\n      color = _a.color;\n\n  switch (type) {\n    case 'pawn':\n      {\n        var piece = src_Piece(color, 'pawn');\n        return piece.getPawnCaptures(origin);\n      }\n\n    default:\n      return getLegalMoves(origin, board);\n  }\n}\n\nfunction getAllMovesForColor(color, board) {\n  var e_1, _a;\n\n  var allMoves = [];\n\n  try {\n    for (var _b = __values(board.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\n      var _d = moves_read(_c.value, 2),\n          square = _d[0],\n          piece = _d[1].piece;\n\n      if (!piece) continue;\n      if (piece.color !== color) continue;\n      allMoves.push(getLegalMoves(square, board));\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  return allMoves.flat();\n}\n\nfunction getAttackingMovesForColor(color, board) {\n  var e_2, _a;\n\n  var allMoves = [];\n\n  try {\n    for (var _b = __values(board.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\n      var _d = moves_read(_c.value, 2),\n          square = _d[0],\n          piece = _d[1].piece;\n\n      if (!piece) continue;\n      if (piece.color !== color) continue;\n      allMoves.push(getAttackingMoves(square, board));\n    }\n  } catch (e_2_1) {\n    e_2 = {\n      error: e_2_1\n    };\n  } finally {\n    try {\n      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n    } finally {\n      if (e_2) throw e_2.error;\n    }\n  }\n\n  return allMoves.flat();\n}\n\nfunction getPawnCaptures(pawnSquare, board) {\n  var _a;\n\n  var color = ((_a = board.get(pawnSquare)) === null || _a === void 0 ? void 0 : _a.piece).color;\n  var pawn = src_Piece(color, 'pawn');\n  var captureMoves = pawn.getPawnCaptures(pawnSquare);\n  if (!captureMoves) return [];\n  return captureMoves.filter(function (s) {\n    var squareVal = board.get(s);\n    if (!squareVal) return false;\n    var piece = squareVal.piece;\n    var enPassant = squareVal.enPassant;\n    return piece && piece.color !== pawn.color || enPassant && enPassant.color !== pawn.color;\n  });\n}\n\nfunction getSquaresBetweenKingAndCheck(kingPos, checkPos, allSquares) {\n  // includes kingPos and checkPos\n  var squaresAlongVector = getMovesAlongVector(kingPos, checkPos, allSquares);\n  var squaresBetweenKingAndPiece = removeMovesBehindTwoSquares(kingPos, checkPos, squaresAlongVector);\n  return squaresBetweenKingAndPiece;\n}\n/* filter moves */\n\n\nfunction removeMovesBehindTwoSquares(s1, s2, vector) {\n  var sorted = sortMovesClosestTo(getBeginningOfVector(vector))(vector);\n  var furthestSquare;\n  var closestSquare;\n\n  if (sorted.indexOf(s1) > sorted.indexOf(s2)) {\n    furthestSquare = s1;\n    closestSquare = s2;\n  } else {\n    furthestSquare = s2;\n    closestSquare = s1;\n  }\n\n  var removedOneEnd = removeMovesBehindSquare(furthestSquare)(sorted);\n  var removedBothEnds = removeMovesBehindSquare(closestSquare)(removedOneEnd.reverse());\n  return removedBothEnds;\n}\n\nvar removeMovesBehindSquare = function (square) {\n  return function (moves) {\n    var copy = __spreadArray([], moves_read(moves), false);\n\n    var index = moves.indexOf(square);\n    if (index === -1) return [];\n    copy.splice(index + 1);\n    return copy;\n  };\n};\n\nfunction removeObstructedMoves(startingSquare, possibleMoves, obstructions) {\n  // a) split possible moves into vectors (up,down,left,right, and/or diagonals)\n  // b) see which obstructions belong to which vector\n  // c) find the closest obstruction\n  // d) remove all the moves behind that obstruction\n  var filteredMoves = [];\n  var allVectors = splitIntoVectors(possibleMoves, startingSquare);\n  var obstructionVectors = splitIntoVectors(obstructions, startingSquare);\n\n  for (var vector in allVectors) {\n    if (!obstructionVectors[vector]) {\n      // look for vector obstruction is on\n      filteredMoves.push(allVectors[vector]);\n      continue;\n    }\n\n    var sorted = sortMovesClosestTo(startingSquare)(allVectors[vector]);\n    var closestObstruction = sortMovesClosestTo(startingSquare)(obstructionVectors[vector])[0];\n    filteredMoves.push(removeMovesBehindSquare(closestObstruction)(sorted));\n  }\n\n  return filteredMoves.flat();\n}\n\nfunction removeProtectedSquares(king, possibleMoves, board) {\n  // bc king cant move if square is protected\n  var oppColor = king.color === 'white' ? 'black' : 'white';\n  var allEnemyMoves = getAttackingMovesForColor(oppColor, board);\n  return possibleMoves.filter(function (s) {\n    return !allEnemyMoves.includes(s);\n  });\n}\n\nfunction removeMovesWithPieces(moves, board, color) {\n  return moves.filter(function (s) {\n    var squareVal = board.get(s);\n    if (!squareVal) return false;\n    if (color) return !squareVal.piece || squareVal.piece.color !== color;else return !squareVal.piece;\n  });\n}\n/* gameboard checks */\n\n\nfunction getDiscoveredCheck(kingPos, kingColor, vacated, board) {\n  var e_3, _a;\n\n  var _b; // openSquare is a square just vacated\n\n\n  var squaresAlongVector = getMovesAlongVector(kingPos, vacated, Array.from(board.keys()));\n  squaresAlongVector = squaresAlongVector.filter(function (s) {\n    return s !== kingPos && s !== vacated;\n  });\n  if (!squaresAlongVector.length) return '';\n\n  try {\n    for (var squaresAlongVector_1 = __values(squaresAlongVector), squaresAlongVector_1_1 = squaresAlongVector_1.next(); !squaresAlongVector_1_1.done; squaresAlongVector_1_1 = squaresAlongVector_1.next()) {\n      var square = squaresAlongVector_1_1.value;\n      var piece = (_b = board.get(square)) === null || _b === void 0 ? void 0 : _b.piece;\n      if (!piece || piece.color === kingColor) continue;\n      var legalMoves = getLegalMoves(square, board);\n      if (legalMoves.includes(kingPos)) return square;\n    }\n  } catch (e_3_1) {\n    e_3 = {\n      error: e_3_1\n    };\n  } finally {\n    try {\n      if (squaresAlongVector_1_1 && !squaresAlongVector_1_1.done && (_a = squaresAlongVector_1.return)) _a.call(squaresAlongVector_1);\n    } finally {\n      if (e_3) throw e_3.error;\n    }\n  }\n\n  return '';\n}\n\nfunction canBlockOrCaptureCheck(kingPos, squareGivingCheck, board) {\n  var _a;\n\n  var king = (_a = board.get(kingPos)) === null || _a === void 0 ? void 0 : _a.piece;\n  var blockOrCaptureSquares = getSquaresBetweenKingAndCheck(kingPos, squareGivingCheck, Array.from(board.keys())); // also includes check square\n\n  var ownPieceMoves = getAllMovesForColor(king.color, board);\n  return ownPieceMoves.some(function (move) {\n    return blockOrCaptureSquares.includes(move);\n  });\n}\n\n\n;// CONCATENATED MODULE: ./src/Gameboard.ts\nvar __assign = undefined && undefined.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar Gameboard_values = undefined && undefined.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nvar Gameboard_read = undefined && undefined.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar Gameboard_spreadArray = undefined && undefined.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\n\n\n\nvar Gameboard = function (board, squaresGivingCheck) {\n  board = board || createBoard();\n\n  function createBoard() {\n    var files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];\n    var ranks = [1, 2, 3, 4, 5, 6, 7, 8];\n    return files.reduce(function (acc, file) {\n      ranks.forEach(function (rank) {\n        var square = file.concat(rank.toString());\n        acc.set(square, {\n          piece: null\n        });\n      });\n      return acc;\n    }, new Map());\n  }\n\n  function canCastle(color, side) {\n    var rank = color === 'white' ? 1 : 8;\n    var castleSquares = side === 'kingside' ? [\"f\".concat(rank), \"g\".concat(rank)] : [\"c\".concat(rank), \"d\".concat(rank)];\n    var oppColor = color === 'white' ? 'black' : 'white';\n    var oppMoves = getAttackingMovesForColor(oppColor, board);\n    var canCastle = true;\n    castleSquares.forEach(function (s) {\n      // check if castle square is cleared\n      if (at(s).piece) canCastle = false; // make sure castle square isnt attacked\n\n      if (oppMoves.includes(s)) {\n        canCastle = false;\n      }\n    });\n    return canCastle;\n  }\n\n  function castle(color, side) {\n    var rank = color === 'white' ? 1 : 8;\n    var castleSquares = side === 'kingside' ? [\"f\".concat(rank), \"g\".concat(rank)] : [\"d\".concat(rank), \"c\".concat(rank)];\n    var kingPos = get.kingPosition(color);\n    var rookPos = getRookPos();\n    from(rookPos).to(castleSquares[0]);\n    from(kingPos).to(castleSquares[1]);\n\n    function getRookPos() {\n      var pieceMap = get.pieceMap();\n      var rookPos = pieceMap[color].rook.find(function (square) {\n        var file = square.split('')[0];\n        return side === 'kingside' ? ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'].indexOf(file) > 3 : ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'].indexOf(file) < 3;\n      });\n      return rookPos;\n    } // need to get king position\n    // need to get castle squares\n    // need to find rook\n\n  }\n\n  var enPassant = function () {\n    function getSquare(current, color) {\n      var _a = toXY(current),\n          x = _a.x,\n          y = _a.y;\n\n      var newY = color === 'white' ? y - 1 : y + 1;\n      return fromXY({\n        x: x,\n        y: newY\n      });\n    }\n\n    return {\n      checkToggle: function (from, to) {\n        var y1 = toXY(from).y;\n        var y2 = toXY(to).y;\n        return Math.abs(y1 - y2) === 2;\n      },\n      toggle: function (current, color) {\n        var enPassantSquare = getSquare(current, color);\n        at(enPassantSquare).setEnPassant(color, current);\n      },\n      remove: function () {\n        var e_1, _a;\n\n        try {\n          for (var _b = Gameboard_values(board.values()), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var squareObj = _c.value;\n            if (squareObj.enPassant) return squareObj.enPassant = undefined;\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n      }\n    };\n  }();\n\n  var at = function (square) {\n    return {\n      place: function (piece) {\n        if (!board.get(square)) return 'square does not exist';\n        board.set(square, {\n          piece: piece\n        });\n      },\n      remove: function () {\n        if (!board.get(square)) return 'square does not exist';\n        board.set(square, {\n          piece: null\n        });\n      },\n      promote: function (pieceType) {\n        var squareVal = board.get(square);\n        var piece = squareVal === null || squareVal === void 0 ? void 0 : squareVal.piece;\n        if (!piece) return;\n        board.set(square, __assign(__assign({}, squareVal), {\n          piece: __assign(__assign({}, piece), {\n            type: pieceType\n          })\n        }));\n      },\n      setEnPassant: function (color, current) {\n        if (!board.get(square)) return 'square does not exist';\n        board.set(square, {\n          piece: null,\n          enPassant: {\n            current: current,\n            color: color\n          }\n        });\n      },\n\n      get piece() {\n        var _a;\n\n        return (_a = board.get(square)) === null || _a === void 0 ? void 0 : _a.piece;\n      },\n\n      getLegalMoves: function () {\n        squaresGivingCheck = squaresGivingCheck || [];\n        var _a = at(square).piece,\n            type = _a.type,\n            color = _a.color;\n\n        switch (squaresGivingCheck.length) {\n          case 2:\n            {\n              if (type !== 'king') return [];\n              return getLegalMoves(square, board);\n            }\n\n          case 1:\n            {\n              return getLegalMovesInCheck(origin, board, get.kingPosition(color), squaresGivingCheck[0]);\n            }\n\n          case 0:\n            {\n              return getLegalMoves(square, board);\n            }\n        }\n      }\n    };\n  };\n\n  var from = function (s1) {\n    return {\n      to: function (s2) {\n        var piece = at(s1).piece;\n        if (!piece) return; // move piece\n\n        at(s1).remove();\n        at(s2).place(piece);\n      }\n    };\n  };\n\n  var get = {\n    kingPosition: function (color) {\n      var e_2, _a;\n\n      try {\n        for (var _b = Gameboard_values(board.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var _d = Gameboard_read(_c.value, 2),\n              square = _d[0],\n              value = _d[1];\n\n          if (value.piece && value.piece.type === 'king' && value.piece.color === color) return square;\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    },\n    pieceMap: function () {\n      var e_3, _a;\n\n      var pieceMap = {\n        white: {},\n        black: {}\n      };\n\n      try {\n        for (var _b = Gameboard_values(board.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var _d = Gameboard_read(_c.value, 2),\n              square = _d[0],\n              value = _d[1];\n\n          var piece = value.piece;\n          if (!piece) continue;\n          var type = piece.type,\n              color = piece.color;\n          pieceMap[color][type] = pieceMap[color][type] ? Gameboard_spreadArray(Gameboard_spreadArray([], Gameboard_read(pieceMap[color][type]), false), [square], false) : [square];\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n\n      return pieceMap;\n    },\n    piecePositions: function (color) {\n      var e_4, _a;\n\n      var piecePositions = [];\n\n      try {\n        for (var _b = Gameboard_values(board.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var _d = Gameboard_read(_c.value, 2),\n              square = _d[0],\n              value = _d[1];\n\n          if (value.piece && value.piece.color === color) piecePositions.push(square);\n        }\n      } catch (e_4_1) {\n        e_4 = {\n          error: e_4_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_4) throw e_4.error;\n        }\n      }\n\n      return piecePositions;\n    },\n    squaresGivingCheckAfterMove: function (from, end) {\n      var _a;\n\n      var squaresGivingCheck = [];\n      var piece = (_a = board.get(end)) === null || _a === void 0 ? void 0 : _a.piece;\n      var oppColor = piece.color === 'white' ? 'black' : 'white';\n      var kingPosition = get.kingPosition(oppColor);\n      var pieceHitsKing = getLegalMoves(end, board).includes(kingPosition);\n      if (pieceHitsKing) squaresGivingCheck.push(end);\n      var discoveredCheck = getDiscoveredCheck(kingPosition, oppColor, from, board);\n      if (discoveredCheck) squaresGivingCheck.push(discoveredCheck);\n      return squaresGivingCheck;\n    },\n    isCheckmate: function (color, squaresGivingCheck) {\n      var kingPos = get.kingPosition(color);\n      var legalMoves = at(kingPos).getLegalMoves(); // check if check can be blocked\n\n      if (squaresGivingCheck.length === 1) {\n        if (canBlockOrCaptureCheck(kingPos, squaresGivingCheck[0], board)) return false;\n      }\n\n      if (!legalMoves || !legalMoves.length) return true;\n      return false;\n    }\n  };\n  return {\n    createBoard: createBoard,\n    castle: castle,\n    canCastle: canCastle,\n    enPassant: enPassant,\n    at: at,\n    from: from,\n    get: get,\n\n    get board() {\n      return board;\n    }\n\n  };\n};\n\n/* harmony default export */ const src_Gameboard = (Gameboard);\n;// CONCATENATED MODULE: ./src/History.ts\n// should output history object that holds move history in 2d array\n// for each move needs to attach piece Type to beginning of move if not pawn\n// should further specify square of piece if, say both rooks, can move to same square\nvar History_read = undefined && undefined.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\n\nfunction History(prevHistory, board, pieceMap) {\n  var history = prevHistory || [];\n  var get = {\n    piecePrefix: function (from, to) {\n      var _a;\n\n      var _b = (_a = board.get(to)) === null || _a === void 0 ? void 0 : _a.piece,\n          type = _b.type,\n          color = _b.color;\n\n      switch (type) {\n        case 'pawn':\n          return '';\n\n        case 'knight':\n        case 'rook':\n          {\n            var prefix_1 = type === 'rook' ? 'R' : 'N';\n\n            if (pieceMap[color][type].length !== 1) {\n              // look for piece of same type that couldve also went to the square\n              pieceMap[color][type].forEach(function (s) {\n                if (s === to) return;\n                var boardCopy = new Map(board);\n                boardCopy.set(to, {\n                  piece: null\n                });\n\n                if (getLegalMoves(s, boardCopy).includes(to)) {\n                  var _a = History_read(from.split(''), 2),\n                      x1 = _a[0],\n                      y1 = _a[1];\n\n                  var _b = History_read(s.split(''), 1),\n                      x2 = _b[0];\n\n                  var sameFile = x1 === x2;\n                  prefix_1 = sameFile ? prefix_1 + y1 : prefix_1 + x1;\n                }\n              });\n            }\n\n            return prefix_1;\n          }\n\n        default:\n          {\n            var prefix = type.charAt(0).toUpperCase();\n            return prefix;\n          }\n      }\n    },\n    castleNotation: function (side) {\n      return side === 'kingside' ? 'O-O' : 'O-O-O';\n    }\n  };\n  var affix = {\n    capture: function (move, prefix) {\n      return \"\".concat(prefix, \"x\").concat(move);\n    },\n    promote: function (move, pieceType) {\n      var suffix = pieceType === 'knight' ? 'N' : pieceType.charAt(0).toUpperCase();\n      return \"\".concat(move, \"=\").concat(suffix);\n    },\n    check: function (notation) {\n      return \"\".concat(notation, \"+\");\n    },\n    checkmate: function (notation) {\n      return \"\".concat(notation, \"#\");\n    }\n  };\n  return {\n    get: get,\n    affix: affix,\n    insertMove: function (notation) {\n      var lastMovePair = history[history.length - 1];\n\n      if (lastMovePair.length === 1) {\n        lastMovePair.push(notation);\n      } else {\n        var newMovePair = [notation];\n        history.push(newMovePair);\n      }\n    }\n  };\n}\n;// CONCATENATED MODULE: ./src/main.ts\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LE9BRkE7QUFHTE0sY0FBVSxFQUFFLFVBQUNGLFFBQUQsRUFBaUI7QUFDM0IsVUFBTUcsWUFBWSxHQUFHZixPQUFPLENBQUNBLE9BQU8sQ0FBQ3pJLE1BQVIsR0FBaUIsQ0FBbEIsQ0FBNUI7O0FBQ0EsVUFBSXdKLFlBQVksQ0FBQ3hKLE1BQWIsS0FBd0IsQ0FBNUIsRUFBK0I7QUFDN0J3SixvQkFBWSxDQUFDMUosSUFBYixDQUFrQnVKLFFBQWxCO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsWUFBTUksV0FBVyxHQUFHLENBQUNKLFFBQUQsQ0FBcEI7QUFDQVosZUFBTyxDQUFDM0ksSUFBUixDQUFhMkosV0FBYjtBQUNEO0FBQ0Y7QUFYSSxHQUFQO0FBYUQsQzs7QUN6RkQ7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Nyb0NoZXNzLy4vc3JjL3V0aWxzL2hlbHBlcnMudHM/MjhmMyIsIndlYnBhY2s6Ly9jcm9DaGVzcy8uL3NyYy9QaWVjZS50cz8yZWI4Iiwid2VicGFjazovL2Nyb0NoZXNzLy4vc3JjL3V0aWxzL21vdmVzLnRzPzUwZmIiLCJ3ZWJwYWNrOi8vY3JvQ2hlc3MvLi9zcmMvR2FtZWJvYXJkLnRzPzU3ZTMiLCJ3ZWJwYWNrOi8vY3JvQ2hlc3MvLi9zcmMvSGlzdG9yeS50cz80YzIxIiwid2VicGFjazovL2Nyb0NoZXNzLy4vc3JjL21haW4udHM/Y2Q0OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb29yZCB9IGZyb20gJy4uL3R5cGVzL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgU3F1YXJlIH0gZnJvbSAnLi4vdHlwZXMvdHlwZXMnO1xuXG5mdW5jdGlvbiB0b1hZKHNxdWFyZTogU3F1YXJlKTogQ29vcmQge1xuICBjb25zdCBbeCwgeV0gPSBzcXVhcmUuc3BsaXQoJycpO1xuICByZXR1cm4ge1xuICAgIHg6IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJywgJ2YnLCAnZycsICdoJ10uaW5kZXhPZih4LnRvTG93ZXJDYXNlKCkpLFxuICAgIHk6IE51bWJlcih5KVxuICB9O1xufVxuXG5mdW5jdGlvbiBmcm9tWFkoY29vcmQ6IENvb3JkKTogU3F1YXJlIHtcbiAgY29uc3QgeyB4LCB5IH0gPSBjb29yZDtcbiAgY29uc3QgY29sID0gWydhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJywgJ2gnXVt4XTtcbiAgaWYgKCFjb2wpIHJldHVybiAnJztcbiAgcmV0dXJuIGNvbC5jb25jYXQoeS50b1N0cmluZygpKTtcbn1cblxuY29uc3QgY2FsY0Rpc3RhbmNlID0gKHNxdWFyZU9uZTogc3RyaW5nKSA9PiAoc3F1YXJlVHdvOiBzdHJpbmcpID0+IHtcbiAgY29uc3QgeyB4OiB4MSwgeTogeTEgfSA9IHRvWFkoc3F1YXJlT25lKTtcbiAgY29uc3QgeyB4OiB4MiwgeTogeTIgfSA9IHRvWFkoc3F1YXJlVHdvKTtcblxuICBjb25zdCB4RGlmZiA9IHgxIC0geDI7XG4gIGNvbnN0IHlEaWZmID0geTEgLSB5MjtcbiAgcmV0dXJuIHtcbiAgICB4RGlmZixcbiAgICB5RGlmZlxuICB9O1xufTtcblxuZXhwb3J0IHsgdG9YWSwgZnJvbVhZLCBjYWxjRGlzdGFuY2UgfTtcbiIsImltcG9ydCBtb3ZlcyBmcm9tICcuL3V0aWxzL21vdmVzJztcbmltcG9ydCB7IHRvWFksIGZyb21YWSB9IGZyb20gJy4vdXRpbHMvaGVscGVycyc7XG5cbmltcG9ydCB7IENvbG9yLCBTcXVhcmUsIFBpZWNlVHlwZSB9IGZyb20gJy4vdHlwZXMvdHlwZXMnO1xuXG5jb25zdCBQaWVjZSA9IChjb2xvcjogQ29sb3IsIHR5cGU6IFBpZWNlVHlwZSkgPT4ge1xuICBmdW5jdGlvbiBoYXNNb3ZlKGZyb206IFNxdWFyZSwgdG86IFNxdWFyZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAna2luZyc6IHtcbiAgICAgICAgY29uc3Qgb25lU3F1YXJlVmVydCA9XG4gICAgICAgICAgbW92ZXMueUJ5TigxKShmcm9tKSh0bykgJiYgbW92ZXMueEJ5TigwKShmcm9tKSh0byk7XG4gICAgICAgIGNvbnN0IG9uZVNxdWFyZUxhdGVyYWwgPVxuICAgICAgICAgIG1vdmVzLnhCeU4oMSkoZnJvbSkodG8pICYmIG1vdmVzLnlCeU4oMCkoZnJvbSkodG8pO1xuICAgICAgICBjb25zdCBvbmVTcXVhcmVEaWFnb25hbGx5ID1cbiAgICAgICAgICBtb3Zlcy55QnlOKDEpKGZyb20pKHRvKSAmJiBtb3Zlcy54QnlOKDEpKGZyb20pKHRvKTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGZyb20gIT09IHRvICYmXG4gICAgICAgICAgKG9uZVNxdWFyZURpYWdvbmFsbHkgfHwgb25lU3F1YXJlVmVydCB8fCBvbmVTcXVhcmVMYXRlcmFsKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2FzZSAncXVlZW4nOiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgZnJvbSAhPT0gdG8gJiZcbiAgICAgICAgICAobW92ZXMuZGlhZ29uYWwoZnJvbSkodG8pIHx8IG1vdmVzLnZlcnRBbmRMYXRlcmFsKGZyb20pKHRvKSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2Jpc2hvcCc6IHtcbiAgICAgICAgcmV0dXJuIGZyb20gIT09IHRvICYmIG1vdmVzLmRpYWdvbmFsKGZyb20pKHRvKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2tuaWdodCc6IHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBmcm9tICE9PSB0byAmJlxuICAgICAgICAgICgobW92ZXMueEJ5TigxKShmcm9tKSh0bykgJiYgbW92ZXMueUJ5TigyKShmcm9tKSh0bykpIHx8XG4gICAgICAgICAgICAobW92ZXMueEJ5TigyKShmcm9tKSh0bykgJiYgbW92ZXMueUJ5TigxKShmcm9tKSh0bykpKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2FzZSAncm9vayc6IHtcbiAgICAgICAgcmV0dXJuIGZyb20gIT09IHRvICYmIG1vdmVzLnZlcnRBbmRMYXRlcmFsKHRvKShmcm9tKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ3Bhd24nOiB7XG4gICAgICAgIGNvbnN0IHsgeDogeDEsIHk6IHkxIH0gPSB0b1hZKGZyb20pO1xuICAgICAgICBjb25zdCB7IHg6IHgyLCB5OiB5MiB9ID0gdG9YWSh0byk7XG5cbiAgICAgICAgY29uc3Qgb25seU1vdmVzSW5Gcm9udCA9IGNvbG9yID09PSAnd2hpdGUnID8geTEgPCB5MiA6IHkxID4geTI7XG4gICAgICAgIGNvbnN0IHJlZ3VsYXJNb3ZlID0gbW92ZXMueUJ5TigxKShmcm9tKSh0bykgJiYgeDEgPT09IHgyO1xuXG4gICAgICAgIGNvbnN0IGZpcnN0TW92ZSA9IGNvbG9yID09PSAnd2hpdGUnID8geTEgPT09IDIgOiB5MSA9PT0gNztcbiAgICAgICAgY29uc3QganVtcFR3byA9IG1vdmVzLnlCeU4oMikoZnJvbSkodG8pICYmIHgxID09PSB4MjtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGZyb20gIT09IHRvICYmXG4gICAgICAgICAgb25seU1vdmVzSW5Gcm9udCAmJlxuICAgICAgICAgIChyZWd1bGFyTW92ZSB8fCAoZmlyc3RNb3ZlICYmIGp1bXBUd28pKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFBhd25DYXB0dXJlcyhvcmlnaW46IFNxdWFyZSkge1xuICAgIGlmICh0eXBlICE9PSAncGF3bicpIHJldHVybjtcblxuICAgIGNvbnN0IHsgeCwgeSB9ID0gdG9YWShvcmlnaW4pO1xuXG4gICAgY29uc3QgbmV3WSA9IGNvbG9yID09PSAnd2hpdGUnID8geSArIDEgOiB5IC0gMTtcblxuICAgIGNvbnN0IGNhcHR1cmVPbmUgPSB7IHg6IHggKyAxLCB5OiBuZXdZIH07XG4gICAgY29uc3QgY2FwdHVyZVR3byA9IHsgeDogeCAtIDEsIHk6IG5ld1kgfTtcblxuICAgIHJldHVybiBbZnJvbVhZKGNhcHR1cmVPbmUpLCBmcm9tWFkoY2FwdHVyZVR3byldO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBoYXNNb3ZlLFxuICAgIGdldFBhd25DYXB0dXJlcyxcbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH0sXG4gICAgZ2V0IGNvbG9yKCkge1xuICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFBpZWNlO1xuIiwiaW1wb3J0IHsgY2FsY0Rpc3RhbmNlLCB0b1hZIH0gZnJvbSAnLi9oZWxwZXJzJztcbmltcG9ydCB7XG4gIFBpZWNlSW50ZXJmYWNlLFxuICBTcXVhcmVPYmosXG4gIFBpZWNlT2JqLFxuICBFblBhc3NhbnRPYmpcbn0gZnJvbSAnLi4vdHlwZXMvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBNb3ZlcywgQm9hcmQsIFNxdWFyZSwgQ29sb3IgfSBmcm9tICcuLi90eXBlcy90eXBlcyc7XG5pbXBvcnQgUGllY2UgZnJvbSAnLi4vUGllY2UnO1xuXG5jb25zdCBtb3ZlcyA9IHtcbiAgdmVydEFuZExhdGVyYWw6IChmcm9tOiBTcXVhcmUpID0+ICh0bzogU3F1YXJlKSA9PiB7XG4gICAgY29uc3QgW3gxLCB5MV0gPSBmcm9tLnNwbGl0KCcnKTtcbiAgICBjb25zdCBbeDIsIHkyXSA9IHRvLnNwbGl0KCcnKTtcbiAgICByZXR1cm4geDEgPT09IHgyIHx8IHkxID09PSB5MjtcbiAgfSxcbiAgZGlhZ29uYWw6IChmcm9tOiBTcXVhcmUpID0+ICh0bzogU3F1YXJlKSA9PiB7XG4gICAgY29uc3QgeyB4OiB4MSwgeTogeTEgfSA9IHRvWFkoZnJvbSk7XG4gICAgY29uc3QgeyB4OiB4MiwgeTogeTIgfSA9IHRvWFkodG8pO1xuICAgIHJldHVybiBNYXRoLmFicyh4MiAtIHgxKSA9PT0gTWF0aC5hYnMoeTIgLSB5MSk7XG4gIH0sXG4gIHhCeU46IChudW06IG51bWJlcikgPT4gKGZyb206IFNxdWFyZSkgPT4gKHRvOiBTcXVhcmUpID0+IHtcbiAgICBjb25zdCB7IHg6IHgxIH0gPSB0b1hZKGZyb20pO1xuICAgIGNvbnN0IHsgeDogeDIgfSA9IHRvWFkodG8pO1xuICAgIHJldHVybiBNYXRoLmFicyh4MSAtIHgyKSA9PT0gbnVtO1xuICB9LFxuICB5QnlOOiAobnVtOiBudW1iZXIpID0+IChmcm9tOiBTcXVhcmUpID0+ICh0bzogU3F1YXJlKSA9PiB7XG4gICAgY29uc3QgeyB5OiB5MSB9ID0gdG9YWShmcm9tKTtcbiAgICBjb25zdCB7IHk6IHkyIH0gPSB0b1hZKHRvKTtcbiAgICByZXR1cm4gTWF0aC5hYnMoeTEgLSB5MikgPT09IG51bTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgbW92ZXM7XG5cbi8qIGRlYWxpbmcgd2l0aCBtb3ZlIHZlY3RvcnMgKi9cblxuZnVuY3Rpb24gc3BsaXRJbnRvVmVjdG9ycyhhcnJheU9mTW92ZXM6IE1vdmVzLCBzdGFydDogU3F1YXJlKSB7XG4gIGludGVyZmFjZSBWZWN0b3JzIHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmdbXTtcbiAgfVxuICByZXR1cm4gYXJyYXlPZk1vdmVzLnJlZHVjZSgoYWNjOiBWZWN0b3JzLCBjdXJyOiBTcXVhcmUpID0+IHtcbiAgICBjb25zdCB7IHhEaWZmLCB5RGlmZiB9ID0gY2FsY0Rpc3RhbmNlKHN0YXJ0KShjdXJyKTtcblxuICAgIGxldCB2ZWN0b3IgPSAnJztcbiAgICBpZiAoeURpZmYgIT09IDApIHZlY3RvciA9IHlEaWZmIDwgMCA/ICd1cCcgOiAnZG93bic7XG4gICAgaWYgKHhEaWZmICE9PSAwKSB2ZWN0b3IgKz0geERpZmYgPCAwID8gJ1JpZ2h0JyA6ICdMZWZ0JztcblxuICAgIC8vIG5vcm1hbGl6ZSB2ZWN0b3IgbmFtZVxuICAgIHZlY3RvciA9IHZlY3Rvci5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIHZlY3Rvci5zbGljZSgxKTtcblxuICAgIGFjY1t2ZWN0b3JdID0gYWNjW3ZlY3Rvcl0gfHwgW107XG4gICAgYWNjW3ZlY3Rvcl0ucHVzaChjdXJyKTtcblxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gZ2V0QmVnaW5uaW5nT2ZWZWN0b3IodmVjdG9yOiBNb3Zlcykge1xuICBpZiAodmVjdG9yLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuXG4gIHJldHVybiB2ZWN0b3IucmVkdWNlKChhY2MsIGN1cnIpID0+IHtcbiAgICBjb25zdCB7IHg6IHgxLCB5OiB5MSB9ID0gdG9YWShhY2MpO1xuICAgIGNvbnN0IHsgeDogeDIsIHk6IHkyIH0gPSB0b1hZKGN1cnIpO1xuXG4gICAgY29uc3QgYWNjSXNCZWdpbm5pbmcgPSB4MSA9PT0geDIgPyB5MSA8IHkyIDogeDEgPCB4MjtcbiAgICByZXR1cm4gYWNjSXNCZWdpbm5pbmcgPyBhY2MgOiBjdXJyO1xuICB9KTtcbn1cblxuY29uc3QgZ2V0TW92ZXNBbG9uZ1ZlY3RvciA9IChcbiAgczE6IFNxdWFyZSxcbiAgczI6IFNxdWFyZSxcbiAgYWxsU3F1YXJlczogTW92ZXNcbik6IE1vdmVzID0+IHtcbiAgY29uc3QgbGllc1NhbWVWZXJ0T3JMYXQgPSBtb3Zlcy52ZXJ0QW5kTGF0ZXJhbChzMSkoczIpO1xuICBjb25zdCBsaWVzU2FtZURpYWdvbmFsbHkgPSBtb3Zlcy5kaWFnb25hbChzMSkoczIpO1xuXG4gIGNvbnN0IGxpZXNPblNhbWVMaW5lID0gbGllc1NhbWVWZXJ0T3JMYXQgfHwgbGllc1NhbWVEaWFnb25hbGx5O1xuICBpZiAoIWxpZXNPblNhbWVMaW5lKSByZXR1cm4gW107XG5cbiAgY29uc3QgbWF0Y2hpbmdWZWN0b3IgPSBsaWVzU2FtZURpYWdvbmFsbHkgPyAnZGlhZ29uYWwnIDogJ3ZlcnRBbmRMYXRlcmFsJztcblxuICBjb25zdCBzcXVhcmVzQWxvbmdWZWN0b3IgPSBhbGxTcXVhcmVzLmZpbHRlcihcbiAgICAocykgPT4gbW92ZXNbbWF0Y2hpbmdWZWN0b3JdKHMxKShzKSAmJiBtb3Zlc1ttYXRjaGluZ1ZlY3Rvcl0oczIpKHMpXG4gICk7XG4gIHJldHVybiBzcXVhcmVzQWxvbmdWZWN0b3I7XG59O1xuXG4vKiBzb3J0IG1vdmVzICovXG5cbmNvbnN0IHNvcnRNb3Zlc0Nsb3Nlc3RUbyA9XG4gIChzcXVhcmU6IFNxdWFyZSkgPT5cbiAgKG1vdmVzOiBNb3Zlcyk6IE1vdmVzID0+IHtcbiAgICByZXR1cm4gWy4uLm1vdmVzXS5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBjb25zdCB7IHhEaWZmOiB4MURpZmYsIHlEaWZmOiB5MURpZmYgfSA9IGNhbGNEaXN0YW5jZShzcXVhcmUpKGEpO1xuICAgICAgY29uc3QgYURpZmYgPSBNYXRoLmFicyh4MURpZmYpICsgTWF0aC5hYnMoeTFEaWZmKTtcblxuICAgICAgY29uc3QgeyB4RGlmZjogeDJEaWZmLCB5RGlmZjogeTJEaWZmIH0gPSBjYWxjRGlzdGFuY2Uoc3F1YXJlKShiKTtcbiAgICAgIGNvbnN0IGJEaWZmID0gTWF0aC5hYnMoeDJEaWZmKSArIE1hdGguYWJzKHkyRGlmZik7XG5cbiAgICAgIHJldHVybiBhRGlmZiAtIGJEaWZmO1xuICAgIH0pO1xuICB9O1xuXG4vKiBnZXQgbW92ZXMgKi9cblxuZnVuY3Rpb24gZ2V0UG9zc2libGVNb3ZlcyhvcmlnaW46IFNxdWFyZSwgYm9hcmQ6IEJvYXJkKSB7XG4gIC8vIGdldCBhbGwgbW92ZXMgdGhhdCBjYW4gaGFwcGVuIGlmIG5vIG90aGVyIHBpZWNlcyB3ZXJlIG9uIHRoZSBib2FyZFxuICBjb25zdCBhbGxTcXVhcmVzID0gQXJyYXkuZnJvbShib2FyZC5rZXlzKCkpO1xuXG4gIGNvbnN0IHNxdWFyZSA9IGJvYXJkLmdldChvcmlnaW4pIGFzIFNxdWFyZU9iajtcblxuICBjb25zdCB7IHR5cGUsIGNvbG9yIH0gPSBzcXVhcmUucGllY2UgYXMgUGllY2VPYmo7XG4gIGNvbnN0IHBpZWNlID0gUGllY2UoY29sb3IsIHR5cGUpO1xuXG4gIHJldHVybiBhbGxTcXVhcmVzLmZpbHRlcigocykgPT4gcGllY2UuaGFzTW92ZShvcmlnaW4sIHMpKTtcbn1cblxuZnVuY3Rpb24gZ2V0TGVnYWxNb3ZlcyhvcmlnaW46IFNxdWFyZSwgYm9hcmQ6IEJvYXJkKSB7XG4gIC8vIGdldCBtb3ZlcyByZWdhcmRsZXNzIG9mIHdoZXRoZXIgb3Igbm90IHRoZXJlIGlzIGNoZWNrXG5cbiAgY29uc3Qgc3F1YXJlID0gYm9hcmQuZ2V0KG9yaWdpbikgYXMgU3F1YXJlT2JqO1xuXG4gIGNvbnN0IHBpZWNlID0gc3F1YXJlLnBpZWNlIGFzIFBpZWNlT2JqO1xuXG4gIGNvbnN0IHBvc3NpYmxlTW92ZXMgPSBnZXRQb3NzaWJsZU1vdmVzKG9yaWdpbiwgYm9hcmQpO1xuXG4gIGNvbnN0IG9ic3RydWN0aW9ucyA9IHBvc3NpYmxlTW92ZXMuZmlsdGVyKChzKSA9PiBib2FyZC5nZXQocyk/LnBpZWNlKTtcbiAgaWYgKCFvYnN0cnVjdGlvbnMubGVuZ3RoKSB7XG4gICAgaWYgKHBpZWNlLnR5cGUgPT09ICdwYXduJylcbiAgICAgIHJldHVybiBbLi4uZ2V0UGF3bkNhcHR1cmVzKG9yaWdpbiwgYm9hcmQpLCAuLi5wb3NzaWJsZU1vdmVzXTtcbiAgICByZXR1cm4gcG9zc2libGVNb3ZlcztcbiAgfVxuXG4gIGxldCBsZWdhbE1vdmVzOiBNb3ZlcyA9IFtdO1xuICBzd2l0Y2ggKHBpZWNlLnR5cGUpIHtcbiAgICBjYXNlICdrbmlnaHQnOiB7XG4gICAgICBsZWdhbE1vdmVzID0gcG9zc2libGVNb3ZlcztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlICdwYXduJzoge1xuICAgICAgY29uc3QgY2FwdHVyZXNBdmFpbGFibGUgPSBnZXRQYXduQ2FwdHVyZXMob3JpZ2luLCBib2FyZCk7XG4gICAgICBjb25zdCB1bm9ic3RydWN0ZWRNb3ZlcyA9IHJlbW92ZU1vdmVzV2l0aFBpZWNlcyhcbiAgICAgICAgcmVtb3ZlT2JzdHJ1Y3RlZE1vdmVzKG9yaWdpbiwgcG9zc2libGVNb3Zlcywgb2JzdHJ1Y3Rpb25zKSxcbiAgICAgICAgYm9hcmRcbiAgICAgICk7XG4gICAgICBsZWdhbE1vdmVzID0gWy4uLmNhcHR1cmVzQXZhaWxhYmxlLCAuLi51bm9ic3RydWN0ZWRNb3Zlc107XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAna2luZyc6IHtcbiAgICAgIGxlZ2FsTW92ZXMgPSByZW1vdmVQcm90ZWN0ZWRTcXVhcmVzKHBpZWNlLCBwb3NzaWJsZU1vdmVzLCBib2FyZCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgbGVnYWxNb3ZlcyA9IHJlbW92ZU9ic3RydWN0ZWRNb3ZlcyhvcmlnaW4sIHBvc3NpYmxlTW92ZXMsIG9ic3RydWN0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlbW92ZU1vdmVzV2l0aFBpZWNlcyhsZWdhbE1vdmVzLCBib2FyZCwgcGllY2UuY29sb3IpO1xufVxuXG5mdW5jdGlvbiBnZXRMZWdhbE1vdmVzSW5DaGVjayhcbiAgb3JpZ2luOiBTcXVhcmUsXG4gIGJvYXJkOiBCb2FyZCxcbiAga2luZ1BvczogU3F1YXJlLFxuICBzcXVhcmVHaXZpbmdDaGVjazogU3F1YXJlXG4pIHtcbiAgY29uc3Qgc3F1YXJlc1RoYXREZWFsV2l0aENoZWNrID0gZ2V0U3F1YXJlc0JldHdlZW5LaW5nQW5kQ2hlY2soXG4gICAga2luZ1BvcyxcbiAgICBzcXVhcmVHaXZpbmdDaGVjayxcbiAgICBBcnJheS5mcm9tKGJvYXJkLmtleXMoKSlcbiAgKTtcblxuICBjb25zdCBtb3ZlcyA9IGdldExlZ2FsTW92ZXMob3JpZ2luLCBib2FyZCk7XG5cbiAgcmV0dXJuIG1vdmVzLmZpbHRlcigocykgPT4gc3F1YXJlc1RoYXREZWFsV2l0aENoZWNrLmluY2x1ZGVzKHMpKTtcbn1cblxuZnVuY3Rpb24gZ2V0QXR0YWNraW5nTW92ZXMob3JpZ2luOiBTcXVhcmUsIGJvYXJkOiBCb2FyZCkge1xuICAvLyBmb3Igd2hlbiB5b3UgbmVlZCB0byBjaGVjayBmb3IgaWYgc3F1YXJlcyBhcmUgcHJvdGVjdGVkXG4gIGNvbnN0IHNxdWFyZSA9IGJvYXJkLmdldChvcmlnaW4pIGFzIFNxdWFyZU9iajtcblxuICBjb25zdCB7IHR5cGUsIGNvbG9yIH0gPSBzcXVhcmUucGllY2UgYXMgUGllY2VPYmo7XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAncGF3bic6IHtcbiAgICAgIGNvbnN0IHBpZWNlID0gUGllY2UoY29sb3IsICdwYXduJyk7XG4gICAgICByZXR1cm4gcGllY2UuZ2V0UGF3bkNhcHR1cmVzKG9yaWdpbikgYXMgTW92ZXM7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZ2V0TGVnYWxNb3ZlcyhvcmlnaW4sIGJvYXJkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRBbGxNb3Zlc0ZvckNvbG9yKGNvbG9yOiBDb2xvciwgYm9hcmQ6IEJvYXJkKTogTW92ZXMge1xuICBjb25zdCBhbGxNb3ZlczogTW92ZXNbXSA9IFtdO1xuICBmb3IgKGNvbnN0IFtzcXVhcmUsIHsgcGllY2UgfV0gb2YgYm9hcmQuZW50cmllcygpKSB7XG4gICAgaWYgKCFwaWVjZSkgY29udGludWU7XG4gICAgaWYgKHBpZWNlLmNvbG9yICE9PSBjb2xvcikgY29udGludWU7XG5cbiAgICBhbGxNb3Zlcy5wdXNoKGdldExlZ2FsTW92ZXMoc3F1YXJlLCBib2FyZCkpO1xuICB9XG5cbiAgcmV0dXJuIGFsbE1vdmVzLmZsYXQoKTtcbn1cblxuZnVuY3Rpb24gZ2V0QXR0YWNraW5nTW92ZXNGb3JDb2xvcihjb2xvcjogQ29sb3IsIGJvYXJkOiBCb2FyZCk6IE1vdmVzIHtcbiAgY29uc3QgYWxsTW92ZXM6IE1vdmVzW10gPSBbXTtcbiAgZm9yIChjb25zdCBbc3F1YXJlLCB7IHBpZWNlIH1dIG9mIGJvYXJkLmVudHJpZXMoKSkge1xuICAgIGlmICghcGllY2UpIGNvbnRpbnVlO1xuICAgIGlmIChwaWVjZS5jb2xvciAhPT0gY29sb3IpIGNvbnRpbnVlO1xuXG4gICAgYWxsTW92ZXMucHVzaChnZXRBdHRhY2tpbmdNb3ZlcyhzcXVhcmUsIGJvYXJkKSk7XG4gIH1cblxuICByZXR1cm4gYWxsTW92ZXMuZmxhdCgpO1xufVxuXG5mdW5jdGlvbiBnZXRQYXduQ2FwdHVyZXMocGF3blNxdWFyZTogU3F1YXJlLCBib2FyZDogQm9hcmQpIHtcbiAgY29uc3QgeyBjb2xvciB9ID0gYm9hcmQuZ2V0KHBhd25TcXVhcmUpPy5waWVjZSBhcyBQaWVjZU9iajtcbiAgY29uc3QgcGF3biA9IFBpZWNlKGNvbG9yLCAncGF3bicpO1xuXG4gIGNvbnN0IGNhcHR1cmVNb3ZlcyA9IHBhd24uZ2V0UGF3bkNhcHR1cmVzKHBhd25TcXVhcmUpO1xuICBpZiAoIWNhcHR1cmVNb3ZlcykgcmV0dXJuIFtdO1xuXG4gIHJldHVybiBjYXB0dXJlTW92ZXMuZmlsdGVyKChzKSA9PiB7XG4gICAgY29uc3Qgc3F1YXJlVmFsID0gYm9hcmQuZ2V0KHMpO1xuICAgIGlmICghc3F1YXJlVmFsKSByZXR1cm4gZmFsc2U7XG5cbiAgICBjb25zdCBwaWVjZSA9IHNxdWFyZVZhbC5waWVjZTtcbiAgICBjb25zdCBlblBhc3NhbnQ6IEVuUGFzc2FudE9iaiB8IHVuZGVmaW5lZCA9IHNxdWFyZVZhbC5lblBhc3NhbnQ7XG5cbiAgICByZXR1cm4gKFxuICAgICAgKHBpZWNlICYmIHBpZWNlLmNvbG9yICE9PSBwYXduLmNvbG9yKSB8fFxuICAgICAgKGVuUGFzc2FudCAmJiBlblBhc3NhbnQuY29sb3IgIT09IHBhd24uY29sb3IpXG4gICAgKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFNxdWFyZXNCZXR3ZWVuS2luZ0FuZENoZWNrKFxuICBraW5nUG9zOiBTcXVhcmUsXG4gIGNoZWNrUG9zOiBTcXVhcmUsXG4gIGFsbFNxdWFyZXM6IE1vdmVzXG4pIHtcbiAgLy8gaW5jbHVkZXMga2luZ1BvcyBhbmQgY2hlY2tQb3NcbiAgY29uc3Qgc3F1YXJlc0Fsb25nVmVjdG9yID0gZ2V0TW92ZXNBbG9uZ1ZlY3RvcihraW5nUG9zLCBjaGVja1BvcywgYWxsU3F1YXJlcyk7XG4gIGNvbnN0IHNxdWFyZXNCZXR3ZWVuS2luZ0FuZFBpZWNlID0gcmVtb3ZlTW92ZXNCZWhpbmRUd29TcXVhcmVzKFxuICAgIGtpbmdQb3MsXG4gICAgY2hlY2tQb3MsXG4gICAgc3F1YXJlc0Fsb25nVmVjdG9yXG4gICk7XG4gIHJldHVybiBzcXVhcmVzQmV0d2VlbktpbmdBbmRQaWVjZTtcbn1cblxuLyogZmlsdGVyIG1vdmVzICovXG5cbmZ1bmN0aW9uIHJlbW92ZU1vdmVzQmVoaW5kVHdvU3F1YXJlcyhcbiAgczE6IFNxdWFyZSxcbiAgczI6IFNxdWFyZSxcbiAgdmVjdG9yOiBNb3Zlc1xuKTogTW92ZXMge1xuICBjb25zdCBzb3J0ZWQgPSBzb3J0TW92ZXNDbG9zZXN0VG8oZ2V0QmVnaW5uaW5nT2ZWZWN0b3IodmVjdG9yKSkodmVjdG9yKTtcbiAgbGV0IGZ1cnRoZXN0U3F1YXJlO1xuICBsZXQgY2xvc2VzdFNxdWFyZTtcblxuICBpZiAoc29ydGVkLmluZGV4T2YoczEpID4gc29ydGVkLmluZGV4T2YoczIpKSB7XG4gICAgZnVydGhlc3RTcXVhcmUgPSBzMTtcbiAgICBjbG9zZXN0U3F1YXJlID0gczI7XG4gIH0gZWxzZSB7XG4gICAgZnVydGhlc3RTcXVhcmUgPSBzMjtcbiAgICBjbG9zZXN0U3F1YXJlID0gczE7XG4gIH1cbiAgY29uc3QgcmVtb3ZlZE9uZUVuZCA9IHJlbW92ZU1vdmVzQmVoaW5kU3F1YXJlKGZ1cnRoZXN0U3F1YXJlKShzb3J0ZWQpO1xuICBjb25zdCByZW1vdmVkQm90aEVuZHMgPSByZW1vdmVNb3Zlc0JlaGluZFNxdWFyZShjbG9zZXN0U3F1YXJlKShcbiAgICByZW1vdmVkT25lRW5kLnJldmVyc2UoKVxuICApO1xuXG4gIHJldHVybiByZW1vdmVkQm90aEVuZHM7XG59XG5cbmNvbnN0IHJlbW92ZU1vdmVzQmVoaW5kU3F1YXJlID1cbiAgKHNxdWFyZTogU3F1YXJlKSA9PlxuICAobW92ZXM6IE1vdmVzKTogTW92ZXMgPT4ge1xuICAgIGNvbnN0IGNvcHkgPSBbLi4ubW92ZXNdO1xuICAgIGNvbnN0IGluZGV4ID0gbW92ZXMuaW5kZXhPZihzcXVhcmUpO1xuXG4gICAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIFtdO1xuXG4gICAgY29weS5zcGxpY2UoaW5kZXggKyAxKTtcblxuICAgIHJldHVybiBjb3B5O1xuICB9O1xuXG5mdW5jdGlvbiByZW1vdmVPYnN0cnVjdGVkTW92ZXMoXG4gIHN0YXJ0aW5nU3F1YXJlOiBTcXVhcmUsXG4gIHBvc3NpYmxlTW92ZXM6IE1vdmVzLFxuICBvYnN0cnVjdGlvbnM6IE1vdmVzXG4pOiBNb3ZlcyB7XG4gIC8vIGEpIHNwbGl0IHBvc3NpYmxlIG1vdmVzIGludG8gdmVjdG9ycyAodXAsZG93bixsZWZ0LHJpZ2h0LCBhbmQvb3IgZGlhZ29uYWxzKVxuICAvLyBiKSBzZWUgd2hpY2ggb2JzdHJ1Y3Rpb25zIGJlbG9uZyB0byB3aGljaCB2ZWN0b3JcbiAgLy8gYykgZmluZCB0aGUgY2xvc2VzdCBvYnN0cnVjdGlvblxuICAvLyBkKSByZW1vdmUgYWxsIHRoZSBtb3ZlcyBiZWhpbmQgdGhhdCBvYnN0cnVjdGlvblxuXG4gIGNvbnN0IGZpbHRlcmVkTW92ZXM6IE1vdmVzW10gPSBbXTtcblxuICBjb25zdCBhbGxWZWN0b3JzID0gc3BsaXRJbnRvVmVjdG9ycyhwb3NzaWJsZU1vdmVzLCBzdGFydGluZ1NxdWFyZSk7XG4gIGNvbnN0IG9ic3RydWN0aW9uVmVjdG9ycyA9IHNwbGl0SW50b1ZlY3RvcnMob2JzdHJ1Y3Rpb25zLCBzdGFydGluZ1NxdWFyZSk7XG4gIGZvciAoY29uc3QgdmVjdG9yIGluIGFsbFZlY3RvcnMpIHtcbiAgICBpZiAoIW9ic3RydWN0aW9uVmVjdG9yc1t2ZWN0b3JdKSB7XG4gICAgICAvLyBsb29rIGZvciB2ZWN0b3Igb2JzdHJ1Y3Rpb24gaXMgb25cbiAgICAgIGZpbHRlcmVkTW92ZXMucHVzaChhbGxWZWN0b3JzW3ZlY3Rvcl0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3Qgc29ydGVkID0gc29ydE1vdmVzQ2xvc2VzdFRvKHN0YXJ0aW5nU3F1YXJlKShhbGxWZWN0b3JzW3ZlY3Rvcl0pO1xuICAgIGNvbnN0IGNsb3Nlc3RPYnN0cnVjdGlvbiA9IHNvcnRNb3Zlc0Nsb3Nlc3RUbyhzdGFydGluZ1NxdWFyZSkoXG4gICAgICBvYnN0cnVjdGlvblZlY3RvcnNbdmVjdG9yXVxuICAgIClbMF07XG5cbiAgICBmaWx0ZXJlZE1vdmVzLnB1c2gocmVtb3ZlTW92ZXNCZWhpbmRTcXVhcmUoY2xvc2VzdE9ic3RydWN0aW9uKShzb3J0ZWQpKTtcbiAgfVxuXG4gIHJldHVybiBmaWx0ZXJlZE1vdmVzLmZsYXQoKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlUHJvdGVjdGVkU3F1YXJlcyhcbiAga2luZzogUGllY2VPYmosXG4gIHBvc3NpYmxlTW92ZXM6IE1vdmVzLFxuICBib2FyZDogQm9hcmRcbik6IE1vdmVzIHtcbiAgLy8gYmMga2luZyBjYW50IG1vdmUgaWYgc3F1YXJlIGlzIHByb3RlY3RlZFxuICBjb25zdCBvcHBDb2xvciA9IGtpbmcuY29sb3IgPT09ICd3aGl0ZScgPyAnYmxhY2snIDogJ3doaXRlJztcblxuICBjb25zdCBhbGxFbmVteU1vdmVzID0gZ2V0QXR0YWNraW5nTW92ZXNGb3JDb2xvcihvcHBDb2xvciwgYm9hcmQpO1xuICByZXR1cm4gcG9zc2libGVNb3Zlcy5maWx0ZXIoKHMpID0+IHtcbiAgICByZXR1cm4gIWFsbEVuZW15TW92ZXMuaW5jbHVkZXMocyk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZW1vdmVNb3Zlc1dpdGhQaWVjZXMoXG4gIG1vdmVzOiBNb3ZlcyxcbiAgYm9hcmQ6IEJvYXJkLFxuICBjb2xvcj86IENvbG9yXG4pOiBNb3ZlcyB7XG4gIHJldHVybiBtb3Zlcy5maWx0ZXIoKHMpID0+IHtcbiAgICBjb25zdCBzcXVhcmVWYWwgPSBib2FyZC5nZXQocyk7XG4gICAgaWYgKCFzcXVhcmVWYWwpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChjb2xvcikgcmV0dXJuICFzcXVhcmVWYWwucGllY2UgfHwgc3F1YXJlVmFsLnBpZWNlLmNvbG9yICE9PSBjb2xvcjtcbiAgICBlbHNlIHJldHVybiAhc3F1YXJlVmFsLnBpZWNlO1xuICB9KTtcbn1cblxuLyogZ2FtZWJvYXJkIGNoZWNrcyAqL1xuXG5mdW5jdGlvbiBnZXREaXNjb3ZlcmVkQ2hlY2soXG4gIGtpbmdQb3M6IFNxdWFyZSxcbiAga2luZ0NvbG9yOiBDb2xvcixcbiAgdmFjYXRlZDogU3F1YXJlLFxuICBib2FyZDogQm9hcmRcbik6IFNxdWFyZSB7XG4gIC8vIG9wZW5TcXVhcmUgaXMgYSBzcXVhcmUganVzdCB2YWNhdGVkXG4gIGxldCBzcXVhcmVzQWxvbmdWZWN0b3IgPSBnZXRNb3Zlc0Fsb25nVmVjdG9yKFxuICAgIGtpbmdQb3MsXG4gICAgdmFjYXRlZCxcbiAgICBBcnJheS5mcm9tKGJvYXJkLmtleXMoKSlcbiAgKTtcbiAgc3F1YXJlc0Fsb25nVmVjdG9yID0gc3F1YXJlc0Fsb25nVmVjdG9yLmZpbHRlcihcbiAgICAocykgPT4gcyAhPT0ga2luZ1BvcyAmJiBzICE9PSB2YWNhdGVkXG4gICk7XG4gIGlmICghc3F1YXJlc0Fsb25nVmVjdG9yLmxlbmd0aCkgcmV0dXJuICcnO1xuXG4gIGZvciAoY29uc3Qgc3F1YXJlIG9mIHNxdWFyZXNBbG9uZ1ZlY3Rvcikge1xuICAgIGNvbnN0IHBpZWNlID0gYm9hcmQuZ2V0KHNxdWFyZSk/LnBpZWNlO1xuICAgIGlmICghcGllY2UgfHwgcGllY2UuY29sb3IgPT09IGtpbmdDb2xvcikgY29udGludWU7XG5cbiAgICBjb25zdCBsZWdhbE1vdmVzID0gZ2V0TGVnYWxNb3ZlcyhzcXVhcmUsIGJvYXJkKTtcbiAgICBpZiAobGVnYWxNb3Zlcy5pbmNsdWRlcyhraW5nUG9zKSkgcmV0dXJuIHNxdWFyZTtcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gY2FuQmxvY2tPckNhcHR1cmVDaGVjayhcbiAga2luZ1BvczogU3F1YXJlLFxuICBzcXVhcmVHaXZpbmdDaGVjazogU3F1YXJlLFxuICBib2FyZDogQm9hcmRcbik6IGJvb2xlYW4ge1xuICBjb25zdCBraW5nID0gYm9hcmQuZ2V0KGtpbmdQb3MpPy5waWVjZSBhcyBQaWVjZU9iajtcblxuICBjb25zdCBibG9ja09yQ2FwdHVyZVNxdWFyZXMgPSBnZXRTcXVhcmVzQmV0d2VlbktpbmdBbmRDaGVjayhcbiAgICBraW5nUG9zLFxuICAgIHNxdWFyZUdpdmluZ0NoZWNrLFxuICAgIEFycmF5LmZyb20oYm9hcmQua2V5cygpKVxuICApOyAvLyBhbHNvIGluY2x1ZGVzIGNoZWNrIHNxdWFyZVxuXG4gIGNvbnN0IG93blBpZWNlTW92ZXMgPSBnZXRBbGxNb3Zlc0ZvckNvbG9yKGtpbmcuY29sb3IsIGJvYXJkKTtcbiAgcmV0dXJuIG93blBpZWNlTW92ZXMuc29tZSgobW92ZSkgPT4gYmxvY2tPckNhcHR1cmVTcXVhcmVzLmluY2x1ZGVzKG1vdmUpKTtcbn1cblxuZXhwb3J0IHtcbiAgZ2V0QXR0YWNraW5nTW92ZXNGb3JDb2xvcixcbiAgZ2V0TGVnYWxNb3ZlcyxcbiAgZ2V0TGVnYWxNb3Zlc0luQ2hlY2ssXG4gIGdldERpc2NvdmVyZWRDaGVjayxcbiAgY2FuQmxvY2tPckNhcHR1cmVDaGVja1xufTtcbiIsImltcG9ydCB7XG4gIGdldExlZ2FsTW92ZXMsXG4gIGdldERpc2NvdmVyZWRDaGVjayxcbiAgY2FuQmxvY2tPckNhcHR1cmVDaGVjayxcbiAgZ2V0QXR0YWNraW5nTW92ZXNGb3JDb2xvcixcbiAgZ2V0TGVnYWxNb3Zlc0luQ2hlY2tcbn0gZnJvbSAnLi91dGlscy9tb3Zlcyc7XG5pbXBvcnQgeyB0b1hZLCBmcm9tWFkgfSBmcm9tICcuL3V0aWxzL2hlbHBlcnMnO1xuXG5pbXBvcnQgeyBDb2xvciwgU3F1YXJlLCBCb2FyZCwgUGllY2VUeXBlLCBNb3ZlcyB9IGZyb20gJy4vdHlwZXMvdHlwZXMnO1xuaW1wb3J0IHsgUGllY2VNYXAsIFBpZWNlT2JqIH0gZnJvbSAnLi90eXBlcy9pbnRlcmZhY2VzJztcblxuY29uc3QgR2FtZWJvYXJkID0gKGJvYXJkOiBCb2FyZCwgc3F1YXJlc0dpdmluZ0NoZWNrOiBNb3ZlcykgPT4ge1xuICBib2FyZCA9IGJvYXJkIHx8IGNyZWF0ZUJvYXJkKCk7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQm9hcmQoKSB7XG4gICAgY29uc3QgZmlsZXMgPSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJywgJ2cnLCAnaCddO1xuICAgIGNvbnN0IHJhbmtzID0gWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDhdO1xuXG4gICAgcmV0dXJuIGZpbGVzLnJlZHVjZSgoYWNjLCBmaWxlKSA9PiB7XG4gICAgICByYW5rcy5mb3JFYWNoKChyYW5rKSA9PiB7XG4gICAgICAgIGNvbnN0IHNxdWFyZSA9IGZpbGUuY29uY2F0KHJhbmsudG9TdHJpbmcoKSk7XG4gICAgICAgIGFjYy5zZXQoc3F1YXJlLCB7IHBpZWNlOiBudWxsIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIG5ldyBNYXAoKSk7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5DYXN0bGUoY29sb3I6IENvbG9yLCBzaWRlOiAna2luZ3NpZGUnIHwgJ3F1ZWVuc2lkZScpIHtcbiAgICBjb25zdCByYW5rID0gY29sb3IgPT09ICd3aGl0ZScgPyAxIDogODtcbiAgICBjb25zdCBjYXN0bGVTcXVhcmVzID1cbiAgICAgIHNpZGUgPT09ICdraW5nc2lkZScgPyBbYGYke3Jhbmt9YCwgYGcke3Jhbmt9YF0gOiBbYGMke3Jhbmt9YCwgYGQke3Jhbmt9YF07XG5cbiAgICBjb25zdCBvcHBDb2xvciA9IGNvbG9yID09PSAnd2hpdGUnID8gJ2JsYWNrJyA6ICd3aGl0ZSc7XG4gICAgY29uc3Qgb3BwTW92ZXMgPSBnZXRBdHRhY2tpbmdNb3Zlc0ZvckNvbG9yKG9wcENvbG9yLCBib2FyZCk7XG5cbiAgICBsZXQgY2FuQ2FzdGxlID0gdHJ1ZTtcblxuICAgIGNhc3RsZVNxdWFyZXMuZm9yRWFjaCgocykgPT4ge1xuICAgICAgLy8gY2hlY2sgaWYgY2FzdGxlIHNxdWFyZSBpcyBjbGVhcmVkXG4gICAgICBpZiAoYXQocykucGllY2UpIGNhbkNhc3RsZSA9IGZhbHNlO1xuXG4gICAgICAvLyBtYWtlIHN1cmUgY2FzdGxlIHNxdWFyZSBpc250IGF0dGFja2VkXG4gICAgICBpZiAob3BwTW92ZXMuaW5jbHVkZXMocykpIHtcbiAgICAgICAgY2FuQ2FzdGxlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY2FuQ2FzdGxlO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FzdGxlKGNvbG9yOiBDb2xvciwgc2lkZTogJ2tpbmdzaWRlJyB8ICdxdWVlbnNpZGUnKSB7XG4gICAgY29uc3QgcmFuayA9IGNvbG9yID09PSAnd2hpdGUnID8gMSA6IDg7XG4gICAgY29uc3QgY2FzdGxlU3F1YXJlcyA9XG4gICAgICBzaWRlID09PSAna2luZ3NpZGUnID8gW2BmJHtyYW5rfWAsIGBnJHtyYW5rfWBdIDogW2BkJHtyYW5rfWAsIGBjJHtyYW5rfWBdO1xuXG4gICAgY29uc3Qga2luZ1BvcyA9IGdldC5raW5nUG9zaXRpb24oY29sb3IpIGFzIFNxdWFyZTtcbiAgICBjb25zdCByb29rUG9zID0gZ2V0Um9va1BvcygpIGFzIFNxdWFyZTtcblxuICAgIGZyb20ocm9va1BvcykudG8oY2FzdGxlU3F1YXJlc1swXSk7XG4gICAgZnJvbShraW5nUG9zKS50byhjYXN0bGVTcXVhcmVzWzFdKTtcblxuICAgIGZ1bmN0aW9uIGdldFJvb2tQb3MoKSB7XG4gICAgICBjb25zdCBwaWVjZU1hcCA9IGdldC5waWVjZU1hcCgpO1xuICAgICAgY29uc3Qgcm9va1BvcyA9IHBpZWNlTWFwW2NvbG9yXS5yb29rLmZpbmQoKHNxdWFyZSkgPT4ge1xuICAgICAgICBjb25zdCBmaWxlID0gc3F1YXJlLnNwbGl0KCcnKVswXTtcbiAgICAgICAgcmV0dXJuIHNpZGUgPT09ICdraW5nc2lkZSdcbiAgICAgICAgICA/IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJywgJ2YnLCAnZycsICdoJ10uaW5kZXhPZihmaWxlKSA+IDNcbiAgICAgICAgICA6IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJywgJ2YnLCAnZycsICdoJ10uaW5kZXhPZihmaWxlKSA8IDM7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHJvb2tQb3M7XG4gICAgfVxuICAgIC8vIG5lZWQgdG8gZ2V0IGtpbmcgcG9zaXRpb25cbiAgICAvLyBuZWVkIHRvIGdldCBjYXN0bGUgc3F1YXJlc1xuICAgIC8vIG5lZWQgdG8gZmluZCByb29rXG4gIH1cblxuICBjb25zdCBlblBhc3NhbnQgPSAoKCkgPT4ge1xuICAgIGZ1bmN0aW9uIGdldFNxdWFyZShjdXJyZW50OiBTcXVhcmUsIGNvbG9yOiBDb2xvcik6IFNxdWFyZSB7XG4gICAgICBjb25zdCB7IHgsIHkgfSA9IHRvWFkoY3VycmVudCk7XG4gICAgICBjb25zdCBuZXdZID0gY29sb3IgPT09ICd3aGl0ZScgPyB5IC0gMSA6IHkgKyAxO1xuICAgICAgcmV0dXJuIGZyb21YWSh7IHgsIHk6IG5ld1kgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNoZWNrVG9nZ2xlOiAoZnJvbTogU3F1YXJlLCB0bzogU3F1YXJlKTogYm9vbGVhbiA9PiB7XG4gICAgICAgIGNvbnN0IHsgeTogeTEgfSA9IHRvWFkoZnJvbSk7XG4gICAgICAgIGNvbnN0IHsgeTogeTIgfSA9IHRvWFkodG8pO1xuXG4gICAgICAgIHJldHVybiBNYXRoLmFicyh5MSAtIHkyKSA9PT0gMjtcbiAgICAgIH0sXG4gICAgICB0b2dnbGU6IChjdXJyZW50OiBTcXVhcmUsIGNvbG9yOiBDb2xvcik6IHZvaWQgPT4ge1xuICAgICAgICBjb25zdCBlblBhc3NhbnRTcXVhcmUgPSBnZXRTcXVhcmUoY3VycmVudCwgY29sb3IpO1xuICAgICAgICBhdChlblBhc3NhbnRTcXVhcmUpLnNldEVuUGFzc2FudChjb2xvciwgY3VycmVudCk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlOiAoKTogdm9pZCA9PiB7XG4gICAgICAgIGZvciAoY29uc3Qgc3F1YXJlT2JqIG9mIGJvYXJkLnZhbHVlcygpKSB7XG4gICAgICAgICAgaWYgKHNxdWFyZU9iai5lblBhc3NhbnQpIHJldHVybiAoc3F1YXJlT2JqLmVuUGFzc2FudCA9IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9KSgpO1xuXG4gIGNvbnN0IGF0ID0gKHNxdWFyZTogU3F1YXJlKSA9PiAoe1xuICAgIHBsYWNlOiAocGllY2U6IFBpZWNlT2JqKSA9PiB7XG4gICAgICBpZiAoIWJvYXJkLmdldChzcXVhcmUpKSByZXR1cm4gJ3NxdWFyZSBkb2VzIG5vdCBleGlzdCc7XG5cbiAgICAgIGJvYXJkLnNldChzcXVhcmUsIHsgcGllY2UgfSk7XG4gICAgfSxcbiAgICByZW1vdmU6ICgpID0+IHtcbiAgICAgIGlmICghYm9hcmQuZ2V0KHNxdWFyZSkpIHJldHVybiAnc3F1YXJlIGRvZXMgbm90IGV4aXN0JztcblxuICAgICAgYm9hcmQuc2V0KHNxdWFyZSwgeyBwaWVjZTogbnVsbCB9KTtcbiAgICB9LFxuICAgIHByb21vdGU6IChwaWVjZVR5cGU6IFBpZWNlVHlwZSkgPT4ge1xuICAgICAgY29uc3Qgc3F1YXJlVmFsID0gYm9hcmQuZ2V0KHNxdWFyZSk7XG4gICAgICBjb25zdCBwaWVjZSA9IHNxdWFyZVZhbD8ucGllY2U7XG4gICAgICBpZiAoIXBpZWNlKSByZXR1cm47XG5cbiAgICAgIGJvYXJkLnNldChzcXVhcmUsIHsgLi4uc3F1YXJlVmFsLCBwaWVjZTogeyAuLi5waWVjZSwgdHlwZTogcGllY2VUeXBlIH0gfSk7XG4gICAgfSxcbiAgICBzZXRFblBhc3NhbnQ6IChjb2xvcjogQ29sb3IsIGN1cnJlbnQ6IFNxdWFyZSkgPT4ge1xuICAgICAgaWYgKCFib2FyZC5nZXQoc3F1YXJlKSkgcmV0dXJuICdzcXVhcmUgZG9lcyBub3QgZXhpc3QnO1xuXG4gICAgICBib2FyZC5zZXQoc3F1YXJlLCB7XG4gICAgICAgIHBpZWNlOiBudWxsLFxuICAgICAgICBlblBhc3NhbnQ6IHtcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIGNvbG9yOiBjb2xvclxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGdldCBwaWVjZSgpIHtcbiAgICAgIHJldHVybiBib2FyZC5nZXQoc3F1YXJlKT8ucGllY2U7XG4gICAgfSxcbiAgICBnZXRMZWdhbE1vdmVzOiAoKSA9PiB7XG4gICAgICBzcXVhcmVzR2l2aW5nQ2hlY2sgPSBzcXVhcmVzR2l2aW5nQ2hlY2sgfHwgW107XG4gICAgICBjb25zdCB7IHR5cGUsIGNvbG9yIH0gPSBhdChzcXVhcmUpLnBpZWNlIGFzIFBpZWNlT2JqO1xuXG4gICAgICBzd2l0Y2ggKHNxdWFyZXNHaXZpbmdDaGVjay5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgaWYgKHR5cGUgIT09ICdraW5nJykgcmV0dXJuIFtdO1xuICAgICAgICAgIHJldHVybiBnZXRMZWdhbE1vdmVzKHNxdWFyZSwgYm9hcmQpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMToge1xuICAgICAgICAgIHJldHVybiBnZXRMZWdhbE1vdmVzSW5DaGVjayhcbiAgICAgICAgICAgIG9yaWdpbixcbiAgICAgICAgICAgIGJvYXJkLFxuICAgICAgICAgICAgZ2V0LmtpbmdQb3NpdGlvbihjb2xvcikgYXMgU3F1YXJlLFxuICAgICAgICAgICAgc3F1YXJlc0dpdmluZ0NoZWNrWzBdXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDA6IHtcbiAgICAgICAgICByZXR1cm4gZ2V0TGVnYWxNb3ZlcyhzcXVhcmUsIGJvYXJkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgZnJvbSA9IChzMTogU3F1YXJlKSA9PiAoe1xuICAgIHRvOiAoczI6IFNxdWFyZSkgPT4ge1xuICAgICAgY29uc3QgcGllY2UgPSBhdChzMSkucGllY2U7XG4gICAgICBpZiAoIXBpZWNlKSByZXR1cm47XG5cbiAgICAgIC8vIG1vdmUgcGllY2VcbiAgICAgIGF0KHMxKS5yZW1vdmUoKTtcbiAgICAgIGF0KHMyKS5wbGFjZShwaWVjZSk7XG4gICAgfVxuICB9KTtcblxuICBjb25zdCBnZXQgPSB7XG4gICAga2luZ1Bvc2l0aW9uOiAoY29sb3I6IENvbG9yKTogU3F1YXJlIHwgdW5kZWZpbmVkID0+IHtcbiAgICAgIGZvciAoY29uc3QgW3NxdWFyZSwgdmFsdWVdIG9mIGJvYXJkLmVudHJpZXMoKSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdmFsdWUucGllY2UgJiZcbiAgICAgICAgICB2YWx1ZS5waWVjZS50eXBlID09PSAna2luZycgJiZcbiAgICAgICAgICB2YWx1ZS5waWVjZS5jb2xvciA9PT0gY29sb3JcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiBzcXVhcmU7XG4gICAgICB9XG4gICAgfSxcbiAgICBwaWVjZU1hcDogKCk6IHtcbiAgICAgIHdoaXRlOiBQaWVjZU1hcDtcbiAgICAgIGJsYWNrOiBQaWVjZU1hcDtcbiAgICB9ID0+IHtcbiAgICAgIGNvbnN0IHBpZWNlTWFwID0geyB3aGl0ZToge30gYXMgUGllY2VNYXAsIGJsYWNrOiB7fSBhcyBQaWVjZU1hcCB9O1xuICAgICAgZm9yIChjb25zdCBbc3F1YXJlLCB2YWx1ZV0gb2YgYm9hcmQuZW50cmllcygpKSB7XG4gICAgICAgIGNvbnN0IHsgcGllY2UgfSA9IHZhbHVlO1xuICAgICAgICBpZiAoIXBpZWNlKSBjb250aW51ZTtcblxuICAgICAgICBjb25zdCB7IHR5cGUsIGNvbG9yIH0gPSBwaWVjZTtcbiAgICAgICAgcGllY2VNYXBbY29sb3JdW3R5cGVdID0gcGllY2VNYXBbY29sb3JdW3R5cGVdXG4gICAgICAgICAgPyBbLi4ucGllY2VNYXBbY29sb3JdW3R5cGVdLCBzcXVhcmVdXG4gICAgICAgICAgOiBbc3F1YXJlXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwaWVjZU1hcDtcbiAgICB9LFxuICAgIHBpZWNlUG9zaXRpb25zOiAoY29sb3I6IENvbG9yKTogU3F1YXJlW10gPT4ge1xuICAgICAgY29uc3QgcGllY2VQb3NpdGlvbnMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgW3NxdWFyZSwgdmFsdWVdIG9mIGJvYXJkLmVudHJpZXMoKSkge1xuICAgICAgICBpZiAodmFsdWUucGllY2UgJiYgdmFsdWUucGllY2UuY29sb3IgPT09IGNvbG9yKVxuICAgICAgICAgIHBpZWNlUG9zaXRpb25zLnB1c2goc3F1YXJlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwaWVjZVBvc2l0aW9ucztcbiAgICB9LFxuICAgIHNxdWFyZXNHaXZpbmdDaGVja0FmdGVyTW92ZTogKGZyb206IFNxdWFyZSwgZW5kOiBTcXVhcmUpOiBzdHJpbmdbXSA9PiB7XG4gICAgICBjb25zdCBzcXVhcmVzR2l2aW5nQ2hlY2s6IHN0cmluZ1tdID0gW107XG5cbiAgICAgIGNvbnN0IHBpZWNlID0gYm9hcmQuZ2V0KGVuZCk/LnBpZWNlIGFzIFBpZWNlT2JqO1xuICAgICAgY29uc3Qgb3BwQ29sb3IgPSBwaWVjZS5jb2xvciA9PT0gJ3doaXRlJyA/ICdibGFjaycgOiAnd2hpdGUnO1xuICAgICAgY29uc3Qga2luZ1Bvc2l0aW9uID0gZ2V0LmtpbmdQb3NpdGlvbihvcHBDb2xvcikgYXMgU3F1YXJlO1xuXG4gICAgICBjb25zdCBwaWVjZUhpdHNLaW5nID0gZ2V0TGVnYWxNb3ZlcyhlbmQsIGJvYXJkKS5pbmNsdWRlcyhraW5nUG9zaXRpb24pO1xuICAgICAgaWYgKHBpZWNlSGl0c0tpbmcpIHNxdWFyZXNHaXZpbmdDaGVjay5wdXNoKGVuZCk7XG5cbiAgICAgIGNvbnN0IGRpc2NvdmVyZWRDaGVjayA9IGdldERpc2NvdmVyZWRDaGVjayhcbiAgICAgICAga2luZ1Bvc2l0aW9uLFxuICAgICAgICBvcHBDb2xvcixcbiAgICAgICAgZnJvbSxcbiAgICAgICAgYm9hcmRcbiAgICAgICk7XG4gICAgICBpZiAoZGlzY292ZXJlZENoZWNrKSBzcXVhcmVzR2l2aW5nQ2hlY2sucHVzaChkaXNjb3ZlcmVkQ2hlY2spO1xuXG4gICAgICByZXR1cm4gc3F1YXJlc0dpdmluZ0NoZWNrO1xuICAgIH0sXG4gICAgaXNDaGVja21hdGU6IChjb2xvcjogQ29sb3IsIHNxdWFyZXNHaXZpbmdDaGVjazogc3RyaW5nW10pOiBib29sZWFuID0+IHtcbiAgICAgIGNvbnN0IGtpbmdQb3MgPSBnZXQua2luZ1Bvc2l0aW9uKGNvbG9yKSBhcyBTcXVhcmU7XG4gICAgICBjb25zdCBsZWdhbE1vdmVzID0gYXQoa2luZ1BvcykuZ2V0TGVnYWxNb3ZlcygpO1xuICAgICAgLy8gY2hlY2sgaWYgY2hlY2sgY2FuIGJlIGJsb2NrZWRcbiAgICAgIGlmIChzcXVhcmVzR2l2aW5nQ2hlY2subGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmIChjYW5CbG9ja09yQ2FwdHVyZUNoZWNrKGtpbmdQb3MsIHNxdWFyZXNHaXZpbmdDaGVja1swXSwgYm9hcmQpKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghbGVnYWxNb3ZlcyB8fCAhbGVnYWxNb3Zlcy5sZW5ndGgpIHJldHVybiB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGNyZWF0ZUJvYXJkLFxuICAgIGNhc3RsZSxcbiAgICBjYW5DYXN0bGUsXG4gICAgZW5QYXNzYW50LFxuICAgIGF0LFxuICAgIGZyb20sXG4gICAgZ2V0LFxuICAgIGdldCBib2FyZCgpIHtcbiAgICAgIHJldHVybiBib2FyZDtcbiAgICB9XG4gIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBHYW1lYm9hcmQ7XG4iLCIvLyBzaG91bGQgb3V0cHV0IGhpc3Rvcnkgb2JqZWN0IHRoYXQgaG9sZHMgbW92ZSBoaXN0b3J5IGluIDJkIGFycmF5XG4vLyBmb3IgZWFjaCBtb3ZlIG5lZWRzIHRvIGF0dGFjaCBwaWVjZSBUeXBlIHRvIGJlZ2lubmluZyBvZiBtb3ZlIGlmIG5vdCBwYXduXG4vLyBzaG91bGQgZnVydGhlciBzcGVjaWZ5IHNxdWFyZSBvZiBwaWVjZSBpZiwgc2F5IGJvdGggcm9va3MsIGNhbiBtb3ZlIHRvIHNhbWUgc3F1YXJlXG5cbmltcG9ydCB7IEFsbFBpZWNlTWFwLCBQaWVjZU9iaiB9IGZyb20gJy4vdHlwZXMvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBCb2FyZCwgUGllY2VUeXBlLCBTcXVhcmUgfSBmcm9tICcuL3R5cGVzL3R5cGVzJztcbmltcG9ydCB7IGdldExlZ2FsTW92ZXMgfSBmcm9tICcuL3V0aWxzL21vdmVzJztcblxudHlwZSBIaXN0b3J5VHlwZSA9IFNxdWFyZVtdW107XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhpc3RvcnkoXG4gIHByZXZIaXN0b3J5OiBIaXN0b3J5VHlwZSxcbiAgYm9hcmQ6IEJvYXJkLFxuICBwaWVjZU1hcDogQWxsUGllY2VNYXBcbikge1xuICBjb25zdCBoaXN0b3J5OiBIaXN0b3J5VHlwZSA9IHByZXZIaXN0b3J5IHx8IFtdO1xuXG4gIGNvbnN0IGdldCA9IHtcbiAgICBwaWVjZVByZWZpeDogKGZyb206IFNxdWFyZSwgdG86IFNxdWFyZSkgPT4ge1xuICAgICAgY29uc3QgeyB0eXBlLCBjb2xvciB9ID0gYm9hcmQuZ2V0KHRvKT8ucGllY2UgYXMgUGllY2VPYmo7XG5cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdwYXduJzpcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIGNhc2UgJ2tuaWdodCc6XG4gICAgICAgIGNhc2UgJ3Jvb2snOiB7XG4gICAgICAgICAgbGV0IHByZWZpeCA9IHR5cGUgPT09ICdyb29rJyA/ICdSJyA6ICdOJztcbiAgICAgICAgICBpZiAocGllY2VNYXBbY29sb3JdW3R5cGVdLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgLy8gbG9vayBmb3IgcGllY2Ugb2Ygc2FtZSB0eXBlIHRoYXQgY291bGR2ZSBhbHNvIHdlbnQgdG8gdGhlIHNxdWFyZVxuICAgICAgICAgICAgcGllY2VNYXBbY29sb3JdW3R5cGVdLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHMgPT09IHRvKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgY29uc3QgYm9hcmRDb3B5ID0gbmV3IE1hcChib2FyZCk7XG4gICAgICAgICAgICAgIGJvYXJkQ29weS5zZXQodG8sIHsgcGllY2U6IG51bGwgfSk7XG5cbiAgICAgICAgICAgICAgaWYgKGdldExlZ2FsTW92ZXMocywgYm9hcmRDb3B5KS5pbmNsdWRlcyh0bykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbeDEsIHkxXSA9IGZyb20uc3BsaXQoJycpO1xuICAgICAgICAgICAgICAgIGNvbnN0IFt4Ml0gPSBzLnNwbGl0KCcnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzYW1lRmlsZSA9IHgxID09PSB4MjtcblxuICAgICAgICAgICAgICAgIHByZWZpeCA9IHNhbWVGaWxlID8gcHJlZml4ICsgeTEgOiBwcmVmaXggKyB4MTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHByZWZpeDtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY29uc3QgcHJlZml4ID0gdHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICByZXR1cm4gcHJlZml4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjYXN0bGVOb3RhdGlvbjogKHNpZGU6ICdraW5nc2lkZScgfCAncXVlZW5zaWRlJykgPT4ge1xuICAgICAgcmV0dXJuIHNpZGUgPT09ICdraW5nc2lkZScgPyAnTy1PJyA6ICdPLU8tTyc7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGFmZml4ID0ge1xuICAgIGNhcHR1cmU6IChtb3ZlOiBTcXVhcmUsIHByZWZpeDogc3RyaW5nKSA9PiB7XG4gICAgICByZXR1cm4gYCR7cHJlZml4fXgke21vdmV9YDtcbiAgICB9LFxuICAgIHByb21vdGU6IChtb3ZlOiBTcXVhcmUsIHBpZWNlVHlwZTogUGllY2VUeXBlKSA9PiB7XG4gICAgICBjb25zdCBzdWZmaXggPVxuICAgICAgICBwaWVjZVR5cGUgPT09ICdrbmlnaHQnID8gJ04nIDogcGllY2VUeXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICByZXR1cm4gYCR7bW92ZX09JHtzdWZmaXh9YDtcbiAgICB9LFxuICAgIGNoZWNrOiAobm90YXRpb246IHN0cmluZykgPT4ge1xuICAgICAgcmV0dXJuIGAke25vdGF0aW9ufStgO1xuICAgIH0sXG4gICAgY2hlY2ttYXRlOiAobm90YXRpb246IHN0cmluZykgPT4ge1xuICAgICAgcmV0dXJuIGAke25vdGF0aW9ufSNgO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGdldCxcbiAgICBhZmZpeCxcbiAgICBpbnNlcnRNb3ZlOiAobm90YXRpb246IHN0cmluZykgPT4ge1xuICAgICAgY29uc3QgbGFzdE1vdmVQYWlyID0gaGlzdG9yeVtoaXN0b3J5Lmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGxhc3RNb3ZlUGFpci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgbGFzdE1vdmVQYWlyLnB1c2gobm90YXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbmV3TW92ZVBhaXIgPSBbbm90YXRpb25dO1xuICAgICAgICBoaXN0b3J5LnB1c2gobmV3TW92ZVBhaXIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbiIsImltcG9ydCBHYW1lYm9hcmQgZnJvbSAnLi9HYW1lYm9hcmQnO1xuaW1wb3J0IEhpc3RvcnkgZnJvbSAnLi9IaXN0b3J5JztcblxuZXhwb3J0IHsgR2FtZWJvYXJkLCBIaXN0b3J5IH07XG4iXSwibmFtZXMiOlsidG9YWSIsInNxdWFyZSIsInNwbGl0IiwieCIsInkiLCJpbmRleE9mIiwidG9Mb3dlckNhc2UiLCJOdW1iZXIiLCJmcm9tWFkiLCJjb29yZCIsImNvbCIsImNvbmNhdCIsInRvU3RyaW5nIiwiY2FsY0Rpc3RhbmNlIiwic3F1YXJlT25lIiwic3F1YXJlVHdvIiwieDEiLCJ5MSIsIngyIiwieTIiLCJ4RGlmZiIsInlEaWZmIiwibW92ZXMiLCJQaWVjZSIsImNvbG9yIiwidHlwZSIsImhhc01vdmUiLCJmcm9tIiwidG8iLCJvbmVTcXVhcmVWZXJ0IiwieUJ5TiIsInhCeU4iLCJvbmVTcXVhcmVMYXRlcmFsIiwib25lU3F1YXJlRGlhZ29uYWxseSIsImRpYWdvbmFsIiwidmVydEFuZExhdGVyYWwiLCJvbmx5TW92ZXNJbkZyb250IiwicmVndWxhck1vdmUiLCJmaXJzdE1vdmUiLCJqdW1wVHdvIiwiZ2V0UGF3bkNhcHR1cmVzIiwib3JpZ2luIiwibmV3WSIsImNhcHR1cmVPbmUiLCJjYXB0dXJlVHdvIiwiTWF0aCIsImFicyIsIm51bSIsInNwbGl0SW50b1ZlY3RvcnMiLCJhcnJheU9mTW92ZXMiLCJzdGFydCIsInJlZHVjZSIsImFjYyIsImN1cnIiLCJ2ZWN0b3IiLCJjaGFyQXQiLCJzbGljZSIsInB1c2giLCJnZXRCZWdpbm5pbmdPZlZlY3RvciIsImxlbmd0aCIsImFjY0lzQmVnaW5uaW5nIiwiZ2V0TW92ZXNBbG9uZ1ZlY3RvciIsInMxIiwiczIiLCJhbGxTcXVhcmVzIiwibGllc1NhbWVWZXJ0T3JMYXQiLCJsaWVzU2FtZURpYWdvbmFsbHkiLCJsaWVzT25TYW1lTGluZSIsIm1hdGNoaW5nVmVjdG9yIiwic3F1YXJlc0Fsb25nVmVjdG9yIiwiZmlsdGVyIiwicyIsInNvcnRNb3Zlc0Nsb3Nlc3RUbyIsIl9fc3ByZWFkQXJyYXkiLCJzb3J0IiwiYSIsImIiLCJ4MURpZmYiLCJ5MURpZmYiLCJhRGlmZiIsIngyRGlmZiIsInkyRGlmZiIsImJEaWZmIiwiZ2V0UG9zc2libGVNb3ZlcyIsImJvYXJkIiwiQXJyYXkiLCJrZXlzIiwiZ2V0IiwicGllY2UiLCJnZXRMZWdhbE1vdmVzIiwicG9zc2libGVNb3ZlcyIsIm9ic3RydWN0aW9ucyIsIl9hIiwiX19yZWFkIiwibGVnYWxNb3ZlcyIsImNhcHR1cmVzQXZhaWxhYmxlIiwidW5vYnN0cnVjdGVkTW92ZXMiLCJyZW1vdmVNb3Zlc1dpdGhQaWVjZXMiLCJyZW1vdmVPYnN0cnVjdGVkTW92ZXMiLCJyZW1vdmVQcm90ZWN0ZWRTcXVhcmVzIiwiZ2V0TGVnYWxNb3Zlc0luQ2hlY2siLCJraW5nUG9zIiwic3F1YXJlR2l2aW5nQ2hlY2siLCJzcXVhcmVzVGhhdERlYWxXaXRoQ2hlY2siLCJnZXRTcXVhcmVzQmV0d2VlbktpbmdBbmRDaGVjayIsImluY2x1ZGVzIiwiZ2V0QXR0YWNraW5nTW92ZXMiLCJnZXRBbGxNb3Zlc0ZvckNvbG9yIiwiYWxsTW92ZXMiLCJlbnRyaWVzIiwiX2MiLCJmbGF0IiwiZ2V0QXR0YWNraW5nTW92ZXNGb3JDb2xvciIsInBhd25TcXVhcmUiLCJwYXduIiwiY2FwdHVyZU1vdmVzIiwic3F1YXJlVmFsIiwiZW5QYXNzYW50IiwiY2hlY2tQb3MiLCJzcXVhcmVzQmV0d2VlbktpbmdBbmRQaWVjZSIsInJlbW92ZU1vdmVzQmVoaW5kVHdvU3F1YXJlcyIsInNvcnRlZCIsImZ1cnRoZXN0U3F1YXJlIiwiY2xvc2VzdFNxdWFyZSIsInJlbW92ZWRPbmVFbmQiLCJyZW1vdmVNb3Zlc0JlaGluZFNxdWFyZSIsInJlbW92ZWRCb3RoRW5kcyIsInJldmVyc2UiLCJjb3B5IiwiaW5kZXgiLCJzcGxpY2UiLCJzdGFydGluZ1NxdWFyZSIsImZpbHRlcmVkTW92ZXMiLCJhbGxWZWN0b3JzIiwib2JzdHJ1Y3Rpb25WZWN0b3JzIiwiY2xvc2VzdE9ic3RydWN0aW9uIiwia2luZyIsIm9wcENvbG9yIiwiYWxsRW5lbXlNb3ZlcyIsImdldERpc2NvdmVyZWRDaGVjayIsImtpbmdDb2xvciIsInZhY2F0ZWQiLCJzcXVhcmVzQWxvbmdWZWN0b3JfMV8xIiwiX2IiLCJjYW5CbG9ja09yQ2FwdHVyZUNoZWNrIiwiYmxvY2tPckNhcHR1cmVTcXVhcmVzIiwib3duUGllY2VNb3ZlcyIsInNvbWUiLCJtb3ZlIiwiR2FtZWJvYXJkIiwic3F1YXJlc0dpdmluZ0NoZWNrIiwiY3JlYXRlQm9hcmQiLCJmaWxlcyIsInJhbmtzIiwiZmlsZSIsImZvckVhY2giLCJyYW5rIiwic2V0IiwiTWFwIiwiY2FuQ2FzdGxlIiwic2lkZSIsImNhc3RsZVNxdWFyZXMiLCJvcHBNb3ZlcyIsImF0IiwiY2FzdGxlIiwia2luZ1Bvc2l0aW9uIiwicm9va1BvcyIsImdldFJvb2tQb3MiLCJwaWVjZU1hcCIsInJvb2siLCJmaW5kIiwiZ2V0U3F1YXJlIiwiY3VycmVudCIsImNoZWNrVG9nZ2xlIiwidG9nZ2xlIiwiZW5QYXNzYW50U3F1YXJlIiwic2V0RW5QYXNzYW50IiwicmVtb3ZlIiwidmFsdWVzIiwic3F1YXJlT2JqIiwidW5kZWZpbmVkIiwicGxhY2UiLCJwcm9tb3RlIiwicGllY2VUeXBlIiwiX19hc3NpZ24iLCJ2YWx1ZSIsIndoaXRlIiwiYmxhY2siLCJwaWVjZVBvc2l0aW9ucyIsInNxdWFyZXNHaXZpbmdDaGVja0FmdGVyTW92ZSIsImVuZCIsInBpZWNlSGl0c0tpbmciLCJkaXNjb3ZlcmVkQ2hlY2siLCJpc0NoZWNrbWF0ZSIsIkhpc3RvcnkiLCJwcmV2SGlzdG9yeSIsImhpc3RvcnkiLCJwaWVjZVByZWZpeCIsInByZWZpeF8xIiwiYm9hcmRDb3B5Iiwic2FtZUZpbGUiLCJwcmVmaXgiLCJ0b1VwcGVyQ2FzZSIsImNhc3RsZU5vdGF0aW9uIiwiYWZmaXgiLCJjYXB0dXJlIiwic3VmZml4IiwiY2hlY2siLCJub3RhdGlvbiIsImNoZWNrbWF0ZSIsImluc2VydE1vdmUiLCJsYXN0TW92ZVBhaXIiLCJuZXdNb3ZlUGFpciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///371\n")}},__webpack_require__={d:(Q,F)=>{for(var B in F)__webpack_require__.o(F,B)&&!__webpack_require__.o(Q,B)&&Object.defineProperty(Q,B,{enumerable:!0,get:F[B]})},o:(Q,F)=>Object.prototype.hasOwnProperty.call(Q,F),r:Q=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})}},__webpack_exports__={};return __webpack_modules__[371](0,__webpack_exports__,__webpack_require__),__webpack_exports__})()}));