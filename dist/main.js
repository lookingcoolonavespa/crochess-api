!function(Q,F){"object"==typeof exports&&"object"==typeof module?module.exports=F():"function"==typeof define&&define.amd?define([],F):"object"==typeof exports?exports.croChess=F():Q.croChess=F()}(this,(function(){return(()=>{"use strict";var __webpack_modules__={708:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"Castle\": () => (/* reexport */ Castle),\n  \"Gameboard\": () => (/* reexport */ src_Gameboard),\n  \"History\": () => (/* reexport */ History),\n  \"files\": () => (/* reexport */ files),\n  \"ranks\": () => (/* reexport */ ranks),\n  \"startingPositions\": () => (/* reexport */ startingPositions_namespaceObject)\n});\n\n// NAMESPACE OBJECT: ./src/startingPositions.ts\nvar startingPositions_namespaceObject = {};\n__webpack_require__.r(startingPositions_namespaceObject);\n__webpack_require__.d(startingPositions_namespaceObject, {\n  \"standard\": () => (standard)\n});\n\n;// CONCATENATED MODULE: ./src/utils/helpers.ts\nfunction toXY(square) {\n  const [x, y] = square.split('');\n  return {\n    x: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'].indexOf(x.toLowerCase()),\n    y: Number(y)\n  };\n}\n\nfunction fromXY(coord) {\n  const {\n    x,\n    y\n  } = coord;\n  const col = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'][x];\n  if (!col) return '';\n  return col.concat(y.toString());\n}\n\nconst calcDistance = squareOne => squareTwo => {\n  const {\n    x: x1,\n    y: y1\n  } = toXY(squareOne);\n  const {\n    x: x2,\n    y: y2\n  } = toXY(squareTwo);\n  const xDiff = x1 - x2;\n  const yDiff = y1 - y2;\n  return {\n    xDiff,\n    yDiff\n  };\n};\n\nfunction getPieceFromAbbr(abbr) {\n  switch (abbr) {\n    case 'K':\n      return 'king';\n\n    case 'Q':\n      return 'queen';\n\n    case 'N':\n      return 'knight';\n\n    case 'B':\n      return 'bishop';\n\n    case 'R':\n      return 'rook';\n  }\n}\n\nfunction parseNotation(notation) {\n  const move = {};\n  const replaced = notation.replace(/[+x#]/, '');\n\n  if (+replaced[0] === 0) {\n    // this is castle\n    move.castle = replaced.length === 3 ? 'kingside' : 'queenside';\n    return move;\n  }\n\n  if (replaced[0].toUpperCase() === replaced[0]) {\n    // this is piece move\n    move.pieceType = getPieceFromAbbr(replaced[0]);\n    move.to = replaced.slice(-2);\n\n    if (replaced.length === 4) {\n      move.from = replaced[1];\n    }\n\n    return move;\n  } else {\n    // is a pawn move\n    move.pieceType = 'pawn';\n\n    if (replaced.includes('=')) {\n      // indicates promotion\n      move.promote = getPieceFromAbbr(replaced.slice(-1));\n    }\n\n    const promoteNoteIndex = replaced.indexOf('=');\n    const noPromoteNotation = replaced.slice(0, promoteNoteIndex === -1 ? replaced.length : promoteNoteIndex);\n\n    if (noPromoteNotation.length === 3) {\n      move.from = replaced[0];\n    }\n\n    move.to = noPromoteNotation.slice(-2);\n  }\n\n  return move;\n}\n\n\n;// CONCATENATED MODULE: ./src/Piece.ts\n\n\n\nconst Piece = (color, type) => {\n  function hasMove(from, to) {\n    switch (type) {\n      case 'king':\n        {\n          const oneSquareVert = utils_moves.yByN(1)(from)(to) && utils_moves.xByN(0)(from)(to);\n          const oneSquareLateral = utils_moves.xByN(1)(from)(to) && utils_moves.yByN(0)(from)(to);\n          const oneSquareDiagonally = utils_moves.yByN(1)(from)(to) && utils_moves.xByN(1)(from)(to);\n          return from !== to && (oneSquareDiagonally || oneSquareVert || oneSquareLateral);\n        }\n\n      case 'queen':\n        {\n          return from !== to && (utils_moves.diagonal(from)(to) || utils_moves.vertAndLateral(from)(to));\n        }\n\n      case 'bishop':\n        {\n          return from !== to && utils_moves.diagonal(from)(to);\n        }\n\n      case 'knight':\n        {\n          return from !== to && (utils_moves.xByN(1)(from)(to) && utils_moves.yByN(2)(from)(to) || utils_moves.xByN(2)(from)(to) && utils_moves.yByN(1)(from)(to));\n        }\n\n      case 'rook':\n        {\n          return from !== to && utils_moves.vertAndLateral(to)(from);\n        }\n\n      case 'pawn':\n        {\n          const {\n            x: x1,\n            y: y1\n          } = toXY(from);\n          const {\n            x: x2,\n            y: y2\n          } = toXY(to);\n          const onlyMovesInFront = color === 'white' ? y1 < y2 : y1 > y2;\n          const regularMove = utils_moves.yByN(1)(from)(to) && x1 === x2;\n          const firstMove = color === 'white' ? y1 === 2 : y1 === 7;\n          const jumpTwo = utils_moves.yByN(2)(from)(to) && x1 === x2;\n          return from !== to && onlyMovesInFront && (regularMove || firstMove && jumpTwo);\n        }\n    }\n  }\n\n  function getPawnCaptures(origin) {\n    if (type !== 'pawn') return;\n    const {\n      x,\n      y\n    } = toXY(origin);\n    const newY = color === 'white' ? y + 1 : y - 1;\n    const captureOne = {\n      x: x + 1,\n      y: newY\n    };\n    const captureTwo = {\n      x: x - 1,\n      y: newY\n    };\n    return [fromXY(captureOne), fromXY(captureTwo)];\n  }\n\n  return {\n    hasMove,\n    getPawnCaptures,\n\n    get type() {\n      return type;\n    },\n\n    get color() {\n      return color;\n    }\n\n  };\n};\n\n/* harmony default export */ const src_Piece = (Piece);\n;// CONCATENATED MODULE: ./src/utils/moves.ts\n\n\nconst moves = {\n  vertAndLateral: from => to => {\n    const [x1, y1] = from.split('');\n    const [x2, y2] = to.split('');\n    return x1 === x2 || y1 === y2;\n  },\n  diagonal: from => to => {\n    const {\n      x: x1,\n      y: y1\n    } = toXY(from);\n    const {\n      x: x2,\n      y: y2\n    } = toXY(to);\n    return Math.abs(x2 - x1) === Math.abs(y2 - y1);\n  },\n  xByN: num => from => to => {\n    const {\n      x: x1\n    } = toXY(from);\n    const {\n      x: x2\n    } = toXY(to);\n    return Math.abs(x1 - x2) === num;\n  },\n  yByN: num => from => to => {\n    const {\n      y: y1\n    } = toXY(from);\n    const {\n      y: y2\n    } = toXY(to);\n    return Math.abs(y1 - y2) === num;\n  }\n};\n/* harmony default export */ const utils_moves = (moves);\n/* dealing with move vectors */\n\nfunction splitIntoVectors(arrayOfMoves, start) {\n  return arrayOfMoves.reduce((acc, curr) => {\n    const {\n      xDiff,\n      yDiff\n    } = calcDistance(start)(curr);\n    let vector = '';\n    if (yDiff !== 0) vector = yDiff < 0 ? 'up' : 'down';\n    if (xDiff !== 0) vector += xDiff < 0 ? 'Right' : 'Left'; // normalize vector name\n\n    vector = vector.charAt(0).toLowerCase() + vector.slice(1);\n    acc[vector] = acc[vector] || [];\n    acc[vector].push(curr);\n    return acc;\n  }, {});\n}\n\nfunction getBeginningOfVector(vector) {\n  if (vector.length === 0) return '';\n  return vector.reduce((acc, curr) => {\n    const {\n      x: x1,\n      y: y1\n    } = toXY(acc);\n    const {\n      x: x2,\n      y: y2\n    } = toXY(curr);\n    const accIsBeginning = x1 === x2 ? y1 < y2 : x1 < x2;\n    return accIsBeginning ? acc : curr;\n  });\n}\n\nconst getMovesAlongVector = (s1, s2, allSquares) => {\n  const liesSameVertOrLat = moves.vertAndLateral(s1)(s2);\n  const liesSameDiagonally = moves.diagonal(s1)(s2);\n  const liesOnSameLine = liesSameVertOrLat || liesSameDiagonally;\n  if (!liesOnSameLine) return [];\n  const matchingVector = liesSameDiagonally ? 'diagonal' : 'vertAndLateral';\n  const squaresAlongVector = allSquares.filter(s => moves[matchingVector](s1)(s) && moves[matchingVector](s2)(s));\n  return squaresAlongVector;\n};\n/* sort moves */\n\n\nconst sortMovesClosestTo = square => moves => {\n  return [...moves].sort((a, b) => {\n    const {\n      xDiff: x1Diff,\n      yDiff: y1Diff\n    } = calcDistance(square)(a);\n    const aDiff = Math.abs(x1Diff) + Math.abs(y1Diff);\n    const {\n      xDiff: x2Diff,\n      yDiff: y2Diff\n    } = calcDistance(square)(b);\n    const bDiff = Math.abs(x2Diff) + Math.abs(y2Diff);\n    return aDiff - bDiff;\n  });\n};\n/* get moves */\n\n\nfunction getPossibleMoves(origin, board) {\n  // get all moves that can happen if no other pieces were on the board\n  const allSquares = Array.from(board.keys());\n  const square = board.get(origin);\n  const {\n    type,\n    color\n  } = square.piece;\n  const piece = src_Piece(color, type);\n  return allSquares.filter(s => piece.hasMove(origin, s));\n}\n\nfunction getLegalMoves(origin, board) {\n  // get moves regardless of whether or not there is check\n  const square = board.get(origin);\n  const piece = square.piece;\n  const possibleMoves = getPossibleMoves(origin, board);\n  const obstructions = possibleMoves.filter(s => {\n    var _a;\n\n    return (_a = board.get(s)) === null || _a === void 0 ? void 0 : _a.piece;\n  });\n\n  if (!obstructions.length) {\n    if (piece.type === 'pawn') return [...getPawnCaptures(origin, board), ...possibleMoves];\n    return possibleMoves;\n  }\n\n  let legalMoves = [];\n\n  switch (piece.type) {\n    case 'knight':\n      {\n        legalMoves = possibleMoves;\n        break;\n      }\n\n    case 'pawn':\n      {\n        const capturesAvailable = getPawnCaptures(origin, board);\n        const unobstructedMoves = removeMovesWithPieces(removeObstructedMoves(origin, possibleMoves, obstructions), board);\n        legalMoves = [...capturesAvailable, ...unobstructedMoves];\n        break;\n      }\n\n    case 'king':\n      {\n        legalMoves = removeProtectedSquares(origin, possibleMoves, board);\n        break;\n      }\n\n    default:\n      {\n        legalMoves = removeObstructedMoves(origin, possibleMoves, obstructions);\n      }\n  }\n\n  return removeMovesWithPieces(legalMoves, board, piece.color);\n}\n\nfunction getLegalMovesInCheck(origin, board, kingPos, squareGivingCheck) {\n  const squaresThatDealWithCheck = getSquaresBetweenKingAndCheck(kingPos, squareGivingCheck, Array.from(board.keys()));\n  const moves = getLegalMoves(origin, board);\n  return moves.filter(s => squaresThatDealWithCheck.includes(s));\n}\n\nfunction getAttackingMoves(origin, board) {\n  const square = board.get(origin);\n  const {\n    type,\n    color\n  } = square.piece;\n\n  switch (type) {\n    case 'pawn':\n      {\n        const piece = src_Piece(color, 'pawn');\n        return piece.getPawnCaptures(origin);\n      }\n\n    case 'king':\n      {\n        // need to do this because getLegalMoves will recursively call removeProtectedSquares otherwise\n        const attackingMoves = removeMovesWithPieces(getPossibleMoves(origin, board), board, color);\n        return attackingMoves;\n      }\n\n    default:\n      return getLegalMoves(origin, board);\n  }\n}\n\nfunction getAllMovesForColor(color, board, skipKing) {\n  const allMoves = [];\n\n  for (const [square, {\n    piece\n  }] of board.entries()) {\n    if (!piece) continue;\n    if (piece.color !== color) continue;\n    if (skipKing && piece.type === 'king') continue;\n    allMoves.push(getLegalMoves(square, board));\n  }\n\n  return allMoves.flat();\n}\n\nfunction getAttackingMovesForColor(color, board) {\n  const allMoves = [];\n\n  for (const [square, {\n    piece\n  }] of board.entries()) {\n    if (!piece) continue;\n    if (piece.color !== color) continue;\n    allMoves.push(getAttackingMoves(square, board));\n  }\n\n  return allMoves.flat();\n}\n\nfunction getPawnCaptures(pawnSquare, board) {\n  var _a;\n\n  const {\n    color\n  } = (_a = board.get(pawnSquare)) === null || _a === void 0 ? void 0 : _a.piece;\n  const pawn = src_Piece(color, 'pawn');\n  const captureMoves = pawn.getPawnCaptures(pawnSquare);\n  if (!captureMoves) return [];\n  return captureMoves.filter(s => {\n    const squareVal = board.get(s);\n    if (!squareVal) return false;\n    const piece = squareVal.piece;\n    const enPassant = squareVal.enPassant;\n    return piece && piece.color !== pawn.color || enPassant && enPassant.color !== pawn.color;\n  });\n}\n\nfunction getSquaresBetweenKingAndCheck(kingPos, checkPos, allSquares) {\n  // includes kingPos and checkPos\n  const squaresAlongVector = getMovesAlongVector(kingPos, checkPos, allSquares);\n  const squaresBetweenKingAndPiece = removeMovesBehindTwoSquares(kingPos, checkPos, squaresAlongVector);\n  return squaresBetweenKingAndPiece;\n}\n/* filter moves */\n\n\nfunction removeMovesBehindTwoSquares(s1, s2, vector) {\n  const sorted = sortMovesClosestTo(getBeginningOfVector(vector))(vector);\n  let furthestSquare;\n  let closestSquare;\n\n  if (sorted.indexOf(s1) > sorted.indexOf(s2)) {\n    furthestSquare = s1;\n    closestSquare = s2;\n  } else {\n    furthestSquare = s2;\n    closestSquare = s1;\n  }\n\n  const removedOneEnd = removeMovesBehindSquare(furthestSquare)(sorted);\n  const removedBothEnds = removeMovesBehindSquare(closestSquare)(removedOneEnd.reverse());\n  return removedBothEnds;\n}\n\nconst removeMovesBehindSquare = square => moves => {\n  const copy = [...moves];\n  const index = moves.indexOf(square);\n  if (index === -1) return [];\n  copy.splice(index + 1);\n  return copy;\n};\n\nfunction removeObstructedMoves(startingSquare, possibleMoves, obstructions) {\n  // a) split possible moves into vectors (up,down,left,right, and/or diagonals)\n  // b) see which obstructions belong to which vector\n  // c) find the closest obstruction\n  // d) remove all the moves behind that obstruction\n  const filteredMoves = [];\n  const allVectors = splitIntoVectors(possibleMoves, startingSquare);\n  const obstructionVectors = splitIntoVectors(obstructions, startingSquare);\n\n  for (const vector in allVectors) {\n    if (!obstructionVectors[vector]) {\n      // look for vector obstruction is on\n      filteredMoves.push(allVectors[vector]);\n      continue;\n    }\n\n    const sorted = sortMovesClosestTo(startingSquare)(allVectors[vector]);\n    const closestObstruction = sortMovesClosestTo(startingSquare)(obstructionVectors[vector])[0];\n    filteredMoves.push(removeMovesBehindSquare(closestObstruction)(sorted));\n  }\n\n  return filteredMoves.flat();\n}\n\nfunction removeProtectedSquares(kingPos, possibleMoves, board) {\n  var _a;\n\n  const king = (_a = board.get(kingPos)) === null || _a === void 0 ? void 0 : _a.piece;\n  const oppColor = king.color === 'white' ? 'black' : 'white'; // bc king cant move if square is protected\n  // set king piece on each square in possible moves to find which squares are protected\n\n  const boardCopy = new Map(board);\n  possibleMoves.forEach(s => boardCopy.set(s, {\n    piece: king\n  }));\n  const allEnemyMoves = getAttackingMovesForColor(oppColor, boardCopy);\n  return possibleMoves.filter(s => {\n    return !allEnemyMoves.includes(s);\n  });\n}\n\nfunction removeMovesWithPieces(moves, board, color) {\n  return moves.filter(s => {\n    const squareVal = board.get(s);\n    if (!squareVal) return false;\n    if (color) return !squareVal.piece || squareVal.piece.color !== color;else return !squareVal.piece;\n  });\n}\n/* gameboard checks */\n\n\nfunction getDiscoveredCheck(kingPos, kingColor, vacated, board) {\n  var _a; // openSquare is a square just vacated\n\n\n  let squaresAlongVector = getMovesAlongVector(kingPos, vacated, Array.from(board.keys()));\n  squaresAlongVector = squaresAlongVector.filter(s => s !== kingPos && s !== vacated);\n  if (!squaresAlongVector.length) return '';\n\n  for (const square of squaresAlongVector) {\n    const piece = (_a = board.get(square)) === null || _a === void 0 ? void 0 : _a.piece;\n    if (!piece || piece.color === kingColor) continue;\n    const legalMoves = getLegalMoves(square, board);\n    if (legalMoves.includes(kingPos)) return square;\n  }\n\n  return '';\n}\n\nfunction canBlockOrCaptureCheck(kingPos, squareGivingCheck, board) {\n  var _a;\n\n  const king = (_a = board.get(kingPos)) === null || _a === void 0 ? void 0 : _a.piece;\n  const blockOrCaptureSquares = getSquaresBetweenKingAndCheck(kingPos, squareGivingCheck, Array.from(board.keys())); // also includes check square\n\n  const ownPieceMoves = getAllMovesForColor(king.color, board, true);\n  return ownPieceMoves.some(move => blockOrCaptureSquares.includes(move));\n}\n\nfunction getPiecesWithMove(board, move, pieceType, color) {\n  const pieceSquares = [];\n\n  for (const [square, {\n    piece\n  }] of board.entries()) {\n    if (!piece) continue;\n    if (piece.color !== color) continue;\n    if (piece.type !== pieceType) continue;\n  }\n}\n\n\n;// CONCATENATED MODULE: ./src/ranksAndFiles.ts\nconst files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];\nconst ranks = [1, 2, 3, 4, 5, 6, 7, 8];\n\n;// CONCATENATED MODULE: ./src/Castle.ts\nfunction Castle(whiteKingside, whiteQueenside, blackKingside, blackQueenside) {\n  return {\n    white: {\n      kingside: whiteKingside,\n      queenside: whiteQueenside\n    },\n    black: {\n      kingside: blackKingside,\n      queenside: blackQueenside\n    }\n  };\n}\n;// CONCATENATED MODULE: ./src/Gameboard.ts\n\n\n\n\n\n\nfunction createBoard() {\n  return files.reduce((acc, file) => {\n    ranks.forEach(rank => {\n      const square = file.concat(rank.toString());\n      acc.set(square, {\n        piece: null\n      });\n    });\n    return acc;\n  }, new Map());\n}\n\nconst Gameboard = (board = createBoard(), squaresGivingCheck, CastleRights) => {\n  function placePieces(pieceMap, boardMap = board) {\n    let color;\n\n    for (color in pieceMap) {\n      const map = pieceMap[color];\n      let pieceType;\n\n      for (pieceType in map) {\n        const squares = map[pieceType];\n        squares.forEach(s => at(s, boardMap).place({\n          type: pieceType,\n          color: color\n        }));\n      }\n    }\n  }\n\n  function makeMove(s1, s2, promote) {\n    const piece = at(s1).piece; // validate move\n\n    if (!piece) return;\n    if (!validate.move(s1, s2)) return;\n    if (promote && !validate.promotion(s1, s2)) return;\n\n    switch (piece.type) {\n      case 'pawn':\n        {\n          if (promote) {\n            at(s1).promote(promote);\n          }\n\n          if (enPassant.isCapture(s1, s2)) {\n            enPassant.capture(s2);\n          }\n\n          enPassant.remove();\n\n          if (enPassant.checkToggle(s1, s2)) {\n            enPassant.toggle(piece.color, s2);\n          }\n\n          from(s1).to(s2);\n          break;\n        }\n\n      case 'king':\n        {\n          // check if move is castle\n          let castleSide = '';\n          const castleSquares = get.castleSquares(piece.color);\n\n          for (const [side, squares] of Object.entries(castleSquares)) {\n            if (squares[1] === s2) castleSide = side;\n          }\n\n          if (castleSide) castle(piece.color, castleSide);else from(s1).to(s2);\n          enPassant.remove();\n          break;\n        }\n\n      default:\n        from(s1).to(s2);\n        enPassant.remove();\n    }\n\n    return board;\n  }\n\n  function castle(color, side, boardMap = board) {\n    const castleSquares = get.castleSquares(color)[side];\n    const kingPos = get.kingPosition(color, boardMap);\n    const rookPos = getRookPos();\n    from(rookPos, boardMap).to(castleSquares[0]);\n    from(kingPos, boardMap).to(castleSquares[1]);\n\n    function getRookPos() {\n      const pieceMap = get.pieceMap(boardMap);\n      const rookPos = pieceMap[color].rook.find(square => {\n        const file = square.split('')[0];\n        return side === 'kingside' ? files.indexOf(file) > 3 : files.indexOf(file) < 3;\n      });\n      return rookPos;\n    } // need to get king position\n    // need to get castle squares\n    // need to find rook\n\n  }\n\n  const enPassant = (() => {\n    function getSquare(current, color) {\n      const {\n        x,\n        y\n      } = toXY(current);\n      const newY = color === 'white' ? y - 1 : y + 1;\n      return fromXY({\n        x,\n        y: newY\n      });\n    }\n\n    return {\n      checkToggle: (from, to) => {\n        const {\n          y: y1\n        } = toXY(from);\n        const {\n          y: y2\n        } = toXY(to);\n        return Math.abs(y1 - y2) === 2;\n      },\n      toggle: (color, current, boardMap = board) => {\n        const enPassantSquare = getSquare(current, color);\n        at(enPassantSquare, boardMap).setEnPassant(color, current);\n      },\n      remove: (boardMap = board) => {\n        for (const squareObj of boardMap.values()) {\n          if (squareObj.enPassant) return squareObj.enPassant = undefined;\n        }\n      },\n      isCapture: (from, to, boardMap = board) => {\n        var _a;\n\n        const piece = at(from, boardMap).piece;\n        const enPassant = (_a = boardMap.get(to)) === null || _a === void 0 ? void 0 : _a.enPassant;\n        if (!piece || piece.type !== 'pawn') return false;\n        if (!enPassant) return false;\n        if (enPassant.color === piece.color) return false;\n        return true;\n      },\n      capture: (to, boardMap = board) => {\n        var _a;\n\n        const enPassant = (_a = boardMap.get(to)) === null || _a === void 0 ? void 0 : _a.enPassant;\n        at(enPassant.current, boardMap).remove();\n      }\n    };\n  })();\n\n  const at = (square, boardMap = board) => ({\n    place: piece => {\n      if (!boardMap.get(square)) return;\n      boardMap.set(square, {\n        piece\n      });\n    },\n    remove: () => {\n      if (!boardMap.get(square)) return;\n      boardMap.set(square, {\n        piece: null\n      });\n    },\n    promote: pieceType => {\n      const squareVal = boardMap.get(square);\n      const piece = squareVal === null || squareVal === void 0 ? void 0 : squareVal.piece;\n      if (!piece) return;\n      boardMap.set(square, Object.assign(Object.assign({}, squareVal), {\n        piece: Object.assign(Object.assign({}, piece), {\n          type: pieceType\n        })\n      }));\n    },\n    setEnPassant: (color, current) => {\n      if (!boardMap.get(square)) return;\n      boardMap.set(square, {\n        piece: null,\n        enPassant: {\n          current\n          /* square pawn is on */\n          ,\n          color\n        }\n      });\n    },\n\n    get piece() {\n      var _a;\n\n      return (_a = boardMap.get(square)) === null || _a === void 0 ? void 0 : _a.piece;\n    },\n\n    getLegalMoves: (checks = squaresGivingCheck || []) => {\n      const {\n        type,\n        color\n      } = at(square, boardMap).piece;\n\n      switch (checks.length) {\n        case 2:\n          {\n            if (type !== 'king') return [];\n            return getLegalMoves(square, boardMap);\n          }\n\n        case 1:\n          {\n            return getLegalMovesInCheck(origin, boardMap, get.kingPosition(color), checks[0]);\n          }\n\n        default:\n          {\n            if (type === 'king') {\n              let legalMoves = getLegalMoves(square, boardMap);\n              if (get.canCastle(color, 'kingside')) legalMoves = [...legalMoves, ...get.castleSquares(color).kingside];\n              if (get.canCastle(color, 'queenside')) legalMoves = [...legalMoves, ...get.castleSquares(color).queenside];\n              return legalMoves;\n            } else return getLegalMoves(square, boardMap);\n          }\n      }\n    }\n  });\n\n  const from = (s1, boardMap = board) => ({\n    to: s2 => {\n      const piece = at(s1, boardMap).piece;\n      if (!piece) return; // move piece\n\n      at(s1, boardMap).remove();\n      at(s2, boardMap).place(piece);\n    }\n  });\n\n  const get = {\n    kingPosition: (color, boardMap = board) => {\n      for (const [square, value] of boardMap.entries()) {\n        if (value.piece && value.piece.type === 'king' && value.piece.color === color) return square;\n      }\n    },\n    pieceMap: (boardMap = board) => {\n      const pieceMap = {\n        white: {},\n        black: {}\n      };\n\n      for (const [square, value] of boardMap.entries()) {\n        const {\n          piece\n        } = value;\n        if (!piece) continue;\n        const {\n          type,\n          color\n        } = piece;\n        pieceMap[color][type] = pieceMap[color][type] ? [...pieceMap[color][type], square] : [square];\n      }\n\n      return pieceMap;\n    },\n    squaresGivingCheckAfterMove: (from, end) => {\n      var _a;\n\n      const squaresGivingCheck = [];\n      const piece = (_a = board.get(end)) === null || _a === void 0 ? void 0 : _a.piece;\n      const oppColor = piece.color === 'white' ? 'black' : 'white';\n      const kingPosition = get.kingPosition(oppColor);\n      const pieceHitsKing = getLegalMoves(end, board).includes(kingPosition);\n      if (pieceHitsKing) squaresGivingCheck.push(end);\n      const discoveredCheck = getDiscoveredCheck(kingPosition, oppColor, from, board);\n      if (discoveredCheck) squaresGivingCheck.push(discoveredCheck);\n      return squaresGivingCheck;\n    },\n    isCheckmate: (color, squaresGivingCheck, boardMap = board) => {\n      const kingPos = get.kingPosition(color, boardMap);\n      const legalMoves = at(kingPos, boardMap).getLegalMoves(); // check if check can be blocked\n\n      if (squaresGivingCheck.length === 1) {\n        if (canBlockOrCaptureCheck(kingPos, squaresGivingCheck[0], boardMap)) return false;\n      }\n\n      if (legalMoves.length) return false;\n      return true;\n    },\n\n    castleSquares(color) {\n      const rank = color === 'white' ? 1 : 8;\n      return {\n        kingside: [`f${rank}`, `g${rank}`],\n        queenside: [`d${rank}`, `c${rank}`]\n      };\n    },\n\n    castleRightsAfterMove: (square, boardMap = board) => {\n      const piece = at(square, boardMap).piece;\n      const castleRights = CastleRights || Castle(true, true, true, true);\n\n      if (castleRights[piece.color].kingside || castleRights[piece.color].queenside) {\n        // check if i need to change castling rights\n        if (piece.type === 'king') {\n          castleRights[piece.color].kingside = false;\n          castleRights[piece.color].queenside = false;\n        }\n\n        if (piece.type === 'rook') {\n          // need to find if it is kingside or queenside rook\n          const [file] = square.split('');\n          const kingside = files.indexOf(file) > 3;\n          if (kingside) castleRights[piece.color].kingside = false;else castleRights[piece.color].queenside = false;\n        }\n      }\n\n      return castleRights;\n    },\n    canCastle: (color, side, boardMap = board) => {\n      if (CastleRights && !CastleRights[color][side]) return false; // check if rook still exists\n\n      if (!checkIfRookExists()) return false;\n      const oppColor = color === 'white' ? 'black' : 'white';\n      const oppMoves = getAttackingMovesForColor(oppColor, boardMap);\n      const castleSquares = get.castleSquares(color)[side];\n\n      for (const square of castleSquares) {\n        // check if castle square is cleared\n        if (at(square, boardMap).piece) return false; // make sure castle square isnt attacked\n\n        if (oppMoves.includes(square)) return false;\n      }\n\n      return true;\n\n      function checkIfRookExists() {\n        let rookExists = false;\n        const rank = color === 'white' ? 1 : 8;\n        const loopStart = side === 'queenside' ? files.indexOf('a') : files.indexOf('d');\n        const loopEnd = side === 'queenside' ? files.indexOf('e') : files.indexOf('h');\n\n        for (let i = loopStart; i <= loopEnd; i++) {\n          const square = files[i] + rank;\n          const piece = at(square, boardMap).piece;\n          if (!piece) continue;\n          if (piece.type === 'rook') rookExists = true;\n        }\n\n        return rookExists;\n      }\n    },\n    boardStateFromHistory: history => {\n      const boardMap = createBoard();\n      placePieces(standard, boardMap);\n      let pieceMap = standard; // history is 2d array\n\n      const flat = history.flat();\n      /* iterate over history */\n\n      for (const [i, m] of flat.entries()) {\n        const parsed = parseNotation(m);\n        const color = i % 2 === 0 ? 'white' : 'black';\n\n        if (parsed.castle) {\n          castle(color, parsed.castle, boardMap);\n          continue;\n        }\n\n        const possiblePieces = pieceMap[color][parsed.pieceType].filter(s => getLegalMoves(s, boardMap).includes(parsed.to)); // get 'from' square\n\n        let s1;\n\n        if (parsed.from) {\n          const notation = parsed.from;\n          s1 = possiblePieces.find(s => {\n            // if notation is a number, that means piece is on the rank === notation, if not, same file\n            return isNaN(Number(notation)) ? s[0] === notation : s[1] === notation;\n          }) || '';\n        } else s1 = possiblePieces[0];\n\n        const piece = at(s1, boardMap).piece;\n\n        if (!s1 || !piece) {\n          break;\n        } // make move\n\n\n        if (piece.type === 'pawn') {\n          if (enPassant.isCapture(s1, parsed.to, boardMap)) {\n            enPassant.capture(parsed.to, boardMap);\n          }\n\n          enPassant.remove(boardMap);\n          if (enPassant.checkToggle(s1, parsed.to)) enPassant.toggle(color, parsed.to, boardMap);\n\n          if (parsed.promote) {\n            at(s1, boardMap).promote(parsed.promote);\n          }\n        } else enPassant.remove(boardMap);\n\n        from(s1, boardMap).to(parsed.to);\n        pieceMap = get.pieceMap(boardMap);\n      }\n\n      return boardMap;\n    }\n  };\n  const validate = {\n    move: (from, to, boardMap = board) => {\n      const piece = at(from, boardMap).piece;\n      if (!piece) return false;\n      if (!at(from, boardMap).getLegalMoves().includes(to)) return false;\n      return true;\n    },\n    promotion: (from, to, boardMap = board) => {\n      const piece = at(from, boardMap).piece;\n      if ((piece === null || piece === void 0 ? void 0 : piece.type) !== 'pawn') return false;\n      const endOfBoard = piece.color === 'white' ? 8 : 1;\n      const [, rank] = to.split('');\n      if (+rank !== endOfBoard) return false;\n      return true;\n    }\n  };\n  return {\n    createBoard,\n    placePieces,\n    castle,\n    enPassant,\n    at,\n    from,\n    get,\n    validate,\n    makeMove,\n\n    get board() {\n      return board;\n    }\n\n  };\n};\n\n/* harmony default export */ const src_Gameboard = (Gameboard);\n;// CONCATENATED MODULE: ./src/History.ts\n// should output history object that holds move history in 2d array\n// for each move needs to attach piece Type to beginning of move if not pawn\n// should further specify square of piece if, say both rooks, can move to same square\n\nfunction History(prevHistory, board, pieceMap) {\n  const history = prevHistory || [];\n  const get = {\n    piecePrefix: (from, to) => {\n      var _a;\n\n      const {\n        type,\n        color\n      } = (_a = board.get(to)) === null || _a === void 0 ? void 0 : _a.piece;\n\n      switch (type) {\n        case 'pawn':\n          return '';\n\n        case 'knight':\n        case 'rook':\n          {\n            let prefix = type === 'rook' ? 'R' : 'N';\n\n            if (pieceMap[color][type].length !== 1) {\n              // look for piece of same type that couldve also went to the square\n              pieceMap[color][type].forEach(s => {\n                if (s === to) return;\n                const boardCopy = new Map(board);\n                boardCopy.set(to, {\n                  piece: null\n                });\n\n                if (getLegalMoves(s, boardCopy).includes(to)) {\n                  const [x1, y1] = from.split('');\n                  const [x2] = s.split('');\n                  const sameFile = x1 === x2;\n                  prefix = sameFile ? prefix + y1 : prefix + x1;\n                }\n              });\n            }\n\n            return prefix;\n          }\n\n        default:\n          {\n            const prefix = type.charAt(0).toUpperCase();\n            return prefix;\n          }\n      }\n    },\n    castleNotation: side => {\n      return side === 'kingside' ? 'O-O' : 'O-O-O';\n    }\n  };\n  const affix = {\n    capture: (move, prefix) => {\n      return `${prefix}x${move}`;\n    },\n    promote: (move, pieceType) => {\n      const suffix = pieceType === 'knight' ? 'N' : pieceType.charAt(0).toUpperCase();\n      return `${move}=${suffix}`;\n    },\n    check: notation => {\n      return `${notation}+`;\n    },\n    checkmate: notation => {\n      return `${notation}#`;\n    }\n  };\n  return {\n    get,\n    affix,\n    insertMove: notation => {\n      const lastMovePair = history[history.length - 1];\n\n      if (lastMovePair.length === 1) {\n        lastMovePair.push(notation);\n      } else {\n        const newMovePair = [notation];\n        history.push(newMovePair);\n      }\n    }\n  };\n}\n;// CONCATENATED MODULE: ./src/startingPositions.ts\nconst standard = {\n  white: {\n    rook: ['a1', 'h1'],\n    knight: ['g1', 'b1'],\n    bishop: ['f1', 'c1'],\n    king: ['e1'],\n    queen: ['d1'],\n    pawn: ['a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2']\n  },\n  black: {\n    rook: ['a8', 'h8'],\n    knight: ['g8', 'b8'],\n    bishop: ['f8', 'c8'],\n    king: ['e8'],\n    queen: ['d8'],\n    pawn: ['a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7']\n  }\n};\n\n;// CONCATENATED MODULE: ./src/main.ts\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LElBQUQsRUFBTyxJQUFQLENBREQ7QUFFTDhDLFVBQU0sRUFBRSxDQUFDLElBQUQsRUFBTyxJQUFQLENBRkg7QUFHTEMsVUFBTSxFQUFFLENBQUMsSUFBRCxFQUFPLElBQVAsQ0FISDtBQUlMdkcsUUFBSSxFQUFFLENBQUMsSUFBRCxDQUpEO0FBS0x3RyxTQUFLLEVBQUUsQ0FBQyxJQUFELENBTEY7QUFNTDlILFFBQUksRUFBRSxDQUFDLElBQUQsRUFBTyxJQUFQLEVBQWEsSUFBYixFQUFtQixJQUFuQixFQUF5QixJQUF6QixFQUErQixJQUEvQixFQUFxQyxJQUFyQyxFQUEyQyxJQUEzQztBQU5EO0FBVHFCLENBQTlCOzs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3JvQ2hlc3MvLi9zcmMvdXRpbHMvaGVscGVycy50cz8yOGYzIiwid2VicGFjazovL2Nyb0NoZXNzLy4vc3JjL1BpZWNlLnRzPzJlYjgiLCJ3ZWJwYWNrOi8vY3JvQ2hlc3MvLi9zcmMvdXRpbHMvbW92ZXMudHM/NTBmYiIsIndlYnBhY2s6Ly9jcm9DaGVzcy8uL3NyYy9yYW5rc0FuZEZpbGVzLnRzP2U2MjEiLCJ3ZWJwYWNrOi8vY3JvQ2hlc3MvLi9zcmMvQ2FzdGxlLnRzPzFjZWEiLCJ3ZWJwYWNrOi8vY3JvQ2hlc3MvLi9zcmMvR2FtZWJvYXJkLnRzPzU3ZTMiLCJ3ZWJwYWNrOi8vY3JvQ2hlc3MvLi9zcmMvSGlzdG9yeS50cz80YzIxIiwid2VicGFjazovL2Nyb0NoZXNzLy4vc3JjL3N0YXJ0aW5nUG9zaXRpb25zLnRzPzNiYmMiLCJ3ZWJwYWNrOi8vY3JvQ2hlc3MvLi9zcmMvbWFpbi50cz9jZDQ5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvb3JkLCBNb3ZlSW50ZXJmYWNlIH0gZnJvbSAnLi4vdHlwZXMvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBQaWVjZUFiYnJldmlhdGlvbiwgUGllY2VUeXBlLCBTcXVhcmUgfSBmcm9tICcuLi90eXBlcy90eXBlcyc7XG5cbmZ1bmN0aW9uIHRvWFkoc3F1YXJlOiBTcXVhcmUpOiBDb29yZCB7XG4gIGNvbnN0IFt4LCB5XSA9IHNxdWFyZS5zcGxpdCgnJyk7XG4gIHJldHVybiB7XG4gICAgeDogWydhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJywgJ2gnXS5pbmRleE9mKHgudG9Mb3dlckNhc2UoKSksXG4gICAgeTogTnVtYmVyKHkpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGZyb21YWShjb29yZDogQ29vcmQpOiBTcXVhcmUge1xuICBjb25zdCB7IHgsIHkgfSA9IGNvb3JkO1xuICBjb25zdCBjb2wgPSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJywgJ2cnLCAnaCddW3hdO1xuICBpZiAoIWNvbCkgcmV0dXJuICcnO1xuICByZXR1cm4gY29sLmNvbmNhdCh5LnRvU3RyaW5nKCkpO1xufVxuXG5jb25zdCBjYWxjRGlzdGFuY2UgPSAoc3F1YXJlT25lOiBzdHJpbmcpID0+IChzcXVhcmVUd286IHN0cmluZykgPT4ge1xuICBjb25zdCB7IHg6IHgxLCB5OiB5MSB9ID0gdG9YWShzcXVhcmVPbmUpO1xuICBjb25zdCB7IHg6IHgyLCB5OiB5MiB9ID0gdG9YWShzcXVhcmVUd28pO1xuXG4gIGNvbnN0IHhEaWZmID0geDEgLSB4MjtcbiAgY29uc3QgeURpZmYgPSB5MSAtIHkyO1xuICByZXR1cm4ge1xuICAgIHhEaWZmLFxuICAgIHlEaWZmXG4gIH07XG59O1xuXG5mdW5jdGlvbiBnZXRQaWVjZUZyb21BYmJyKGFiYnI6IFBpZWNlQWJicmV2aWF0aW9uKSB7XG4gIHN3aXRjaCAoYWJicikge1xuICAgIGNhc2UgJ0snOlxuICAgICAgcmV0dXJuICdraW5nJztcblxuICAgIGNhc2UgJ1EnOlxuICAgICAgcmV0dXJuICdxdWVlbic7XG5cbiAgICBjYXNlICdOJzpcbiAgICAgIHJldHVybiAna25pZ2h0JztcblxuICAgIGNhc2UgJ0InOlxuICAgICAgcmV0dXJuICdiaXNob3AnO1xuXG4gICAgY2FzZSAnUic6XG4gICAgICByZXR1cm4gJ3Jvb2snO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlTm90YXRpb24obm90YXRpb246IHN0cmluZykge1xuICBjb25zdCBtb3ZlID0gPE1vdmVJbnRlcmZhY2U+e307XG5cbiAgY29uc3QgcmVwbGFjZWQgPSBub3RhdGlvbi5yZXBsYWNlKC9bK3gjXS8sICcnKTtcblxuICBpZiAoK3JlcGxhY2VkWzBdID09PSAwKSB7XG4gICAgLy8gdGhpcyBpcyBjYXN0bGVcbiAgICBtb3ZlLmNhc3RsZSA9IHJlcGxhY2VkLmxlbmd0aCA9PT0gMyA/ICdraW5nc2lkZScgOiAncXVlZW5zaWRlJztcbiAgICByZXR1cm4gbW92ZTtcbiAgfVxuXG4gIGlmIChyZXBsYWNlZFswXS50b1VwcGVyQ2FzZSgpID09PSByZXBsYWNlZFswXSkge1xuICAgIC8vIHRoaXMgaXMgcGllY2UgbW92ZVxuICAgIG1vdmUucGllY2VUeXBlID0gZ2V0UGllY2VGcm9tQWJicihyZXBsYWNlZFswXSBhcyBQaWVjZUFiYnJldmlhdGlvbik7XG4gICAgbW92ZS50byA9IHJlcGxhY2VkLnNsaWNlKC0yKTtcblxuICAgIGlmIChyZXBsYWNlZC5sZW5ndGggPT09IDQpIHtcbiAgICAgIG1vdmUuZnJvbSA9IHJlcGxhY2VkWzFdO1xuICAgIH1cblxuICAgIHJldHVybiBtb3ZlO1xuICB9IGVsc2Uge1xuICAgIC8vIGlzIGEgcGF3biBtb3ZlXG4gICAgbW92ZS5waWVjZVR5cGUgPSAncGF3bic7XG5cbiAgICBpZiAocmVwbGFjZWQuaW5jbHVkZXMoJz0nKSkge1xuICAgICAgLy8gaW5kaWNhdGVzIHByb21vdGlvblxuICAgICAgbW92ZS5wcm9tb3RlID0gZ2V0UGllY2VGcm9tQWJicihyZXBsYWNlZC5zbGljZSgtMSkgYXMgUGllY2VBYmJyZXZpYXRpb24pO1xuICAgIH1cblxuICAgIGNvbnN0IHByb21vdGVOb3RlSW5kZXggPSByZXBsYWNlZC5pbmRleE9mKCc9Jyk7XG4gICAgY29uc3Qgbm9Qcm9tb3RlTm90YXRpb24gPSByZXBsYWNlZC5zbGljZShcbiAgICAgIDAsXG4gICAgICBwcm9tb3RlTm90ZUluZGV4ID09PSAtMSA/IHJlcGxhY2VkLmxlbmd0aCA6IHByb21vdGVOb3RlSW5kZXhcbiAgICApO1xuICAgIGlmIChub1Byb21vdGVOb3RhdGlvbi5sZW5ndGggPT09IDMpIHtcbiAgICAgIG1vdmUuZnJvbSA9IHJlcGxhY2VkWzBdO1xuICAgIH1cbiAgICBtb3ZlLnRvID0gbm9Qcm9tb3RlTm90YXRpb24uc2xpY2UoLTIpO1xuICB9XG5cbiAgcmV0dXJuIG1vdmU7XG59XG5cbmV4cG9ydCB7IHRvWFksIGZyb21YWSwgY2FsY0Rpc3RhbmNlLCBnZXRQaWVjZUZyb21BYmJyLCBwYXJzZU5vdGF0aW9uIH07XG4iLCJpbXBvcnQgbW92ZXMgZnJvbSAnLi91dGlscy9tb3Zlcyc7XG5pbXBvcnQgeyB0b1hZLCBmcm9tWFkgfSBmcm9tICcuL3V0aWxzL2hlbHBlcnMnO1xuXG5pbXBvcnQgeyBDb2xvciwgU3F1YXJlLCBQaWVjZVR5cGUgfSBmcm9tICcuL3R5cGVzL3R5cGVzJztcblxuY29uc3QgUGllY2UgPSAoY29sb3I6IENvbG9yLCB0eXBlOiBQaWVjZVR5cGUpID0+IHtcbiAgZnVuY3Rpb24gaGFzTW92ZShmcm9tOiBTcXVhcmUsIHRvOiBTcXVhcmUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2tpbmcnOiB7XG4gICAgICAgIGNvbnN0IG9uZVNxdWFyZVZlcnQgPVxuICAgICAgICAgIG1vdmVzLnlCeU4oMSkoZnJvbSkodG8pICYmIG1vdmVzLnhCeU4oMCkoZnJvbSkodG8pO1xuICAgICAgICBjb25zdCBvbmVTcXVhcmVMYXRlcmFsID1cbiAgICAgICAgICBtb3Zlcy54QnlOKDEpKGZyb20pKHRvKSAmJiBtb3Zlcy55QnlOKDApKGZyb20pKHRvKTtcbiAgICAgICAgY29uc3Qgb25lU3F1YXJlRGlhZ29uYWxseSA9XG4gICAgICAgICAgbW92ZXMueUJ5TigxKShmcm9tKSh0bykgJiYgbW92ZXMueEJ5TigxKShmcm9tKSh0byk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBmcm9tICE9PSB0byAmJlxuICAgICAgICAgIChvbmVTcXVhcmVEaWFnb25hbGx5IHx8IG9uZVNxdWFyZVZlcnQgfHwgb25lU3F1YXJlTGF0ZXJhbClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ3F1ZWVuJzoge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGZyb20gIT09IHRvICYmXG4gICAgICAgICAgKG1vdmVzLmRpYWdvbmFsKGZyb20pKHRvKSB8fCBtb3Zlcy52ZXJ0QW5kTGF0ZXJhbChmcm9tKSh0bykpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjYXNlICdiaXNob3AnOiB7XG4gICAgICAgIHJldHVybiBmcm9tICE9PSB0byAmJiBtb3Zlcy5kaWFnb25hbChmcm9tKSh0byk7XG4gICAgICB9XG4gICAgICBjYXNlICdrbmlnaHQnOiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgZnJvbSAhPT0gdG8gJiZcbiAgICAgICAgICAoKG1vdmVzLnhCeU4oMSkoZnJvbSkodG8pICYmIG1vdmVzLnlCeU4oMikoZnJvbSkodG8pKSB8fFxuICAgICAgICAgICAgKG1vdmVzLnhCeU4oMikoZnJvbSkodG8pICYmIG1vdmVzLnlCeU4oMSkoZnJvbSkodG8pKSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ3Jvb2snOiB7XG4gICAgICAgIHJldHVybiBmcm9tICE9PSB0byAmJiBtb3Zlcy52ZXJ0QW5kTGF0ZXJhbCh0bykoZnJvbSk7XG4gICAgICB9XG4gICAgICBjYXNlICdwYXduJzoge1xuICAgICAgICBjb25zdCB7IHg6IHgxLCB5OiB5MSB9ID0gdG9YWShmcm9tKTtcbiAgICAgICAgY29uc3QgeyB4OiB4MiwgeTogeTIgfSA9IHRvWFkodG8pO1xuXG4gICAgICAgIGNvbnN0IG9ubHlNb3Zlc0luRnJvbnQgPSBjb2xvciA9PT0gJ3doaXRlJyA/IHkxIDwgeTIgOiB5MSA+IHkyO1xuICAgICAgICBjb25zdCByZWd1bGFyTW92ZSA9IG1vdmVzLnlCeU4oMSkoZnJvbSkodG8pICYmIHgxID09PSB4MjtcblxuICAgICAgICBjb25zdCBmaXJzdE1vdmUgPSBjb2xvciA9PT0gJ3doaXRlJyA/IHkxID09PSAyIDogeTEgPT09IDc7XG4gICAgICAgIGNvbnN0IGp1bXBUd28gPSBtb3Zlcy55QnlOKDIpKGZyb20pKHRvKSAmJiB4MSA9PT0geDI7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBmcm9tICE9PSB0byAmJlxuICAgICAgICAgIG9ubHlNb3Zlc0luRnJvbnQgJiZcbiAgICAgICAgICAocmVndWxhck1vdmUgfHwgKGZpcnN0TW92ZSAmJiBqdW1wVHdvKSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQYXduQ2FwdHVyZXMob3JpZ2luOiBTcXVhcmUpIHtcbiAgICBpZiAodHlwZSAhPT0gJ3Bhd24nKSByZXR1cm47XG5cbiAgICBjb25zdCB7IHgsIHkgfSA9IHRvWFkob3JpZ2luKTtcblxuICAgIGNvbnN0IG5ld1kgPSBjb2xvciA9PT0gJ3doaXRlJyA/IHkgKyAxIDogeSAtIDE7XG5cbiAgICBjb25zdCBjYXB0dXJlT25lID0geyB4OiB4ICsgMSwgeTogbmV3WSB9O1xuICAgIGNvbnN0IGNhcHR1cmVUd28gPSB7IHg6IHggLSAxLCB5OiBuZXdZIH07XG5cbiAgICByZXR1cm4gW2Zyb21YWShjYXB0dXJlT25lKSwgZnJvbVhZKGNhcHR1cmVUd28pXTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaGFzTW92ZSxcbiAgICBnZXRQYXduQ2FwdHVyZXMsXG4gICAgZ2V0IHR5cGUoKSB7XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9LFxuICAgIGdldCBjb2xvcigpIHtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG4gIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBQaWVjZTtcbiIsImltcG9ydCB7IGNhbGNEaXN0YW5jZSwgdG9YWSB9IGZyb20gJy4vaGVscGVycyc7XG5pbXBvcnQgeyBTcXVhcmVPYmosIFBpZWNlT2JqLCBFblBhc3NhbnRPYmogfSBmcm9tICcuLi90eXBlcy9pbnRlcmZhY2VzJztcbmltcG9ydCB7IE1vdmVzLCBCb2FyZCwgU3F1YXJlLCBDb2xvciwgUGllY2VUeXBlIH0gZnJvbSAnLi4vdHlwZXMvdHlwZXMnO1xuaW1wb3J0IFBpZWNlIGZyb20gJy4uL1BpZWNlJztcblxuY29uc3QgbW92ZXMgPSB7XG4gIHZlcnRBbmRMYXRlcmFsOiAoZnJvbTogU3F1YXJlKSA9PiAodG86IFNxdWFyZSkgPT4ge1xuICAgIGNvbnN0IFt4MSwgeTFdID0gZnJvbS5zcGxpdCgnJyk7XG4gICAgY29uc3QgW3gyLCB5Ml0gPSB0by5zcGxpdCgnJyk7XG4gICAgcmV0dXJuIHgxID09PSB4MiB8fCB5MSA9PT0geTI7XG4gIH0sXG4gIGRpYWdvbmFsOiAoZnJvbTogU3F1YXJlKSA9PiAodG86IFNxdWFyZSkgPT4ge1xuICAgIGNvbnN0IHsgeDogeDEsIHk6IHkxIH0gPSB0b1hZKGZyb20pO1xuICAgIGNvbnN0IHsgeDogeDIsIHk6IHkyIH0gPSB0b1hZKHRvKTtcbiAgICByZXR1cm4gTWF0aC5hYnMoeDIgLSB4MSkgPT09IE1hdGguYWJzKHkyIC0geTEpO1xuICB9LFxuICB4QnlOOiAobnVtOiBudW1iZXIpID0+IChmcm9tOiBTcXVhcmUpID0+ICh0bzogU3F1YXJlKSA9PiB7XG4gICAgY29uc3QgeyB4OiB4MSB9ID0gdG9YWShmcm9tKTtcbiAgICBjb25zdCB7IHg6IHgyIH0gPSB0b1hZKHRvKTtcbiAgICByZXR1cm4gTWF0aC5hYnMoeDEgLSB4MikgPT09IG51bTtcbiAgfSxcbiAgeUJ5TjogKG51bTogbnVtYmVyKSA9PiAoZnJvbTogU3F1YXJlKSA9PiAodG86IFNxdWFyZSkgPT4ge1xuICAgIGNvbnN0IHsgeTogeTEgfSA9IHRvWFkoZnJvbSk7XG4gICAgY29uc3QgeyB5OiB5MiB9ID0gdG9YWSh0byk7XG4gICAgcmV0dXJuIE1hdGguYWJzKHkxIC0geTIpID09PSBudW07XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IG1vdmVzO1xuXG4vKiBkZWFsaW5nIHdpdGggbW92ZSB2ZWN0b3JzICovXG5cbmZ1bmN0aW9uIHNwbGl0SW50b1ZlY3RvcnMoYXJyYXlPZk1vdmVzOiBNb3Zlcywgc3RhcnQ6IFNxdWFyZSkge1xuICBpbnRlcmZhY2UgVmVjdG9ycyB7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nW107XG4gIH1cbiAgcmV0dXJuIGFycmF5T2ZNb3Zlcy5yZWR1Y2UoKGFjYzogVmVjdG9ycywgY3VycjogU3F1YXJlKSA9PiB7XG4gICAgY29uc3QgeyB4RGlmZiwgeURpZmYgfSA9IGNhbGNEaXN0YW5jZShzdGFydCkoY3Vycik7XG5cbiAgICBsZXQgdmVjdG9yID0gJyc7XG4gICAgaWYgKHlEaWZmICE9PSAwKSB2ZWN0b3IgPSB5RGlmZiA8IDAgPyAndXAnIDogJ2Rvd24nO1xuICAgIGlmICh4RGlmZiAhPT0gMCkgdmVjdG9yICs9IHhEaWZmIDwgMCA/ICdSaWdodCcgOiAnTGVmdCc7XG5cbiAgICAvLyBub3JtYWxpemUgdmVjdG9yIG5hbWVcbiAgICB2ZWN0b3IgPSB2ZWN0b3IuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyB2ZWN0b3Iuc2xpY2UoMSk7XG5cbiAgICBhY2NbdmVjdG9yXSA9IGFjY1t2ZWN0b3JdIHx8IFtdO1xuICAgIGFjY1t2ZWN0b3JdLnB1c2goY3Vycik7XG5cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59XG5cbmZ1bmN0aW9uIGdldEJlZ2lubmluZ09mVmVjdG9yKHZlY3RvcjogTW92ZXMpIHtcbiAgaWYgKHZlY3Rvci5sZW5ndGggPT09IDApIHJldHVybiAnJztcblxuICByZXR1cm4gdmVjdG9yLnJlZHVjZSgoYWNjLCBjdXJyKSA9PiB7XG4gICAgY29uc3QgeyB4OiB4MSwgeTogeTEgfSA9IHRvWFkoYWNjKTtcbiAgICBjb25zdCB7IHg6IHgyLCB5OiB5MiB9ID0gdG9YWShjdXJyKTtcblxuICAgIGNvbnN0IGFjY0lzQmVnaW5uaW5nID0geDEgPT09IHgyID8geTEgPCB5MiA6IHgxIDwgeDI7XG4gICAgcmV0dXJuIGFjY0lzQmVnaW5uaW5nID8gYWNjIDogY3VycjtcbiAgfSk7XG59XG5cbmNvbnN0IGdldE1vdmVzQWxvbmdWZWN0b3IgPSAoXG4gIHMxOiBTcXVhcmUsXG4gIHMyOiBTcXVhcmUsXG4gIGFsbFNxdWFyZXM6IE1vdmVzXG4pOiBNb3ZlcyA9PiB7XG4gIGNvbnN0IGxpZXNTYW1lVmVydE9yTGF0ID0gbW92ZXMudmVydEFuZExhdGVyYWwoczEpKHMyKTtcbiAgY29uc3QgbGllc1NhbWVEaWFnb25hbGx5ID0gbW92ZXMuZGlhZ29uYWwoczEpKHMyKTtcblxuICBjb25zdCBsaWVzT25TYW1lTGluZSA9IGxpZXNTYW1lVmVydE9yTGF0IHx8IGxpZXNTYW1lRGlhZ29uYWxseTtcbiAgaWYgKCFsaWVzT25TYW1lTGluZSkgcmV0dXJuIFtdO1xuXG4gIGNvbnN0IG1hdGNoaW5nVmVjdG9yID0gbGllc1NhbWVEaWFnb25hbGx5ID8gJ2RpYWdvbmFsJyA6ICd2ZXJ0QW5kTGF0ZXJhbCc7XG5cbiAgY29uc3Qgc3F1YXJlc0Fsb25nVmVjdG9yID0gYWxsU3F1YXJlcy5maWx0ZXIoXG4gICAgKHMpID0+IG1vdmVzW21hdGNoaW5nVmVjdG9yXShzMSkocykgJiYgbW92ZXNbbWF0Y2hpbmdWZWN0b3JdKHMyKShzKVxuICApO1xuICByZXR1cm4gc3F1YXJlc0Fsb25nVmVjdG9yO1xufTtcblxuLyogc29ydCBtb3ZlcyAqL1xuXG5jb25zdCBzb3J0TW92ZXNDbG9zZXN0VG8gPVxuICAoc3F1YXJlOiBTcXVhcmUpID0+XG4gIChtb3ZlczogTW92ZXMpOiBNb3ZlcyA9PiB7XG4gICAgcmV0dXJuIFsuLi5tb3Zlc10uc29ydCgoYSwgYikgPT4ge1xuICAgICAgY29uc3QgeyB4RGlmZjogeDFEaWZmLCB5RGlmZjogeTFEaWZmIH0gPSBjYWxjRGlzdGFuY2Uoc3F1YXJlKShhKTtcbiAgICAgIGNvbnN0IGFEaWZmID0gTWF0aC5hYnMoeDFEaWZmKSArIE1hdGguYWJzKHkxRGlmZik7XG5cbiAgICAgIGNvbnN0IHsgeERpZmY6IHgyRGlmZiwgeURpZmY6IHkyRGlmZiB9ID0gY2FsY0Rpc3RhbmNlKHNxdWFyZSkoYik7XG4gICAgICBjb25zdCBiRGlmZiA9IE1hdGguYWJzKHgyRGlmZikgKyBNYXRoLmFicyh5MkRpZmYpO1xuXG4gICAgICByZXR1cm4gYURpZmYgLSBiRGlmZjtcbiAgICB9KTtcbiAgfTtcblxuLyogZ2V0IG1vdmVzICovXG5cbmZ1bmN0aW9uIGdldFBvc3NpYmxlTW92ZXMob3JpZ2luOiBTcXVhcmUsIGJvYXJkOiBCb2FyZCkge1xuICAvLyBnZXQgYWxsIG1vdmVzIHRoYXQgY2FuIGhhcHBlbiBpZiBubyBvdGhlciBwaWVjZXMgd2VyZSBvbiB0aGUgYm9hcmRcbiAgY29uc3QgYWxsU3F1YXJlcyA9IEFycmF5LmZyb20oYm9hcmQua2V5cygpKTtcblxuICBjb25zdCBzcXVhcmUgPSBib2FyZC5nZXQob3JpZ2luKSBhcyBTcXVhcmVPYmo7XG5cbiAgY29uc3QgeyB0eXBlLCBjb2xvciB9ID0gc3F1YXJlLnBpZWNlIGFzIFBpZWNlT2JqO1xuICBjb25zdCBwaWVjZSA9IFBpZWNlKGNvbG9yLCB0eXBlKTtcblxuICByZXR1cm4gYWxsU3F1YXJlcy5maWx0ZXIoKHMpID0+IHBpZWNlLmhhc01vdmUob3JpZ2luLCBzKSk7XG59XG5cbmZ1bmN0aW9uIGdldExlZ2FsTW92ZXMob3JpZ2luOiBTcXVhcmUsIGJvYXJkOiBCb2FyZCkge1xuICAvLyBnZXQgbW92ZXMgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIG9yIG5vdCB0aGVyZSBpcyBjaGVja1xuXG4gIGNvbnN0IHNxdWFyZSA9IGJvYXJkLmdldChvcmlnaW4pIGFzIFNxdWFyZU9iajtcblxuICBjb25zdCBwaWVjZSA9IHNxdWFyZS5waWVjZSBhcyBQaWVjZU9iajtcblxuICBjb25zdCBwb3NzaWJsZU1vdmVzID0gZ2V0UG9zc2libGVNb3ZlcyhvcmlnaW4sIGJvYXJkKTtcblxuICBjb25zdCBvYnN0cnVjdGlvbnMgPSBwb3NzaWJsZU1vdmVzLmZpbHRlcigocykgPT4gYm9hcmQuZ2V0KHMpPy5waWVjZSk7XG4gIGlmICghb2JzdHJ1Y3Rpb25zLmxlbmd0aCkge1xuICAgIGlmIChwaWVjZS50eXBlID09PSAncGF3bicpXG4gICAgICByZXR1cm4gWy4uLmdldFBhd25DYXB0dXJlcyhvcmlnaW4sIGJvYXJkKSwgLi4ucG9zc2libGVNb3Zlc107XG4gICAgcmV0dXJuIHBvc3NpYmxlTW92ZXM7XG4gIH1cblxuICBsZXQgbGVnYWxNb3ZlczogTW92ZXMgPSBbXTtcbiAgc3dpdGNoIChwaWVjZS50eXBlKSB7XG4gICAgY2FzZSAna25pZ2h0Jzoge1xuICAgICAgbGVnYWxNb3ZlcyA9IHBvc3NpYmxlTW92ZXM7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAncGF3bic6IHtcbiAgICAgIGNvbnN0IGNhcHR1cmVzQXZhaWxhYmxlID0gZ2V0UGF3bkNhcHR1cmVzKG9yaWdpbiwgYm9hcmQpO1xuICAgICAgY29uc3QgdW5vYnN0cnVjdGVkTW92ZXMgPSByZW1vdmVNb3Zlc1dpdGhQaWVjZXMoXG4gICAgICAgIHJlbW92ZU9ic3RydWN0ZWRNb3ZlcyhvcmlnaW4sIHBvc3NpYmxlTW92ZXMsIG9ic3RydWN0aW9ucyksXG4gICAgICAgIGJvYXJkXG4gICAgICApO1xuICAgICAgbGVnYWxNb3ZlcyA9IFsuLi5jYXB0dXJlc0F2YWlsYWJsZSwgLi4udW5vYnN0cnVjdGVkTW92ZXNdO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgJ2tpbmcnOiB7XG4gICAgICBsZWdhbE1vdmVzID0gcmVtb3ZlUHJvdGVjdGVkU3F1YXJlcyhvcmlnaW4sIHBvc3NpYmxlTW92ZXMsIGJvYXJkKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBsZWdhbE1vdmVzID0gcmVtb3ZlT2JzdHJ1Y3RlZE1vdmVzKG9yaWdpbiwgcG9zc2libGVNb3Zlcywgb2JzdHJ1Y3Rpb25zKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVtb3ZlTW92ZXNXaXRoUGllY2VzKGxlZ2FsTW92ZXMsIGJvYXJkLCBwaWVjZS5jb2xvcik7XG59XG5cbmZ1bmN0aW9uIGdldExlZ2FsTW92ZXNJbkNoZWNrKFxuICBvcmlnaW46IFNxdWFyZSxcbiAgYm9hcmQ6IEJvYXJkLFxuICBraW5nUG9zOiBTcXVhcmUsXG4gIHNxdWFyZUdpdmluZ0NoZWNrOiBTcXVhcmVcbikge1xuICBjb25zdCBzcXVhcmVzVGhhdERlYWxXaXRoQ2hlY2sgPSBnZXRTcXVhcmVzQmV0d2VlbktpbmdBbmRDaGVjayhcbiAgICBraW5nUG9zLFxuICAgIHNxdWFyZUdpdmluZ0NoZWNrLFxuICAgIEFycmF5LmZyb20oYm9hcmQua2V5cygpKVxuICApO1xuXG4gIGNvbnN0IG1vdmVzID0gZ2V0TGVnYWxNb3ZlcyhvcmlnaW4sIGJvYXJkKTtcblxuICByZXR1cm4gbW92ZXMuZmlsdGVyKChzKSA9PiBzcXVhcmVzVGhhdERlYWxXaXRoQ2hlY2suaW5jbHVkZXMocykpO1xufVxuXG5mdW5jdGlvbiBnZXRBdHRhY2tpbmdNb3ZlcyhvcmlnaW46IFNxdWFyZSwgYm9hcmQ6IEJvYXJkKSB7XG4gIGNvbnN0IHNxdWFyZSA9IGJvYXJkLmdldChvcmlnaW4pIGFzIFNxdWFyZU9iajtcblxuICBjb25zdCB7IHR5cGUsIGNvbG9yIH0gPSBzcXVhcmUucGllY2UgYXMgUGllY2VPYmo7XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAncGF3bic6IHtcbiAgICAgIGNvbnN0IHBpZWNlID0gUGllY2UoY29sb3IsICdwYXduJyk7XG4gICAgICByZXR1cm4gcGllY2UuZ2V0UGF3bkNhcHR1cmVzKG9yaWdpbikgYXMgTW92ZXM7XG4gICAgfVxuICAgIGNhc2UgJ2tpbmcnOiB7XG4gICAgICAvLyBuZWVkIHRvIGRvIHRoaXMgYmVjYXVzZSBnZXRMZWdhbE1vdmVzIHdpbGwgcmVjdXJzaXZlbHkgY2FsbCByZW1vdmVQcm90ZWN0ZWRTcXVhcmVzIG90aGVyd2lzZVxuICAgICAgY29uc3QgYXR0YWNraW5nTW92ZXMgPSByZW1vdmVNb3Zlc1dpdGhQaWVjZXMoXG4gICAgICAgIGdldFBvc3NpYmxlTW92ZXMob3JpZ2luLCBib2FyZCksXG4gICAgICAgIGJvYXJkLFxuICAgICAgICBjb2xvclxuICAgICAgKTtcbiAgICAgIHJldHVybiBhdHRhY2tpbmdNb3ZlcztcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBnZXRMZWdhbE1vdmVzKG9yaWdpbiwgYm9hcmQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEFsbE1vdmVzRm9yQ29sb3IoXG4gIGNvbG9yOiBDb2xvcixcbiAgYm9hcmQ6IEJvYXJkLFxuICBza2lwS2luZz86IGJvb2xlYW5cbik6IE1vdmVzIHtcbiAgY29uc3QgYWxsTW92ZXM6IE1vdmVzW10gPSBbXTtcbiAgZm9yIChjb25zdCBbc3F1YXJlLCB7IHBpZWNlIH1dIG9mIGJvYXJkLmVudHJpZXMoKSkge1xuICAgIGlmICghcGllY2UpIGNvbnRpbnVlO1xuICAgIGlmIChwaWVjZS5jb2xvciAhPT0gY29sb3IpIGNvbnRpbnVlO1xuICAgIGlmIChza2lwS2luZyAmJiBwaWVjZS50eXBlID09PSAna2luZycpIGNvbnRpbnVlO1xuXG4gICAgYWxsTW92ZXMucHVzaChnZXRMZWdhbE1vdmVzKHNxdWFyZSwgYm9hcmQpKTtcbiAgfVxuXG4gIHJldHVybiBhbGxNb3Zlcy5mbGF0KCk7XG59XG5cbmZ1bmN0aW9uIGdldEF0dGFja2luZ01vdmVzRm9yQ29sb3IoY29sb3I6IENvbG9yLCBib2FyZDogQm9hcmQpOiBNb3ZlcyB7XG4gIGNvbnN0IGFsbE1vdmVzOiBNb3Zlc1tdID0gW107XG4gIGZvciAoY29uc3QgW3NxdWFyZSwgeyBwaWVjZSB9XSBvZiBib2FyZC5lbnRyaWVzKCkpIHtcbiAgICBpZiAoIXBpZWNlKSBjb250aW51ZTtcbiAgICBpZiAocGllY2UuY29sb3IgIT09IGNvbG9yKSBjb250aW51ZTtcblxuICAgIGFsbE1vdmVzLnB1c2goZ2V0QXR0YWNraW5nTW92ZXMoc3F1YXJlLCBib2FyZCkpO1xuICB9XG5cbiAgcmV0dXJuIGFsbE1vdmVzLmZsYXQoKTtcbn1cblxuZnVuY3Rpb24gZ2V0UGF3bkNhcHR1cmVzKHBhd25TcXVhcmU6IFNxdWFyZSwgYm9hcmQ6IEJvYXJkKSB7XG4gIGNvbnN0IHsgY29sb3IgfSA9IGJvYXJkLmdldChwYXduU3F1YXJlKT8ucGllY2UgYXMgUGllY2VPYmo7XG4gIGNvbnN0IHBhd24gPSBQaWVjZShjb2xvciwgJ3Bhd24nKTtcblxuICBjb25zdCBjYXB0dXJlTW92ZXMgPSBwYXduLmdldFBhd25DYXB0dXJlcyhwYXduU3F1YXJlKTtcbiAgaWYgKCFjYXB0dXJlTW92ZXMpIHJldHVybiBbXTtcblxuICByZXR1cm4gY2FwdHVyZU1vdmVzLmZpbHRlcigocykgPT4ge1xuICAgIGNvbnN0IHNxdWFyZVZhbCA9IGJvYXJkLmdldChzKTtcbiAgICBpZiAoIXNxdWFyZVZhbCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgY29uc3QgcGllY2UgPSBzcXVhcmVWYWwucGllY2U7XG4gICAgY29uc3QgZW5QYXNzYW50OiBFblBhc3NhbnRPYmogfCB1bmRlZmluZWQgPSBzcXVhcmVWYWwuZW5QYXNzYW50O1xuXG4gICAgcmV0dXJuIChcbiAgICAgIChwaWVjZSAmJiBwaWVjZS5jb2xvciAhPT0gcGF3bi5jb2xvcikgfHxcbiAgICAgIChlblBhc3NhbnQgJiYgZW5QYXNzYW50LmNvbG9yICE9PSBwYXduLmNvbG9yKVxuICAgICk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRTcXVhcmVzQmV0d2VlbktpbmdBbmRDaGVjayhcbiAga2luZ1BvczogU3F1YXJlLFxuICBjaGVja1BvczogU3F1YXJlLFxuICBhbGxTcXVhcmVzOiBNb3Zlc1xuKSB7XG4gIC8vIGluY2x1ZGVzIGtpbmdQb3MgYW5kIGNoZWNrUG9zXG4gIGNvbnN0IHNxdWFyZXNBbG9uZ1ZlY3RvciA9IGdldE1vdmVzQWxvbmdWZWN0b3Ioa2luZ1BvcywgY2hlY2tQb3MsIGFsbFNxdWFyZXMpO1xuICBjb25zdCBzcXVhcmVzQmV0d2VlbktpbmdBbmRQaWVjZSA9IHJlbW92ZU1vdmVzQmVoaW5kVHdvU3F1YXJlcyhcbiAgICBraW5nUG9zLFxuICAgIGNoZWNrUG9zLFxuICAgIHNxdWFyZXNBbG9uZ1ZlY3RvclxuICApO1xuICByZXR1cm4gc3F1YXJlc0JldHdlZW5LaW5nQW5kUGllY2U7XG59XG5cbi8qIGZpbHRlciBtb3ZlcyAqL1xuXG5mdW5jdGlvbiByZW1vdmVNb3Zlc0JlaGluZFR3b1NxdWFyZXMoXG4gIHMxOiBTcXVhcmUsXG4gIHMyOiBTcXVhcmUsXG4gIHZlY3RvcjogTW92ZXNcbik6IE1vdmVzIHtcbiAgY29uc3Qgc29ydGVkID0gc29ydE1vdmVzQ2xvc2VzdFRvKGdldEJlZ2lubmluZ09mVmVjdG9yKHZlY3RvcikpKHZlY3Rvcik7XG4gIGxldCBmdXJ0aGVzdFNxdWFyZTtcbiAgbGV0IGNsb3Nlc3RTcXVhcmU7XG5cbiAgaWYgKHNvcnRlZC5pbmRleE9mKHMxKSA+IHNvcnRlZC5pbmRleE9mKHMyKSkge1xuICAgIGZ1cnRoZXN0U3F1YXJlID0gczE7XG4gICAgY2xvc2VzdFNxdWFyZSA9IHMyO1xuICB9IGVsc2Uge1xuICAgIGZ1cnRoZXN0U3F1YXJlID0gczI7XG4gICAgY2xvc2VzdFNxdWFyZSA9IHMxO1xuICB9XG4gIGNvbnN0IHJlbW92ZWRPbmVFbmQgPSByZW1vdmVNb3Zlc0JlaGluZFNxdWFyZShmdXJ0aGVzdFNxdWFyZSkoc29ydGVkKTtcbiAgY29uc3QgcmVtb3ZlZEJvdGhFbmRzID0gcmVtb3ZlTW92ZXNCZWhpbmRTcXVhcmUoY2xvc2VzdFNxdWFyZSkoXG4gICAgcmVtb3ZlZE9uZUVuZC5yZXZlcnNlKClcbiAgKTtcblxuICByZXR1cm4gcmVtb3ZlZEJvdGhFbmRzO1xufVxuXG5jb25zdCByZW1vdmVNb3Zlc0JlaGluZFNxdWFyZSA9XG4gIChzcXVhcmU6IFNxdWFyZSkgPT5cbiAgKG1vdmVzOiBNb3Zlcyk6IE1vdmVzID0+IHtcbiAgICBjb25zdCBjb3B5ID0gWy4uLm1vdmVzXTtcbiAgICBjb25zdCBpbmRleCA9IG1vdmVzLmluZGV4T2Yoc3F1YXJlKTtcblxuICAgIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiBbXTtcblxuICAgIGNvcHkuc3BsaWNlKGluZGV4ICsgMSk7XG5cbiAgICByZXR1cm4gY29weTtcbiAgfTtcblxuZnVuY3Rpb24gcmVtb3ZlT2JzdHJ1Y3RlZE1vdmVzKFxuICBzdGFydGluZ1NxdWFyZTogU3F1YXJlLFxuICBwb3NzaWJsZU1vdmVzOiBNb3ZlcyxcbiAgb2JzdHJ1Y3Rpb25zOiBNb3Zlc1xuKTogTW92ZXMge1xuICAvLyBhKSBzcGxpdCBwb3NzaWJsZSBtb3ZlcyBpbnRvIHZlY3RvcnMgKHVwLGRvd24sbGVmdCxyaWdodCwgYW5kL29yIGRpYWdvbmFscylcbiAgLy8gYikgc2VlIHdoaWNoIG9ic3RydWN0aW9ucyBiZWxvbmcgdG8gd2hpY2ggdmVjdG9yXG4gIC8vIGMpIGZpbmQgdGhlIGNsb3Nlc3Qgb2JzdHJ1Y3Rpb25cbiAgLy8gZCkgcmVtb3ZlIGFsbCB0aGUgbW92ZXMgYmVoaW5kIHRoYXQgb2JzdHJ1Y3Rpb25cblxuICBjb25zdCBmaWx0ZXJlZE1vdmVzOiBNb3Zlc1tdID0gW107XG5cbiAgY29uc3QgYWxsVmVjdG9ycyA9IHNwbGl0SW50b1ZlY3RvcnMocG9zc2libGVNb3Zlcywgc3RhcnRpbmdTcXVhcmUpO1xuICBjb25zdCBvYnN0cnVjdGlvblZlY3RvcnMgPSBzcGxpdEludG9WZWN0b3JzKG9ic3RydWN0aW9ucywgc3RhcnRpbmdTcXVhcmUpO1xuICBmb3IgKGNvbnN0IHZlY3RvciBpbiBhbGxWZWN0b3JzKSB7XG4gICAgaWYgKCFvYnN0cnVjdGlvblZlY3RvcnNbdmVjdG9yXSkge1xuICAgICAgLy8gbG9vayBmb3IgdmVjdG9yIG9ic3RydWN0aW9uIGlzIG9uXG4gICAgICBmaWx0ZXJlZE1vdmVzLnB1c2goYWxsVmVjdG9yc1t2ZWN0b3JdKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHNvcnRlZCA9IHNvcnRNb3Zlc0Nsb3Nlc3RUbyhzdGFydGluZ1NxdWFyZSkoYWxsVmVjdG9yc1t2ZWN0b3JdKTtcbiAgICBjb25zdCBjbG9zZXN0T2JzdHJ1Y3Rpb24gPSBzb3J0TW92ZXNDbG9zZXN0VG8oc3RhcnRpbmdTcXVhcmUpKFxuICAgICAgb2JzdHJ1Y3Rpb25WZWN0b3JzW3ZlY3Rvcl1cbiAgICApWzBdO1xuXG4gICAgZmlsdGVyZWRNb3Zlcy5wdXNoKHJlbW92ZU1vdmVzQmVoaW5kU3F1YXJlKGNsb3Nlc3RPYnN0cnVjdGlvbikoc29ydGVkKSk7XG4gIH1cblxuICByZXR1cm4gZmlsdGVyZWRNb3Zlcy5mbGF0KCk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVByb3RlY3RlZFNxdWFyZXMoXG4gIGtpbmdQb3M6IFNxdWFyZSxcbiAgcG9zc2libGVNb3ZlczogTW92ZXMsXG4gIGJvYXJkOiBCb2FyZFxuKTogTW92ZXMge1xuICBjb25zdCBraW5nID0gYm9hcmQuZ2V0KGtpbmdQb3MpPy5waWVjZSBhcyBQaWVjZU9iajtcbiAgY29uc3Qgb3BwQ29sb3IgPSBraW5nLmNvbG9yID09PSAnd2hpdGUnID8gJ2JsYWNrJyA6ICd3aGl0ZSc7XG5cbiAgLy8gYmMga2luZyBjYW50IG1vdmUgaWYgc3F1YXJlIGlzIHByb3RlY3RlZFxuICAvLyBzZXQga2luZyBwaWVjZSBvbiBlYWNoIHNxdWFyZSBpbiBwb3NzaWJsZSBtb3ZlcyB0byBmaW5kIHdoaWNoIHNxdWFyZXMgYXJlIHByb3RlY3RlZFxuICBjb25zdCBib2FyZENvcHkgPSBuZXcgTWFwKGJvYXJkKTtcbiAgcG9zc2libGVNb3Zlcy5mb3JFYWNoKChzKSA9PiBib2FyZENvcHkuc2V0KHMsIHsgcGllY2U6IGtpbmcgfSkpO1xuXG4gIGNvbnN0IGFsbEVuZW15TW92ZXMgPSBnZXRBdHRhY2tpbmdNb3Zlc0ZvckNvbG9yKG9wcENvbG9yLCBib2FyZENvcHkpO1xuICByZXR1cm4gcG9zc2libGVNb3Zlcy5maWx0ZXIoKHMpID0+IHtcbiAgICByZXR1cm4gIWFsbEVuZW15TW92ZXMuaW5jbHVkZXMocyk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZW1vdmVNb3Zlc1dpdGhQaWVjZXMoXG4gIG1vdmVzOiBNb3ZlcyxcbiAgYm9hcmQ6IEJvYXJkLFxuICBjb2xvcj86IENvbG9yXG4pOiBNb3ZlcyB7XG4gIHJldHVybiBtb3Zlcy5maWx0ZXIoKHMpID0+IHtcbiAgICBjb25zdCBzcXVhcmVWYWwgPSBib2FyZC5nZXQocyk7XG4gICAgaWYgKCFzcXVhcmVWYWwpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChjb2xvcikgcmV0dXJuICFzcXVhcmVWYWwucGllY2UgfHwgc3F1YXJlVmFsLnBpZWNlLmNvbG9yICE9PSBjb2xvcjtcbiAgICBlbHNlIHJldHVybiAhc3F1YXJlVmFsLnBpZWNlO1xuICB9KTtcbn1cblxuLyogZ2FtZWJvYXJkIGNoZWNrcyAqL1xuXG5mdW5jdGlvbiBnZXREaXNjb3ZlcmVkQ2hlY2soXG4gIGtpbmdQb3M6IFNxdWFyZSxcbiAga2luZ0NvbG9yOiBDb2xvcixcbiAgdmFjYXRlZDogU3F1YXJlLFxuICBib2FyZDogQm9hcmRcbik6IFNxdWFyZSB7XG4gIC8vIG9wZW5TcXVhcmUgaXMgYSBzcXVhcmUganVzdCB2YWNhdGVkXG4gIGxldCBzcXVhcmVzQWxvbmdWZWN0b3IgPSBnZXRNb3Zlc0Fsb25nVmVjdG9yKFxuICAgIGtpbmdQb3MsXG4gICAgdmFjYXRlZCxcbiAgICBBcnJheS5mcm9tKGJvYXJkLmtleXMoKSlcbiAgKTtcbiAgc3F1YXJlc0Fsb25nVmVjdG9yID0gc3F1YXJlc0Fsb25nVmVjdG9yLmZpbHRlcihcbiAgICAocykgPT4gcyAhPT0ga2luZ1BvcyAmJiBzICE9PSB2YWNhdGVkXG4gICk7XG4gIGlmICghc3F1YXJlc0Fsb25nVmVjdG9yLmxlbmd0aCkgcmV0dXJuICcnO1xuXG4gIGZvciAoY29uc3Qgc3F1YXJlIG9mIHNxdWFyZXNBbG9uZ1ZlY3Rvcikge1xuICAgIGNvbnN0IHBpZWNlID0gYm9hcmQuZ2V0KHNxdWFyZSk/LnBpZWNlO1xuICAgIGlmICghcGllY2UgfHwgcGllY2UuY29sb3IgPT09IGtpbmdDb2xvcikgY29udGludWU7XG5cbiAgICBjb25zdCBsZWdhbE1vdmVzID0gZ2V0TGVnYWxNb3ZlcyhzcXVhcmUsIGJvYXJkKTtcbiAgICBpZiAobGVnYWxNb3Zlcy5pbmNsdWRlcyhraW5nUG9zKSkgcmV0dXJuIHNxdWFyZTtcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gY2FuQmxvY2tPckNhcHR1cmVDaGVjayhcbiAga2luZ1BvczogU3F1YXJlLFxuICBzcXVhcmVHaXZpbmdDaGVjazogU3F1YXJlLFxuICBib2FyZDogQm9hcmRcbik6IGJvb2xlYW4ge1xuICBjb25zdCBraW5nID0gYm9hcmQuZ2V0KGtpbmdQb3MpPy5waWVjZSBhcyBQaWVjZU9iajtcblxuICBjb25zdCBibG9ja09yQ2FwdHVyZVNxdWFyZXMgPSBnZXRTcXVhcmVzQmV0d2VlbktpbmdBbmRDaGVjayhcbiAgICBraW5nUG9zLFxuICAgIHNxdWFyZUdpdmluZ0NoZWNrLFxuICAgIEFycmF5LmZyb20oYm9hcmQua2V5cygpKVxuICApOyAvLyBhbHNvIGluY2x1ZGVzIGNoZWNrIHNxdWFyZVxuXG4gIGNvbnN0IG93blBpZWNlTW92ZXMgPSBnZXRBbGxNb3Zlc0ZvckNvbG9yKGtpbmcuY29sb3IsIGJvYXJkLCB0cnVlKTtcbiAgcmV0dXJuIG93blBpZWNlTW92ZXMuc29tZSgobW92ZSkgPT4gYmxvY2tPckNhcHR1cmVTcXVhcmVzLmluY2x1ZGVzKG1vdmUpKTtcbn1cblxuZnVuY3Rpb24gZ2V0UGllY2VzV2l0aE1vdmUoXG4gIGJvYXJkOiBCb2FyZCxcbiAgbW92ZTogU3F1YXJlLFxuICBwaWVjZVR5cGU6IFBpZWNlVHlwZSxcbiAgY29sb3I6ICdibGFjaycgfCAnd2hpdGUnXG4pIHtcbiAgY29uc3QgcGllY2VTcXVhcmVzOiBNb3ZlcyA9IFtdO1xuICBmb3IgKGNvbnN0IFtzcXVhcmUsIHsgcGllY2UgfV0gb2YgYm9hcmQuZW50cmllcygpKSB7XG4gICAgaWYgKCFwaWVjZSkgY29udGludWU7XG4gICAgaWYgKHBpZWNlLmNvbG9yICE9PSBjb2xvcikgY29udGludWU7XG4gICAgaWYgKHBpZWNlLnR5cGUgIT09IHBpZWNlVHlwZSkgY29udGludWU7XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgZ2V0QXR0YWNraW5nTW92ZXNGb3JDb2xvcixcbiAgZ2V0TGVnYWxNb3ZlcyxcbiAgZ2V0TGVnYWxNb3Zlc0luQ2hlY2ssXG4gIGdldERpc2NvdmVyZWRDaGVjayxcbiAgY2FuQmxvY2tPckNhcHR1cmVDaGVja1xufTtcbiIsImNvbnN0IGZpbGVzID0gWydhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJywgJ2gnXTtcbmNvbnN0IHJhbmtzID0gWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDhdO1xuXG5leHBvcnQgeyBmaWxlcywgcmFua3MgfTtcbiIsImltcG9ydCB7IENhc3RsZU9iaiB9IGZyb20gJy4vdHlwZXMvaW50ZXJmYWNlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENhc3RsZShcbiAgd2hpdGVLaW5nc2lkZTogYm9vbGVhbixcbiAgd2hpdGVRdWVlbnNpZGU6IGJvb2xlYW4sXG4gIGJsYWNrS2luZ3NpZGU6IGJvb2xlYW4sXG4gIGJsYWNrUXVlZW5zaWRlOiBib29sZWFuXG4pOiBDYXN0bGVPYmoge1xuICByZXR1cm4ge1xuICAgIHdoaXRlOiB7XG4gICAgICBraW5nc2lkZTogd2hpdGVLaW5nc2lkZSxcbiAgICAgIHF1ZWVuc2lkZTogd2hpdGVRdWVlbnNpZGVcbiAgICB9LFxuICAgIGJsYWNrOiB7XG4gICAgICBraW5nc2lkZTogYmxhY2tLaW5nc2lkZSxcbiAgICAgIHF1ZWVuc2lkZTogYmxhY2tRdWVlbnNpZGVcbiAgICB9XG4gIH07XG59XG4iLCJpbXBvcnQge1xuICBnZXRMZWdhbE1vdmVzLFxuICBnZXREaXNjb3ZlcmVkQ2hlY2ssXG4gIGNhbkJsb2NrT3JDYXB0dXJlQ2hlY2ssXG4gIGdldEF0dGFja2luZ01vdmVzRm9yQ29sb3IsXG4gIGdldExlZ2FsTW92ZXNJbkNoZWNrXG59IGZyb20gJy4vdXRpbHMvbW92ZXMnO1xuaW1wb3J0IHsgdG9YWSwgZnJvbVhZLCBnZXRQaWVjZUZyb21BYmJyLCBwYXJzZU5vdGF0aW9uIH0gZnJvbSAnLi91dGlscy9oZWxwZXJzJztcbmltcG9ydCB7IHJhbmtzLCBmaWxlcyB9IGZyb20gJy4vcmFua3NBbmRGaWxlcyc7XG5pbXBvcnQge1xuICBDb2xvcixcbiAgU3F1YXJlLFxuICBCb2FyZCxcbiAgUGllY2VUeXBlLFxuICBNb3ZlcyxcbiAgQ2FzdGxlU3F1YXJlc1R5cGUsXG4gIEhpc3RvcnlUeXBlLFxuICBQaWVjZUFiYnJldmlhdGlvblxufSBmcm9tICcuL3R5cGVzL3R5cGVzJztcbmltcG9ydCB7XG4gIEFsbFBpZWNlTWFwLFxuICBDYXN0bGVPYmosXG4gIEVuUGFzc2FudE9iaixcbiAgR2FtZWJvYXJkT2JqLFxuICBQaWVjZU1hcCxcbiAgUGllY2VPYmosXG4gIFNxdWFyZU9ialxufSBmcm9tICcuL3R5cGVzL2ludGVyZmFjZXMnO1xuaW1wb3J0IENhc3RsZSBmcm9tICcuL0Nhc3RsZSc7XG5pbXBvcnQgeyBzdGFydGluZ1Bvc2l0aW9ucyB9IGZyb20gJy4vbWFpbic7XG5cbmZ1bmN0aW9uIGNyZWF0ZUJvYXJkKCk6IEJvYXJkIHtcbiAgcmV0dXJuIGZpbGVzLnJlZHVjZSgoYWNjLCBmaWxlKSA9PiB7XG4gICAgcmFua3MuZm9yRWFjaCgocmFuaykgPT4ge1xuICAgICAgY29uc3Qgc3F1YXJlID0gZmlsZS5jb25jYXQocmFuay50b1N0cmluZygpKTtcbiAgICAgIGFjYy5zZXQoc3F1YXJlLCB7IHBpZWNlOiBudWxsIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIG5ldyBNYXAoKSk7XG59XG5cbmNvbnN0IEdhbWVib2FyZCA9IChcbiAgYm9hcmQgPSBjcmVhdGVCb2FyZCgpLFxuICBzcXVhcmVzR2l2aW5nQ2hlY2s/OiBNb3ZlcyxcbiAgQ2FzdGxlUmlnaHRzPzogQ2FzdGxlT2JqXG4pOiBHYW1lYm9hcmRPYmogPT4ge1xuICBmdW5jdGlvbiBwbGFjZVBpZWNlcyhwaWVjZU1hcDogQWxsUGllY2VNYXAsIGJvYXJkTWFwID0gYm9hcmQpIHtcbiAgICBsZXQgY29sb3I6IGtleW9mIHR5cGVvZiBwaWVjZU1hcDtcbiAgICBmb3IgKGNvbG9yIGluIHBpZWNlTWFwKSB7XG4gICAgICBjb25zdCBtYXAgPSBwaWVjZU1hcFtjb2xvcl07XG5cbiAgICAgIGxldCBwaWVjZVR5cGU6IGtleW9mIHR5cGVvZiBtYXA7XG4gICAgICBmb3IgKHBpZWNlVHlwZSBpbiBtYXApIHtcbiAgICAgICAgY29uc3Qgc3F1YXJlcyA9IG1hcFtwaWVjZVR5cGVdO1xuICAgICAgICBzcXVhcmVzLmZvckVhY2goKHMpID0+XG4gICAgICAgICAgYXQocywgYm9hcmRNYXApLnBsYWNlKHsgdHlwZTogcGllY2VUeXBlLCBjb2xvcjogY29sb3IgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlTW92ZShcbiAgICBzMTogU3F1YXJlLFxuICAgIHMyOiBTcXVhcmUsXG4gICAgcHJvbW90ZT86IFBpZWNlVHlwZVxuICApOiBCb2FyZCB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgcGllY2UgPSBhdChzMSkucGllY2U7XG5cbiAgICAvLyB2YWxpZGF0ZSBtb3ZlXG4gICAgaWYgKCFwaWVjZSkgcmV0dXJuO1xuICAgIGlmICghdmFsaWRhdGUubW92ZShzMSwgczIpKSByZXR1cm47XG4gICAgaWYgKHByb21vdGUgJiYgIXZhbGlkYXRlLnByb21vdGlvbihzMSwgczIpKSByZXR1cm47XG5cbiAgICBzd2l0Y2ggKHBpZWNlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3Bhd24nOiB7XG4gICAgICAgIGlmIChwcm9tb3RlKSB7XG4gICAgICAgICAgYXQoczEpLnByb21vdGUocHJvbW90ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5QYXNzYW50LmlzQ2FwdHVyZShzMSwgczIpKSB7XG4gICAgICAgICAgZW5QYXNzYW50LmNhcHR1cmUoczIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZW5QYXNzYW50LnJlbW92ZSgpO1xuICAgICAgICBpZiAoZW5QYXNzYW50LmNoZWNrVG9nZ2xlKHMxLCBzMikpIHtcbiAgICAgICAgICBlblBhc3NhbnQudG9nZ2xlKHBpZWNlLmNvbG9yLCBzMik7XG4gICAgICAgIH1cblxuICAgICAgICBmcm9tKHMxKS50byhzMik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjYXNlICdraW5nJzoge1xuICAgICAgICAvLyBjaGVjayBpZiBtb3ZlIGlzIGNhc3RsZVxuICAgICAgICBsZXQgY2FzdGxlU2lkZTogJycgfCAncXVlZW5zaWRlJyB8ICdraW5nc2lkZScgPSAnJztcbiAgICAgICAgY29uc3QgY2FzdGxlU3F1YXJlcyA9IGdldC5jYXN0bGVTcXVhcmVzKHBpZWNlLmNvbG9yKTtcblxuICAgICAgICBmb3IgKGNvbnN0IFtzaWRlLCBzcXVhcmVzXSBvZiBPYmplY3QuZW50cmllcyhjYXN0bGVTcXVhcmVzKSkge1xuICAgICAgICAgIGlmIChzcXVhcmVzWzFdID09PSBzMikgY2FzdGxlU2lkZSA9IHNpZGUgYXMgJ2tpbmdzaWRlJyB8ICdxdWVlbnNpZGUnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNhc3RsZVNpZGUpIGNhc3RsZShwaWVjZS5jb2xvciwgY2FzdGxlU2lkZSk7XG4gICAgICAgIGVsc2UgZnJvbShzMSkudG8oczIpO1xuXG4gICAgICAgIGVuUGFzc2FudC5yZW1vdmUoKTtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZnJvbShzMSkudG8oczIpO1xuICAgICAgICBlblBhc3NhbnQucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJvYXJkO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FzdGxlKFxuICAgIGNvbG9yOiBDb2xvcixcbiAgICBzaWRlOiAna2luZ3NpZGUnIHwgJ3F1ZWVuc2lkZScsXG4gICAgYm9hcmRNYXAgPSBib2FyZFxuICApOiB2b2lkIHtcbiAgICBjb25zdCBjYXN0bGVTcXVhcmVzID0gZ2V0LmNhc3RsZVNxdWFyZXMoY29sb3IpW3NpZGVdO1xuXG4gICAgY29uc3Qga2luZ1BvcyA9IGdldC5raW5nUG9zaXRpb24oY29sb3IsIGJvYXJkTWFwKSBhcyBTcXVhcmU7XG4gICAgY29uc3Qgcm9va1BvcyA9IGdldFJvb2tQb3MoKSBhcyBTcXVhcmU7XG5cbiAgICBmcm9tKHJvb2tQb3MsIGJvYXJkTWFwKS50byhjYXN0bGVTcXVhcmVzWzBdKTtcbiAgICBmcm9tKGtpbmdQb3MsIGJvYXJkTWFwKS50byhjYXN0bGVTcXVhcmVzWzFdKTtcblxuICAgIGZ1bmN0aW9uIGdldFJvb2tQb3MoKSB7XG4gICAgICBjb25zdCBwaWVjZU1hcCA9IGdldC5waWVjZU1hcChib2FyZE1hcCk7XG4gICAgICBjb25zdCByb29rUG9zID0gcGllY2VNYXBbY29sb3JdLnJvb2suZmluZCgoc3F1YXJlKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSBzcXVhcmUuc3BsaXQoJycpWzBdO1xuICAgICAgICByZXR1cm4gc2lkZSA9PT0gJ2tpbmdzaWRlJ1xuICAgICAgICAgID8gZmlsZXMuaW5kZXhPZihmaWxlKSA+IDNcbiAgICAgICAgICA6IGZpbGVzLmluZGV4T2YoZmlsZSkgPCAzO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiByb29rUG9zO1xuICAgIH1cbiAgICAvLyBuZWVkIHRvIGdldCBraW5nIHBvc2l0aW9uXG4gICAgLy8gbmVlZCB0byBnZXQgY2FzdGxlIHNxdWFyZXNcbiAgICAvLyBuZWVkIHRvIGZpbmQgcm9va1xuICB9XG5cbiAgY29uc3QgZW5QYXNzYW50ID0gKCgpID0+IHtcbiAgICBmdW5jdGlvbiBnZXRTcXVhcmUoY3VycmVudDogU3F1YXJlLCBjb2xvcjogQ29sb3IpOiBTcXVhcmUge1xuICAgICAgY29uc3QgeyB4LCB5IH0gPSB0b1hZKGN1cnJlbnQpO1xuICAgICAgY29uc3QgbmV3WSA9IGNvbG9yID09PSAnd2hpdGUnID8geSAtIDEgOiB5ICsgMTtcbiAgICAgIHJldHVybiBmcm9tWFkoeyB4LCB5OiBuZXdZIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjaGVja1RvZ2dsZTogKGZyb206IFNxdWFyZSwgdG86IFNxdWFyZSk6IGJvb2xlYW4gPT4ge1xuICAgICAgICBjb25zdCB7IHk6IHkxIH0gPSB0b1hZKGZyb20pO1xuICAgICAgICBjb25zdCB7IHk6IHkyIH0gPSB0b1hZKHRvKTtcblxuICAgICAgICByZXR1cm4gTWF0aC5hYnMoeTEgLSB5MikgPT09IDI7XG4gICAgICB9LFxuICAgICAgdG9nZ2xlOiAoY29sb3I6IENvbG9yLCBjdXJyZW50OiBTcXVhcmUsIGJvYXJkTWFwID0gYm9hcmQpOiB2b2lkID0+IHtcbiAgICAgICAgY29uc3QgZW5QYXNzYW50U3F1YXJlID0gZ2V0U3F1YXJlKGN1cnJlbnQsIGNvbG9yKTtcbiAgICAgICAgYXQoZW5QYXNzYW50U3F1YXJlLCBib2FyZE1hcCkuc2V0RW5QYXNzYW50KGNvbG9yLCBjdXJyZW50KTtcbiAgICAgIH0sXG4gICAgICByZW1vdmU6IChib2FyZE1hcCA9IGJvYXJkKTogdm9pZCA9PiB7XG4gICAgICAgIGZvciAoY29uc3Qgc3F1YXJlT2JqIG9mIGJvYXJkTWFwLnZhbHVlcygpKSB7XG4gICAgICAgICAgaWYgKHNxdWFyZU9iai5lblBhc3NhbnQpIHJldHVybiAoc3F1YXJlT2JqLmVuUGFzc2FudCA9IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpc0NhcHR1cmU6IChmcm9tOiBTcXVhcmUsIHRvOiBTcXVhcmUsIGJvYXJkTWFwID0gYm9hcmQpOiBib29sZWFuID0+IHtcbiAgICAgICAgY29uc3QgcGllY2UgPSBhdChmcm9tLCBib2FyZE1hcCkucGllY2U7XG4gICAgICAgIGNvbnN0IGVuUGFzc2FudCA9IGJvYXJkTWFwLmdldCh0byk/LmVuUGFzc2FudDtcbiAgICAgICAgaWYgKCFwaWVjZSB8fCBwaWVjZS50eXBlICE9PSAncGF3bicpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFlblBhc3NhbnQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGVuUGFzc2FudC5jb2xvciA9PT0gcGllY2UuY29sb3IpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9LFxuICAgICAgY2FwdHVyZTogKHRvOiBTcXVhcmUsIGJvYXJkTWFwID0gYm9hcmQpID0+IHtcbiAgICAgICAgY29uc3QgZW5QYXNzYW50ID0gYm9hcmRNYXAuZ2V0KHRvKT8uZW5QYXNzYW50IGFzIEVuUGFzc2FudE9iajtcblxuICAgICAgICBhdChlblBhc3NhbnQuY3VycmVudCwgYm9hcmRNYXApLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH0pKCk7XG5cbiAgY29uc3QgYXQgPSAoc3F1YXJlOiBTcXVhcmUsIGJvYXJkTWFwID0gYm9hcmQpID0+ICh7XG4gICAgcGxhY2U6IChwaWVjZTogUGllY2VPYmopOiB2b2lkID0+IHtcbiAgICAgIGlmICghYm9hcmRNYXAuZ2V0KHNxdWFyZSkpIHJldHVybjtcblxuICAgICAgYm9hcmRNYXAuc2V0KHNxdWFyZSwgeyBwaWVjZSB9KTtcbiAgICB9LFxuICAgIHJlbW92ZTogKCk6IHZvaWQgPT4ge1xuICAgICAgaWYgKCFib2FyZE1hcC5nZXQoc3F1YXJlKSkgcmV0dXJuO1xuXG4gICAgICBib2FyZE1hcC5zZXQoc3F1YXJlLCB7IHBpZWNlOiBudWxsIH0pO1xuICAgIH0sXG4gICAgcHJvbW90ZTogKHBpZWNlVHlwZTogUGllY2VUeXBlKTogdm9pZCA9PiB7XG4gICAgICBjb25zdCBzcXVhcmVWYWwgPSBib2FyZE1hcC5nZXQoc3F1YXJlKTtcbiAgICAgIGNvbnN0IHBpZWNlID0gc3F1YXJlVmFsPy5waWVjZTtcbiAgICAgIGlmICghcGllY2UpIHJldHVybjtcblxuICAgICAgYm9hcmRNYXAuc2V0KHNxdWFyZSwge1xuICAgICAgICAuLi5zcXVhcmVWYWwsXG4gICAgICAgIHBpZWNlOiB7IC4uLnBpZWNlLCB0eXBlOiBwaWVjZVR5cGUgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBzZXRFblBhc3NhbnQ6IChjb2xvcjogQ29sb3IsIGN1cnJlbnQ6IFNxdWFyZSk6IHZvaWQgPT4ge1xuICAgICAgaWYgKCFib2FyZE1hcC5nZXQoc3F1YXJlKSkgcmV0dXJuO1xuXG4gICAgICBib2FyZE1hcC5zZXQoc3F1YXJlLCB7XG4gICAgICAgIHBpZWNlOiBudWxsLFxuICAgICAgICBlblBhc3NhbnQ6IHtcbiAgICAgICAgICBjdXJyZW50IC8qIHNxdWFyZSBwYXduIGlzIG9uICovLFxuICAgICAgICAgIGNvbG9yXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0IHBpZWNlKCkge1xuICAgICAgcmV0dXJuIGJvYXJkTWFwLmdldChzcXVhcmUpPy5waWVjZTtcbiAgICB9LFxuICAgIGdldExlZ2FsTW92ZXM6IChjaGVja3MgPSBzcXVhcmVzR2l2aW5nQ2hlY2sgfHwgW10pOiBNb3ZlcyA9PiB7XG4gICAgICBjb25zdCB7IHR5cGUsIGNvbG9yIH0gPSBhdChzcXVhcmUsIGJvYXJkTWFwKS5waWVjZSBhcyBQaWVjZU9iajtcblxuICAgICAgc3dpdGNoIChjaGVja3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgIGlmICh0eXBlICE9PSAna2luZycpIHJldHVybiBbXTtcbiAgICAgICAgICByZXR1cm4gZ2V0TGVnYWxNb3ZlcyhzcXVhcmUsIGJvYXJkTWFwKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICByZXR1cm4gZ2V0TGVnYWxNb3Zlc0luQ2hlY2soXG4gICAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICAgICBib2FyZE1hcCxcbiAgICAgICAgICAgIGdldC5raW5nUG9zaXRpb24oY29sb3IpIGFzIFNxdWFyZSxcbiAgICAgICAgICAgIGNoZWNrc1swXVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGlmICh0eXBlID09PSAna2luZycpIHtcbiAgICAgICAgICAgIGxldCBsZWdhbE1vdmVzID0gZ2V0TGVnYWxNb3ZlcyhzcXVhcmUsIGJvYXJkTWFwKTtcbiAgICAgICAgICAgIGlmIChnZXQuY2FuQ2FzdGxlKGNvbG9yLCAna2luZ3NpZGUnKSlcbiAgICAgICAgICAgICAgbGVnYWxNb3ZlcyA9IFtcbiAgICAgICAgICAgICAgICAuLi5sZWdhbE1vdmVzLFxuICAgICAgICAgICAgICAgIC4uLmdldC5jYXN0bGVTcXVhcmVzKGNvbG9yKS5raW5nc2lkZVxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgaWYgKGdldC5jYW5DYXN0bGUoY29sb3IsICdxdWVlbnNpZGUnKSlcbiAgICAgICAgICAgICAgbGVnYWxNb3ZlcyA9IFtcbiAgICAgICAgICAgICAgICAuLi5sZWdhbE1vdmVzLFxuICAgICAgICAgICAgICAgIC4uLmdldC5jYXN0bGVTcXVhcmVzKGNvbG9yKS5xdWVlbnNpZGVcbiAgICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgcmV0dXJuIGxlZ2FsTW92ZXM7XG4gICAgICAgICAgfSBlbHNlIHJldHVybiBnZXRMZWdhbE1vdmVzKHNxdWFyZSwgYm9hcmRNYXApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBjb25zdCBmcm9tID0gKHMxOiBTcXVhcmUsIGJvYXJkTWFwID0gYm9hcmQpID0+ICh7XG4gICAgdG86IChzMjogU3F1YXJlKTogdm9pZCA9PiB7XG4gICAgICBjb25zdCBwaWVjZSA9IGF0KHMxLCBib2FyZE1hcCkucGllY2U7XG4gICAgICBpZiAoIXBpZWNlKSByZXR1cm47XG5cbiAgICAgIC8vIG1vdmUgcGllY2VcbiAgICAgIGF0KHMxLCBib2FyZE1hcCkucmVtb3ZlKCk7XG4gICAgICBhdChzMiwgYm9hcmRNYXApLnBsYWNlKHBpZWNlKTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IGdldCA9IHtcbiAgICBraW5nUG9zaXRpb246IChjb2xvcjogQ29sb3IsIGJvYXJkTWFwID0gYm9hcmQpOiBTcXVhcmUgfCB1bmRlZmluZWQgPT4ge1xuICAgICAgZm9yIChjb25zdCBbc3F1YXJlLCB2YWx1ZV0gb2YgYm9hcmRNYXAuZW50cmllcygpKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB2YWx1ZS5waWVjZSAmJlxuICAgICAgICAgIHZhbHVlLnBpZWNlLnR5cGUgPT09ICdraW5nJyAmJlxuICAgICAgICAgIHZhbHVlLnBpZWNlLmNvbG9yID09PSBjb2xvclxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIHNxdWFyZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHBpZWNlTWFwOiAoYm9hcmRNYXAgPSBib2FyZCk6IEFsbFBpZWNlTWFwID0+IHtcbiAgICAgIGNvbnN0IHBpZWNlTWFwID0geyB3aGl0ZToge30gYXMgUGllY2VNYXAsIGJsYWNrOiB7fSBhcyBQaWVjZU1hcCB9O1xuICAgICAgZm9yIChjb25zdCBbc3F1YXJlLCB2YWx1ZV0gb2YgYm9hcmRNYXAuZW50cmllcygpKSB7XG4gICAgICAgIGNvbnN0IHsgcGllY2UgfSA9IHZhbHVlO1xuICAgICAgICBpZiAoIXBpZWNlKSBjb250aW51ZTtcblxuICAgICAgICBjb25zdCB7IHR5cGUsIGNvbG9yIH0gPSBwaWVjZTtcbiAgICAgICAgcGllY2VNYXBbY29sb3JdW3R5cGVdID0gcGllY2VNYXBbY29sb3JdW3R5cGVdXG4gICAgICAgICAgPyBbLi4ucGllY2VNYXBbY29sb3JdW3R5cGVdLCBzcXVhcmVdXG4gICAgICAgICAgOiBbc3F1YXJlXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwaWVjZU1hcDtcbiAgICB9LFxuICAgIHNxdWFyZXNHaXZpbmdDaGVja0FmdGVyTW92ZTogKGZyb206IFNxdWFyZSwgZW5kOiBTcXVhcmUpOiBTcXVhcmVbXSA9PiB7XG4gICAgICBjb25zdCBzcXVhcmVzR2l2aW5nQ2hlY2s6IHN0cmluZ1tdID0gW107XG5cbiAgICAgIGNvbnN0IHBpZWNlID0gYm9hcmQuZ2V0KGVuZCk/LnBpZWNlIGFzIFBpZWNlT2JqO1xuICAgICAgY29uc3Qgb3BwQ29sb3IgPSBwaWVjZS5jb2xvciA9PT0gJ3doaXRlJyA/ICdibGFjaycgOiAnd2hpdGUnO1xuICAgICAgY29uc3Qga2luZ1Bvc2l0aW9uID0gZ2V0LmtpbmdQb3NpdGlvbihvcHBDb2xvcikgYXMgU3F1YXJlO1xuXG4gICAgICBjb25zdCBwaWVjZUhpdHNLaW5nID0gZ2V0TGVnYWxNb3ZlcyhlbmQsIGJvYXJkKS5pbmNsdWRlcyhraW5nUG9zaXRpb24pO1xuICAgICAgaWYgKHBpZWNlSGl0c0tpbmcpIHNxdWFyZXNHaXZpbmdDaGVjay5wdXNoKGVuZCk7XG5cbiAgICAgIGNvbnN0IGRpc2NvdmVyZWRDaGVjayA9IGdldERpc2NvdmVyZWRDaGVjayhcbiAgICAgICAga2luZ1Bvc2l0aW9uLFxuICAgICAgICBvcHBDb2xvcixcbiAgICAgICAgZnJvbSxcbiAgICAgICAgYm9hcmRcbiAgICAgICk7XG4gICAgICBpZiAoZGlzY292ZXJlZENoZWNrKSBzcXVhcmVzR2l2aW5nQ2hlY2sucHVzaChkaXNjb3ZlcmVkQ2hlY2spO1xuXG4gICAgICByZXR1cm4gc3F1YXJlc0dpdmluZ0NoZWNrO1xuICAgIH0sXG4gICAgaXNDaGVja21hdGU6IChcbiAgICAgIGNvbG9yOiBDb2xvcixcbiAgICAgIHNxdWFyZXNHaXZpbmdDaGVjazogc3RyaW5nW10sXG4gICAgICBib2FyZE1hcCA9IGJvYXJkXG4gICAgKTogYm9vbGVhbiA9PiB7XG4gICAgICBjb25zdCBraW5nUG9zID0gZ2V0LmtpbmdQb3NpdGlvbihjb2xvciwgYm9hcmRNYXApIGFzIFNxdWFyZTtcbiAgICAgIGNvbnN0IGxlZ2FsTW92ZXMgPSBhdChraW5nUG9zLCBib2FyZE1hcCkuZ2V0TGVnYWxNb3ZlcygpO1xuICAgICAgLy8gY2hlY2sgaWYgY2hlY2sgY2FuIGJlIGJsb2NrZWRcbiAgICAgIGlmIChzcXVhcmVzR2l2aW5nQ2hlY2subGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmIChjYW5CbG9ja09yQ2FwdHVyZUNoZWNrKGtpbmdQb3MsIHNxdWFyZXNHaXZpbmdDaGVja1swXSwgYm9hcmRNYXApKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChsZWdhbE1vdmVzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBjYXN0bGVTcXVhcmVzKGNvbG9yOiBDb2xvcik6IENhc3RsZVNxdWFyZXNUeXBlIHtcbiAgICAgIGNvbnN0IHJhbmsgPSBjb2xvciA9PT0gJ3doaXRlJyA/IDEgOiA4O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2luZ3NpZGU6IFtgZiR7cmFua31gLCBgZyR7cmFua31gXSxcbiAgICAgICAgcXVlZW5zaWRlOiBbYGQke3Jhbmt9YCwgYGMke3Jhbmt9YF1cbiAgICAgIH07XG4gICAgfSxcbiAgICBjYXN0bGVSaWdodHNBZnRlck1vdmU6IChzcXVhcmU6IFNxdWFyZSwgYm9hcmRNYXAgPSBib2FyZCk6IENhc3RsZU9iaiA9PiB7XG4gICAgICBjb25zdCBwaWVjZSA9IGF0KHNxdWFyZSwgYm9hcmRNYXApLnBpZWNlIGFzIFBpZWNlT2JqO1xuXG4gICAgICBjb25zdCBjYXN0bGVSaWdodHMgPSBDYXN0bGVSaWdodHMgfHwgQ2FzdGxlKHRydWUsIHRydWUsIHRydWUsIHRydWUpO1xuXG4gICAgICBpZiAoXG4gICAgICAgIGNhc3RsZVJpZ2h0c1twaWVjZS5jb2xvcl0ua2luZ3NpZGUgfHxcbiAgICAgICAgY2FzdGxlUmlnaHRzW3BpZWNlLmNvbG9yXS5xdWVlbnNpZGVcbiAgICAgICkge1xuICAgICAgICAvLyBjaGVjayBpZiBpIG5lZWQgdG8gY2hhbmdlIGNhc3RsaW5nIHJpZ2h0c1xuICAgICAgICBpZiAocGllY2UudHlwZSA9PT0gJ2tpbmcnKSB7XG4gICAgICAgICAgY2FzdGxlUmlnaHRzW3BpZWNlLmNvbG9yXS5raW5nc2lkZSA9IGZhbHNlO1xuICAgICAgICAgIGNhc3RsZVJpZ2h0c1twaWVjZS5jb2xvcl0ucXVlZW5zaWRlID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGllY2UudHlwZSA9PT0gJ3Jvb2snKSB7XG4gICAgICAgICAgLy8gbmVlZCB0byBmaW5kIGlmIGl0IGlzIGtpbmdzaWRlIG9yIHF1ZWVuc2lkZSByb29rXG4gICAgICAgICAgY29uc3QgW2ZpbGVdID0gc3F1YXJlLnNwbGl0KCcnKTtcbiAgICAgICAgICBjb25zdCBraW5nc2lkZSA9IGZpbGVzLmluZGV4T2YoZmlsZSkgPiAzO1xuICAgICAgICAgIGlmIChraW5nc2lkZSkgY2FzdGxlUmlnaHRzW3BpZWNlLmNvbG9yXS5raW5nc2lkZSA9IGZhbHNlO1xuICAgICAgICAgIGVsc2UgY2FzdGxlUmlnaHRzW3BpZWNlLmNvbG9yXS5xdWVlbnNpZGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2FzdGxlUmlnaHRzO1xuICAgIH0sXG4gICAgY2FuQ2FzdGxlOiAoXG4gICAgICBjb2xvcjogQ29sb3IsXG4gICAgICBzaWRlOiAna2luZ3NpZGUnIHwgJ3F1ZWVuc2lkZScsXG4gICAgICBib2FyZE1hcCA9IGJvYXJkXG4gICAgKTogYm9vbGVhbiA9PiB7XG4gICAgICBpZiAoQ2FzdGxlUmlnaHRzICYmICFDYXN0bGVSaWdodHNbY29sb3JdW3NpZGVdKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIC8vIGNoZWNrIGlmIHJvb2sgc3RpbGwgZXhpc3RzXG4gICAgICBpZiAoIWNoZWNrSWZSb29rRXhpc3RzKCkpIHJldHVybiBmYWxzZTtcblxuICAgICAgY29uc3Qgb3BwQ29sb3IgPSBjb2xvciA9PT0gJ3doaXRlJyA/ICdibGFjaycgOiAnd2hpdGUnO1xuICAgICAgY29uc3Qgb3BwTW92ZXMgPSBnZXRBdHRhY2tpbmdNb3Zlc0ZvckNvbG9yKG9wcENvbG9yLCBib2FyZE1hcCk7XG5cbiAgICAgIGNvbnN0IGNhc3RsZVNxdWFyZXMgPSBnZXQuY2FzdGxlU3F1YXJlcyhjb2xvcilbc2lkZV07XG4gICAgICBmb3IgKGNvbnN0IHNxdWFyZSBvZiBjYXN0bGVTcXVhcmVzKSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIGNhc3RsZSBzcXVhcmUgaXMgY2xlYXJlZFxuICAgICAgICBpZiAoYXQoc3F1YXJlLCBib2FyZE1hcCkucGllY2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gbWFrZSBzdXJlIGNhc3RsZSBzcXVhcmUgaXNudCBhdHRhY2tlZFxuICAgICAgICBpZiAob3BwTW92ZXMuaW5jbHVkZXMoc3F1YXJlKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgZnVuY3Rpb24gY2hlY2tJZlJvb2tFeGlzdHMoKTogYm9vbGVhbiB7XG4gICAgICAgIGxldCByb29rRXhpc3RzID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHJhbmsgPSBjb2xvciA9PT0gJ3doaXRlJyA/IDEgOiA4O1xuICAgICAgICBjb25zdCBsb29wU3RhcnQgPVxuICAgICAgICAgIHNpZGUgPT09ICdxdWVlbnNpZGUnID8gZmlsZXMuaW5kZXhPZignYScpIDogZmlsZXMuaW5kZXhPZignZCcpO1xuICAgICAgICBjb25zdCBsb29wRW5kID1cbiAgICAgICAgICBzaWRlID09PSAncXVlZW5zaWRlJyA/IGZpbGVzLmluZGV4T2YoJ2UnKSA6IGZpbGVzLmluZGV4T2YoJ2gnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGxvb3BTdGFydDsgaSA8PSBsb29wRW5kOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBzcXVhcmUgPSBmaWxlc1tpXSArIHJhbms7XG5cbiAgICAgICAgICBjb25zdCBwaWVjZSA9IGF0KHNxdWFyZSwgYm9hcmRNYXApLnBpZWNlO1xuICAgICAgICAgIGlmICghcGllY2UpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgaWYgKHBpZWNlLnR5cGUgPT09ICdyb29rJykgcm9va0V4aXN0cyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvb2tFeGlzdHM7XG4gICAgICB9XG4gICAgfSxcbiAgICBib2FyZFN0YXRlRnJvbUhpc3Rvcnk6IChoaXN0b3J5OiBIaXN0b3J5VHlwZSk6IEJvYXJkID0+IHtcbiAgICAgIGNvbnN0IGJvYXJkTWFwID0gY3JlYXRlQm9hcmQoKTtcbiAgICAgIHBsYWNlUGllY2VzKHN0YXJ0aW5nUG9zaXRpb25zLnN0YW5kYXJkLCBib2FyZE1hcCk7XG4gICAgICBsZXQgcGllY2VNYXAgPSBzdGFydGluZ1Bvc2l0aW9ucy5zdGFuZGFyZDtcblxuICAgICAgLy8gaGlzdG9yeSBpcyAyZCBhcnJheVxuICAgICAgY29uc3QgZmxhdCA9IGhpc3RvcnkuZmxhdCgpO1xuXG4gICAgICAvKiBpdGVyYXRlIG92ZXIgaGlzdG9yeSAqL1xuICAgICAgZm9yIChjb25zdCBbaSwgbV0gb2YgZmxhdC5lbnRyaWVzKCkpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VOb3RhdGlvbihtKTtcbiAgICAgICAgY29uc3QgY29sb3IgPSBpICUgMiA9PT0gMCA/ICd3aGl0ZScgOiAnYmxhY2snO1xuXG4gICAgICAgIGlmIChwYXJzZWQuY2FzdGxlKSB7XG4gICAgICAgICAgY2FzdGxlKGNvbG9yLCBwYXJzZWQuY2FzdGxlLCBib2FyZE1hcCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwb3NzaWJsZVBpZWNlcyA9IHBpZWNlTWFwW2NvbG9yXVtwYXJzZWQucGllY2VUeXBlXS5maWx0ZXIoKHMpID0+XG4gICAgICAgICAgZ2V0TGVnYWxNb3ZlcyhzLCBib2FyZE1hcCkuaW5jbHVkZXMocGFyc2VkLnRvKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIGdldCAnZnJvbScgc3F1YXJlXG4gICAgICAgIGxldCBzMTogU3F1YXJlO1xuICAgICAgICBpZiAocGFyc2VkLmZyb20pIHtcbiAgICAgICAgICBjb25zdCBub3RhdGlvbiA9IHBhcnNlZC5mcm9tO1xuICAgICAgICAgIHMxID1cbiAgICAgICAgICAgIHBvc3NpYmxlUGllY2VzLmZpbmQoKHMpID0+IHtcbiAgICAgICAgICAgICAgLy8gaWYgbm90YXRpb24gaXMgYSBudW1iZXIsIHRoYXQgbWVhbnMgcGllY2UgaXMgb24gdGhlIHJhbmsgPT09IG5vdGF0aW9uLCBpZiBub3QsIHNhbWUgZmlsZVxuICAgICAgICAgICAgICByZXR1cm4gaXNOYU4oTnVtYmVyKG5vdGF0aW9uKSlcbiAgICAgICAgICAgICAgICA/IHNbMF0gPT09IG5vdGF0aW9uXG4gICAgICAgICAgICAgICAgOiBzWzFdID09PSBub3RhdGlvbjtcbiAgICAgICAgICAgIH0pIHx8ICcnO1xuICAgICAgICB9IGVsc2UgczEgPSBwb3NzaWJsZVBpZWNlc1swXTtcblxuICAgICAgICBjb25zdCBwaWVjZSA9IGF0KHMxLCBib2FyZE1hcCkucGllY2U7XG4gICAgICAgIGlmICghczEgfHwgIXBpZWNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYWtlIG1vdmVcbiAgICAgICAgaWYgKHBpZWNlLnR5cGUgPT09ICdwYXduJykge1xuICAgICAgICAgIGlmIChlblBhc3NhbnQuaXNDYXB0dXJlKHMxLCBwYXJzZWQudG8sIGJvYXJkTWFwKSkge1xuICAgICAgICAgICAgZW5QYXNzYW50LmNhcHR1cmUocGFyc2VkLnRvLCBib2FyZE1hcCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZW5QYXNzYW50LnJlbW92ZShib2FyZE1hcCk7XG5cbiAgICAgICAgICBpZiAoZW5QYXNzYW50LmNoZWNrVG9nZ2xlKHMxLCBwYXJzZWQudG8pKVxuICAgICAgICAgICAgZW5QYXNzYW50LnRvZ2dsZShjb2xvciwgcGFyc2VkLnRvLCBib2FyZE1hcCk7XG5cbiAgICAgICAgICBpZiAocGFyc2VkLnByb21vdGUpIHtcbiAgICAgICAgICAgIGF0KHMxLCBib2FyZE1hcCkucHJvbW90ZShwYXJzZWQucHJvbW90ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgZW5QYXNzYW50LnJlbW92ZShib2FyZE1hcCk7XG5cbiAgICAgICAgZnJvbShzMSwgYm9hcmRNYXApLnRvKHBhcnNlZC50byk7XG4gICAgICAgIHBpZWNlTWFwID0gZ2V0LnBpZWNlTWFwKGJvYXJkTWFwKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJvYXJkTWFwO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCB2YWxpZGF0ZSA9IHtcbiAgICBtb3ZlOiAoZnJvbTogU3F1YXJlLCB0bzogU3F1YXJlLCBib2FyZE1hcCA9IGJvYXJkKTogYm9vbGVhbiA9PiB7XG4gICAgICBjb25zdCBwaWVjZSA9IGF0KGZyb20sIGJvYXJkTWFwKS5waWVjZTtcbiAgICAgIGlmICghcGllY2UpIHJldHVybiBmYWxzZTtcblxuICAgICAgaWYgKCFhdChmcm9tLCBib2FyZE1hcCkuZ2V0TGVnYWxNb3ZlcygpLmluY2x1ZGVzKHRvKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIHByb21vdGlvbjogKGZyb206IFNxdWFyZSwgdG86IFNxdWFyZSwgYm9hcmRNYXAgPSBib2FyZCk6IGJvb2xlYW4gPT4ge1xuICAgICAgY29uc3QgcGllY2UgPSBhdChmcm9tLCBib2FyZE1hcCkucGllY2U7XG5cbiAgICAgIGlmIChwaWVjZT8udHlwZSAhPT0gJ3Bhd24nKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGNvbnN0IGVuZE9mQm9hcmQgPSBwaWVjZS5jb2xvciA9PT0gJ3doaXRlJyA/IDggOiAxO1xuICAgICAgY29uc3QgWywgcmFua10gPSB0by5zcGxpdCgnJyk7XG4gICAgICBpZiAoK3JhbmsgIT09IGVuZE9mQm9hcmQpIHJldHVybiBmYWxzZTtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgY3JlYXRlQm9hcmQsXG4gICAgcGxhY2VQaWVjZXMsXG4gICAgY2FzdGxlLFxuICAgIGVuUGFzc2FudCxcbiAgICBhdCxcbiAgICBmcm9tLFxuICAgIGdldCxcbiAgICB2YWxpZGF0ZSxcbiAgICBtYWtlTW92ZSxcbiAgICBnZXQgYm9hcmQoKSB7XG4gICAgICByZXR1cm4gYm9hcmQ7XG4gICAgfVxuICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgR2FtZWJvYXJkO1xuIiwiLy8gc2hvdWxkIG91dHB1dCBoaXN0b3J5IG9iamVjdCB0aGF0IGhvbGRzIG1vdmUgaGlzdG9yeSBpbiAyZCBhcnJheVxuLy8gZm9yIGVhY2ggbW92ZSBuZWVkcyB0byBhdHRhY2ggcGllY2UgVHlwZSB0byBiZWdpbm5pbmcgb2YgbW92ZSBpZiBub3QgcGF3blxuLy8gc2hvdWxkIGZ1cnRoZXIgc3BlY2lmeSBzcXVhcmUgb2YgcGllY2UgaWYsIHNheSBib3RoIHJvb2tzLCBjYW4gbW92ZSB0byBzYW1lIHNxdWFyZVxuXG5pbXBvcnQgeyBBbGxQaWVjZU1hcCwgSGlzdG9yeU9iaiwgUGllY2VPYmogfSBmcm9tICcuL3R5cGVzL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgQm9hcmQsIFBpZWNlVHlwZSwgU3F1YXJlLCBIaXN0b3J5VHlwZSB9IGZyb20gJy4vdHlwZXMvdHlwZXMnO1xuaW1wb3J0IHsgZ2V0TGVnYWxNb3ZlcyB9IGZyb20gJy4vdXRpbHMvbW92ZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBIaXN0b3J5KFxuICBwcmV2SGlzdG9yeTogSGlzdG9yeVR5cGUsXG4gIGJvYXJkOiBCb2FyZCxcbiAgcGllY2VNYXA6IEFsbFBpZWNlTWFwXG4pOiBIaXN0b3J5T2JqIHtcbiAgY29uc3QgaGlzdG9yeTogSGlzdG9yeVR5cGUgPSBwcmV2SGlzdG9yeSB8fCBbXTtcblxuICBjb25zdCBnZXQgPSB7XG4gICAgcGllY2VQcmVmaXg6IChmcm9tOiBTcXVhcmUsIHRvOiBTcXVhcmUpID0+IHtcbiAgICAgIGNvbnN0IHsgdHlwZSwgY29sb3IgfSA9IGJvYXJkLmdldCh0byk/LnBpZWNlIGFzIFBpZWNlT2JqO1xuXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAncGF3bic6XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICBjYXNlICdrbmlnaHQnOlxuICAgICAgICBjYXNlICdyb29rJzoge1xuICAgICAgICAgIGxldCBwcmVmaXggPSB0eXBlID09PSAncm9vaycgPyAnUicgOiAnTic7XG4gICAgICAgICAgaWYgKHBpZWNlTWFwW2NvbG9yXVt0eXBlXS5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgIC8vIGxvb2sgZm9yIHBpZWNlIG9mIHNhbWUgdHlwZSB0aGF0IGNvdWxkdmUgYWxzbyB3ZW50IHRvIHRoZSBzcXVhcmVcbiAgICAgICAgICAgIHBpZWNlTWFwW2NvbG9yXVt0eXBlXS5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChzID09PSB0bykgcmV0dXJuO1xuXG4gICAgICAgICAgICAgIGNvbnN0IGJvYXJkQ29weSA9IG5ldyBNYXAoYm9hcmQpO1xuICAgICAgICAgICAgICBib2FyZENvcHkuc2V0KHRvLCB7IHBpZWNlOiBudWxsIH0pO1xuXG4gICAgICAgICAgICAgIGlmIChnZXRMZWdhbE1vdmVzKHMsIGJvYXJkQ29weSkuaW5jbHVkZXModG8pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3gxLCB5MV0gPSBmcm9tLnNwbGl0KCcnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBbeDJdID0gcy5zcGxpdCgnJyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2FtZUZpbGUgPSB4MSA9PT0geDI7XG5cbiAgICAgICAgICAgICAgICBwcmVmaXggPSBzYW1lRmlsZSA/IHByZWZpeCArIHkxIDogcHJlZml4ICsgeDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBwcmVmaXg7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGNvbnN0IHByZWZpeCA9IHR5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgcmV0dXJuIHByZWZpeDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY2FzdGxlTm90YXRpb246IChzaWRlOiAna2luZ3NpZGUnIHwgJ3F1ZWVuc2lkZScpID0+IHtcbiAgICAgIHJldHVybiBzaWRlID09PSAna2luZ3NpZGUnID8gJ08tTycgOiAnTy1PLU8nO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBhZmZpeCA9IHtcbiAgICBjYXB0dXJlOiAobW92ZTogU3F1YXJlLCBwcmVmaXg6IHN0cmluZykgPT4ge1xuICAgICAgcmV0dXJuIGAke3ByZWZpeH14JHttb3ZlfWA7XG4gICAgfSxcbiAgICBwcm9tb3RlOiAobW92ZTogU3F1YXJlLCBwaWVjZVR5cGU6IFBpZWNlVHlwZSkgPT4ge1xuICAgICAgY29uc3Qgc3VmZml4ID1cbiAgICAgICAgcGllY2VUeXBlID09PSAna25pZ2h0JyA/ICdOJyA6IHBpZWNlVHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKTtcblxuICAgICAgcmV0dXJuIGAke21vdmV9PSR7c3VmZml4fWA7XG4gICAgfSxcbiAgICBjaGVjazogKG5vdGF0aW9uOiBzdHJpbmcpID0+IHtcbiAgICAgIHJldHVybiBgJHtub3RhdGlvbn0rYDtcbiAgICB9LFxuICAgIGNoZWNrbWF0ZTogKG5vdGF0aW9uOiBzdHJpbmcpID0+IHtcbiAgICAgIHJldHVybiBgJHtub3RhdGlvbn0jYDtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBnZXQsXG4gICAgYWZmaXgsXG4gICAgaW5zZXJ0TW92ZTogKG5vdGF0aW9uOiBzdHJpbmcpID0+IHtcbiAgICAgIGNvbnN0IGxhc3RNb3ZlUGFpciA9IGhpc3RvcnlbaGlzdG9yeS5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChsYXN0TW92ZVBhaXIubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGxhc3RNb3ZlUGFpci5wdXNoKG5vdGF0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5ld01vdmVQYWlyID0gW25vdGF0aW9uXTtcbiAgICAgICAgaGlzdG9yeS5wdXNoKG5ld01vdmVQYWlyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG4iLCJpbXBvcnQgeyBBbGxQaWVjZU1hcCB9IGZyb20gJy4vdHlwZXMvaW50ZXJmYWNlcyc7XG5cbmNvbnN0IHN0YW5kYXJkOiBBbGxQaWVjZU1hcCA9IHtcbiAgd2hpdGU6IHtcbiAgICByb29rOiBbJ2ExJywgJ2gxJ10sXG4gICAga25pZ2h0OiBbJ2cxJywgJ2IxJ10sXG4gICAgYmlzaG9wOiBbJ2YxJywgJ2MxJ10sXG4gICAga2luZzogWydlMSddLFxuICAgIHF1ZWVuOiBbJ2QxJ10sXG4gICAgcGF3bjogWydhMicsICdiMicsICdjMicsICdkMicsICdlMicsICdmMicsICdnMicsICdoMiddXG4gIH0sXG4gIGJsYWNrOiB7XG4gICAgcm9vazogWydhOCcsICdoOCddLFxuICAgIGtuaWdodDogWydnOCcsICdiOCddLFxuICAgIGJpc2hvcDogWydmOCcsICdjOCddLFxuICAgIGtpbmc6IFsnZTgnXSxcbiAgICBxdWVlbjogWydkOCddLFxuICAgIHBhd246IFsnYTcnLCAnYjcnLCAnYzcnLCAnZDcnLCAnZTcnLCAnZjcnLCAnZzcnLCAnaDcnXVxuICB9XG59O1xuXG5leHBvcnQgeyBzdGFuZGFyZCB9O1xuIiwiaW1wb3J0IEdhbWVib2FyZCBmcm9tICcuL0dhbWVib2FyZCc7XG5pbXBvcnQgSGlzdG9yeSBmcm9tICcuL0hpc3RvcnknO1xuaW1wb3J0IENhc3RsZSBmcm9tICcuL0Nhc3RsZSc7XG5pbXBvcnQgKiBhcyBzdGFydGluZ1Bvc2l0aW9ucyBmcm9tICcuL3N0YXJ0aW5nUG9zaXRpb25zJztcbmltcG9ydCB7IHJhbmtzLCBmaWxlcyB9IGZyb20gJy4vcmFua3NBbmRGaWxlcyc7XG5cbmV4cG9ydCB7IEdhbWVib2FyZCwgSGlzdG9yeSwgQ2FzdGxlLCBzdGFydGluZ1Bvc2l0aW9ucywgcmFua3MsIGZpbGVzIH07XG4iXSwibmFtZXMiOlsidG9YWSIsInNxdWFyZSIsIngiLCJ5Iiwic3BsaXQiLCJpbmRleE9mIiwidG9Mb3dlckNhc2UiLCJOdW1iZXIiLCJmcm9tWFkiLCJjb29yZCIsImNvbCIsImNvbmNhdCIsInRvU3RyaW5nIiwiY2FsY0Rpc3RhbmNlIiwic3F1YXJlT25lIiwic3F1YXJlVHdvIiwieDEiLCJ5MSIsIngyIiwieTIiLCJ4RGlmZiIsInlEaWZmIiwiZ2V0UGllY2VGcm9tQWJiciIsImFiYnIiLCJwYXJzZU5vdGF0aW9uIiwibm90YXRpb24iLCJtb3ZlIiwicmVwbGFjZWQiLCJyZXBsYWNlIiwiY2FzdGxlIiwibGVuZ3RoIiwidG9VcHBlckNhc2UiLCJwaWVjZVR5cGUiLCJ0byIsInNsaWNlIiwiZnJvbSIsImluY2x1ZGVzIiwicHJvbW90ZSIsInByb21vdGVOb3RlSW5kZXgiLCJub1Byb21vdGVOb3RhdGlvbiIsIm1vdmVzIiwiUGllY2UiLCJjb2xvciIsInR5cGUiLCJoYXNNb3ZlIiwib25lU3F1YXJlVmVydCIsInlCeU4iLCJ4QnlOIiwib25lU3F1YXJlTGF0ZXJhbCIsIm9uZVNxdWFyZURpYWdvbmFsbHkiLCJkaWFnb25hbCIsInZlcnRBbmRMYXRlcmFsIiwib25seU1vdmVzSW5Gcm9udCIsInJlZ3VsYXJNb3ZlIiwiZmlyc3RNb3ZlIiwianVtcFR3byIsImdldFBhd25DYXB0dXJlcyIsIm9yaWdpbiIsIm5ld1kiLCJjYXB0dXJlT25lIiwiY2FwdHVyZVR3byIsIk1hdGgiLCJhYnMiLCJudW0iLCJzcGxpdEludG9WZWN0b3JzIiwiYXJyYXlPZk1vdmVzIiwic3RhcnQiLCJyZWR1Y2UiLCJhY2MiLCJjdXJyIiwidmVjdG9yIiwiY2hhckF0IiwicHVzaCIsImdldEJlZ2lubmluZ09mVmVjdG9yIiwiYWNjSXNCZWdpbm5pbmciLCJnZXRNb3Zlc0Fsb25nVmVjdG9yIiwiczEiLCJzMiIsImFsbFNxdWFyZXMiLCJsaWVzU2FtZVZlcnRPckxhdCIsImxpZXNTYW1lRGlhZ29uYWxseSIsImxpZXNPblNhbWVMaW5lIiwibWF0Y2hpbmdWZWN0b3IiLCJzcXVhcmVzQWxvbmdWZWN0b3IiLCJmaWx0ZXIiLCJzIiwic29ydE1vdmVzQ2xvc2VzdFRvIiwic29ydCIsImEiLCJiIiwieDFEaWZmIiwieTFEaWZmIiwiYURpZmYiLCJ4MkRpZmYiLCJ5MkRpZmYiLCJiRGlmZiIsImdldFBvc3NpYmxlTW92ZXMiLCJib2FyZCIsIkFycmF5Iiwia2V5cyIsImdldCIsInBpZWNlIiwiZ2V0TGVnYWxNb3ZlcyIsInBvc3NpYmxlTW92ZXMiLCJvYnN0cnVjdGlvbnMiLCJfYSIsImxlZ2FsTW92ZXMiLCJjYXB0dXJlc0F2YWlsYWJsZSIsInVub2JzdHJ1Y3RlZE1vdmVzIiwicmVtb3ZlTW92ZXNXaXRoUGllY2VzIiwicmVtb3ZlT2JzdHJ1Y3RlZE1vdmVzIiwicmVtb3ZlUHJvdGVjdGVkU3F1YXJlcyIsImdldExlZ2FsTW92ZXNJbkNoZWNrIiwia2luZ1BvcyIsInNxdWFyZUdpdmluZ0NoZWNrIiwic3F1YXJlc1RoYXREZWFsV2l0aENoZWNrIiwiZ2V0U3F1YXJlc0JldHdlZW5LaW5nQW5kQ2hlY2siLCJnZXRBdHRhY2tpbmdNb3ZlcyIsImF0dGFja2luZ01vdmVzIiwiZ2V0QWxsTW92ZXNGb3JDb2xvciIsInNraXBLaW5nIiwiYWxsTW92ZXMiLCJlbnRyaWVzIiwiZmxhdCIsImdldEF0dGFja2luZ01vdmVzRm9yQ29sb3IiLCJwYXduU3F1YXJlIiwicGF3biIsImNhcHR1cmVNb3ZlcyIsInNxdWFyZVZhbCIsImVuUGFzc2FudCIsImNoZWNrUG9zIiwic3F1YXJlc0JldHdlZW5LaW5nQW5kUGllY2UiLCJyZW1vdmVNb3Zlc0JlaGluZFR3b1NxdWFyZXMiLCJzb3J0ZWQiLCJmdXJ0aGVzdFNxdWFyZSIsImNsb3Nlc3RTcXVhcmUiLCJyZW1vdmVkT25lRW5kIiwicmVtb3ZlTW92ZXNCZWhpbmRTcXVhcmUiLCJyZW1vdmVkQm90aEVuZHMiLCJyZXZlcnNlIiwiY29weSIsImluZGV4Iiwic3BsaWNlIiwic3RhcnRpbmdTcXVhcmUiLCJmaWx0ZXJlZE1vdmVzIiwiYWxsVmVjdG9ycyIsIm9ic3RydWN0aW9uVmVjdG9ycyIsImNsb3Nlc3RPYnN0cnVjdGlvbiIsImtpbmciLCJvcHBDb2xvciIsImJvYXJkQ29weSIsIk1hcCIsImZvckVhY2giLCJzZXQiLCJhbGxFbmVteU1vdmVzIiwiZ2V0RGlzY292ZXJlZENoZWNrIiwia2luZ0NvbG9yIiwidmFjYXRlZCIsImNhbkJsb2NrT3JDYXB0dXJlQ2hlY2siLCJibG9ja09yQ2FwdHVyZVNxdWFyZXMiLCJvd25QaWVjZU1vdmVzIiwic29tZSIsImdldFBpZWNlc1dpdGhNb3ZlIiwicGllY2VTcXVhcmVzIiwiZmlsZXMiLCJyYW5rcyIsIkNhc3RsZSIsIndoaXRlS2luZ3NpZGUiLCJ3aGl0ZVF1ZWVuc2lkZSIsImJsYWNrS2luZ3NpZGUiLCJibGFja1F1ZWVuc2lkZSIsIndoaXRlIiwia2luZ3NpZGUiLCJxdWVlbnNpZGUiLCJibGFjayIsInN0YXJ0aW5nUG9zaXRpb25zIiwiY3JlYXRlQm9hcmQiLCJmaWxlIiwicmFuayIsIkdhbWVib2FyZCIsInNxdWFyZXNHaXZpbmdDaGVjayIsIkNhc3RsZVJpZ2h0cyIsInBsYWNlUGllY2VzIiwicGllY2VNYXAiLCJib2FyZE1hcCIsIm1hcCIsInNxdWFyZXMiLCJhdCIsInBsYWNlIiwibWFrZU1vdmUiLCJ2YWxpZGF0ZSIsInByb21vdGlvbiIsImlzQ2FwdHVyZSIsImNhcHR1cmUiLCJyZW1vdmUiLCJjaGVja1RvZ2dsZSIsInRvZ2dsZSIsImNhc3RsZVNpZGUiLCJjYXN0bGVTcXVhcmVzIiwic2lkZSIsIk9iamVjdCIsImtpbmdQb3NpdGlvbiIsInJvb2tQb3MiLCJnZXRSb29rUG9zIiwicm9vayIsImZpbmQiLCJnZXRTcXVhcmUiLCJjdXJyZW50IiwiZW5QYXNzYW50U3F1YXJlIiwic2V0RW5QYXNzYW50Iiwic3F1YXJlT2JqIiwidmFsdWVzIiwidW5kZWZpbmVkIiwiY2hlY2tzIiwiY2FuQ2FzdGxlIiwidmFsdWUiLCJzcXVhcmVzR2l2aW5nQ2hlY2tBZnRlck1vdmUiLCJlbmQiLCJwaWVjZUhpdHNLaW5nIiwiZGlzY292ZXJlZENoZWNrIiwiaXNDaGVja21hdGUiLCJjYXN0bGVSaWdodHNBZnRlck1vdmUiLCJjYXN0bGVSaWdodHMiLCJjaGVja0lmUm9va0V4aXN0cyIsIm9wcE1vdmVzIiwicm9va0V4aXN0cyIsImxvb3BTdGFydCIsImxvb3BFbmQiLCJpIiwiYm9hcmRTdGF0ZUZyb21IaXN0b3J5IiwiaGlzdG9yeSIsInN0YW5kYXJkIiwibSIsInBhcnNlZCIsInBvc3NpYmxlUGllY2VzIiwiaXNOYU4iLCJlbmRPZkJvYXJkIiwiSGlzdG9yeSIsInByZXZIaXN0b3J5IiwicGllY2VQcmVmaXgiLCJwcmVmaXgiLCJzYW1lRmlsZSIsImNhc3RsZU5vdGF0aW9uIiwiYWZmaXgiLCJzdWZmaXgiLCJjaGVjayIsImNoZWNrbWF0ZSIsImluc2VydE1vdmUiLCJsYXN0TW92ZVBhaXIiLCJuZXdNb3ZlUGFpciIsImtuaWdodCIsImJpc2hvcCIsInF1ZWVuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///708\n")}},__webpack_require__={d:(Q,F)=>{for(var B in F)__webpack_require__.o(F,B)&&!__webpack_require__.o(Q,B)&&Object.defineProperty(Q,B,{enumerable:!0,get:F[B]})},o:(Q,F)=>Object.prototype.hasOwnProperty.call(Q,F),r:Q=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})}},__webpack_exports__={};return __webpack_modules__[708](0,__webpack_exports__,__webpack_require__),__webpack_exports__})()}));